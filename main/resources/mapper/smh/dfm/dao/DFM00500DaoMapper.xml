<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE mapper 
  PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN"
  "http://mybatis.org/dtd/mybatis-3-mapper.dtd">
<mapper namespace="smh.pcm.dao.DFM00500Dao">

   <!-- AOI 분석 전/후 비교 조회 -->
    <select id="getDefectRateByRepairNullList" parameterType="map" resultType="hashmap">
		--  getDefectRateByRepairNullList 품목코드 미입력시
			WITH	LOTLIST	AS 
			(
					SELECT	C.LOTSTARTDATE
						,	C.LOTID
						,	C.PRODUCTDEFID
						,	C.PRODUCTDEFVERSION
						,	C.PROCESSSEGMENTID
					FROM	PCM_LOT C
					WHERE	
                            --EXISTS
                        	C.LOTID IN		-- (21.06.17) 속도개선 lot 처럼 변경함 
							(	SELECT	A.LOTID		--1 (21.06.17) 속도개선 lot 처럼 변경함
								FROM	PCM_LOTWORKRESULT				A
										INNER JOIN	BAS_PROCESSSEGMENT	B	ON A.PROCESSSEGMENTID = B.PROCESSSEGMENTID 
								WHERE	1=1
					            -- (21.06.17) 속도개선 lot 처럼 변경함
				            	--AND		C.LOTID = A.LOTID
								AND		(
						          			
						          			-- (21.08.10) WORKENDTIME -> SENDTIME 변경
						          			(		B.PROCESSSEGMENTCLASSID = '7012'	
						          				AND	A.SENDTIME			-- (21.06.03  endtime로 다 변경)		A.WORKSTARTTIME 
						          				BETWEEN	TO_TIMESTAMP(#{P_PERIOD_PERIODFR}, 'YYYY-MM-DD HH24:MI:SS')	
									                					AND	TO_TIMESTAMP(#{P_PERIOD_PERIODTO}, 'YYYY-MM-DD HH24:MI:SS') 
					  						)
										)
							)
					<if test="P_LOTID != null and P_LOTID !='' and !(P_LOTID eq '*'.toString()) ">
						AND		C.LOTID = #{P_LOTID}
					</if>
					<if test="P_PRODUCTDEFID != null and P_PRODUCTDEFID !=''"> 
					  AND		C.PRODUCTDEFID = #{P_PRODUCTDEFID}
					</if>					
					<if test="P_PRODUCTDEFVERSION != null and P_PRODUCTDEFVERSION !='' and !(P_PRODUCTDEFVERSION eq '*'.toString()) ">
						AND		EXISTS
						(
							SELECT	1
							FROM	(SELECT DATA AS VALUE 
									  FROM TABLE(CAST(FN_TO_ROWS(#{P_PRODUCTDEFVERSION}) AS TP_SIMPLE_TABLE)) 
									) LMP
							WHERE	C.PRODUCTDEFVERSION = LMP.VALUE
						)
					</if>					
			)	
			
			-----------------------------(21.08.10) 인계 시간 조회
			, T_SENDTIME AS (
					SELECT	A.LOTID		
					, 			A.PROCESSSEGMENTID
					, 			MAX(A.SENDTIME) 		AS 	SENDTIME		       -- 인계 시간
					, 			B.PROCESSSEGMENTCLASSID
				FROM			PCM_LOTWORKRESULT				A
				INNER JOIN	BAS_PROCESSSEGMENT				B	
				ON  			A.PROCESSSEGMENTID = B.PROCESSSEGMENTID 
				AND 			B.PROCESSSEGMENTCLASSID IN ('7012','7014','7022')
				WHERE		1=1
				AND 			LOTID IN (
					SELECT LOTID
					  FROM LOTLIST
				)
				GROUP BY    A.LOTID		
					,       A.PROCESSSEGMENTID
					,       B.PROCESSSEGMENTCLASSID
			)
		-----------------------------
			
		SELECT 
			        '0'    AS  CHK
               ,	   A.PRODUCTDEFNAME  
               ,	   A.PRODUCTDEFID
			   ,	   A.PRODUCTDEFVERSION
			   ,	   A.LOTID
			   ,	    A.PROCESSSEGMENTID
			   ,	    A.PROCESSSEGMENTNAME 
               ,  	MAX(NVL(A.INSPECTIONQTY,0))   AS INSPECTIONQTY                
               ,  	SUM(NVL(A.REPAIRTARGETQTY, 0))	 AS ANALYSISTARGET
               ,    SUM(NVL(A.REPAIRRESULTQTY, 0))  AS ANALYSISRESULT
               ,    ROUND(DECODE(SUM(NVL(A.REPAIRTARGETQTY, 0)), 0, 0,  SUM(NVL(A.REPAIRRESULTQTY, 0))/ SUM(NVL(A.REPAIRTARGETQTY, 0))) * 100, 2) AS ANALYSISRATE
               ,    SUM(NVL(A.DEFECTCOUNT,0)) AS BEFOREDEFECTCNT
               ,    SUM(NVL(A.DEFECTCOUNT,0)) - SUM(NVL(A.REPAIRRESULTQTY, 0)) AS AFTERDEFECTCNT
               ,    ROUND(DECODE(MAX(NVL(A.INSPECTIONQTY,0)), 0, 0, SUM(NVL(A.DEFECTCOUNT,0))/ MAX(NVL(A.INSPECTIONQTY,0))) * 100, 2)  AS BEFOREDEFECTRATE               
               ,    ROUND(DECODE(MAX(NVL(A.INSPECTIONQTY,0)), 0, 0,  (SUM(NVL(A.DEFECTCOUNT,0)) - SUM(NVL(A.REPAIRRESULTQTY, 0)))/ MAX(NVL(A.INSPECTIONQTY,0))) * 100, 2)  AS AFTERDEFECTRATE        
               FROM
               (
               SELECT
					NVL(DIC2.DICTIONARYNAME, E.PRODUCTDEFNAME) 		AS PRODUCTDEFNAME                    
				,	A.PRODUCTDEFID
				,	A.PRODUCTDEFVERSION
				,	A.LOTID
				,	A.PROCESSSEGMENTID
				,	DIC.DICTIONARYNAME 		AS PROCESSSEGMENTNAME 
                ,	A.INSPECTIONQTY                
               ,    A.REPAIRTARGETQTY
               ,    A.REPAIRRESULTQTY                              
                ----------------------------------------------------------------(21.06.17)
                -- 블량 그룹 
                ,  (
                        CASE WHEN AOI.GROUPCODE = '005'  
                            THEN T_AFT_ANALYSIS.GROUPCODE
                            ELSE COALESCE(AOI.GROUPCODE, '999')
                            END
                    ) AS GROUPCODE
                -- 블량 그룹명 
                ,  (
                        CASE WHEN AOI.GROUPCODE = '005'  
                            THEN T_AFT_ANALYSIS.GROUPNAME
                            ELSE COALESCE(AOI.GROUPNAME, 'NONE')
                            END
                    ) AS GROUPNAME
                -- 불량 코드   
                ,	COALESCE(
                            CASE A.SEGMENTTYPE
                                WHEN 'AOIInspection' 
                                THEN (
                                       CASE WHEN AOI.GROUPCODE = '005'  
                                            THEN T_AFT_ANALYSIS.SUBCODE
                                            ELSE AOI.SUBCODE
                                            END 
                                    )
                                ELSE AOI.SUBCODE
                            END, '9999') 														AS	SUBCODE	 
                -- 불량 코드명
                ,	COALESCE(
                            CASE A.SEGMENTTYPE
                                WHEN 'AOIInspection' 
                                THEN (
                                       CASE WHEN AOI.GROUPCODE = '005'  
                                            THEN T_AFT_ANALYSIS.SUBNAME
                                            ELSE  AOI.SUBNAME
                                            END 
                                    )
                                ELSE AOI.SUBNAME
                            END, 'NONE')														AS	SUBNAME
                -- 불량 색상
                ,  COALESCE(
                            CASE A.SEGMENTTYPE
                                WHEN 'AOIInspection' 
                                THEN (
                                       CASE WHEN AOI.GROUPCODE = '005'  
                                            THEN T_AFT_ANALYSIS.COLOR
                                            ELSE AOI.COLOR
                                            END 
                                    )
                                ELSE AOI.COLOR
                            END, '#000000')														AS	COLOR
                    
                -- 불량 수량 
                , A.DEFECTCOUNT
               -----------------------------------------------------------------------------------------                   
		FROM PCM_QCAOIBBTWORKCOMPLETE	A
			INNER JOIN LOTLIST 					L	ON	A.LOTID = L.LOTID
													AND	A.PRODUCTDEFID = L.PRODUCTDEFID
													AND	A.PRODUCTDEFVERSION = L.PRODUCTDEFVERSION		
            -- (21.06.17) 완료된 상태 체크   -> (21.06.18) 여러건 존재함 하나만 나오도록 수정
            INNER JOIN (SELECT RESOURCEID
                            ,  INSPECTIONDEFID  
                            , PROCESSSEGMENTID, PROCESSSEGMENTVERSION
                         FROM  QAM_INSPECTIONRESULT   
                         GROUP BY  RESOURCEID, INSPECTIONDEFID    
                                    , PROCESSSEGMENTID, PROCESSSEGMENTVERSION
                         ) Q_INSP
            ON Q_INSP.RESOURCEID                 		=  A.LOTID
            AND Q_INSP.INSPECTIONDEFID 					= 	'AOIInspection'
            AND Q_INSP.PROCESSSEGMENTID					= A.PROCESSSEGMENTID
            AND Q_INSP.PROCESSSEGMENTVERSION			= A.PROCESSSEGMENTVERSION
            -----------------------------------------------------------------   	
            LEFT OUTER JOIN (
					SELECT	GRP.CODEID								AS	GROUPCODE
						,	GRP.GROUPNAME							AS	GROUPNAME
						,	GRP.DESCRIPTION 							AS	COLOR
						,	SUB.CODEID									AS	SUBCODE
						,	SUB.SUBNAME								AS	SUBNAME
						,	'AOIInspection'								AS	SEGMENTTYPE
						,   '005'                                       	AS  CHK_G_CODE
                                    ,   (
                                        CASE WHEN SUB.CODEID = '1001'
                                             THEN '5001'
                                             ELSE '5002'
                                             END
                                    )   													AS CHK_S_CODE
					FROM	
					(
						SELECT 	C.LOOKUP_CODE   AS CODEID
							,	C.DESCRIPTION
							,	D.DICTIONARYNAME						AS	GROUPNAME
						FROM 	CMD_LOOKUP_VALUES									C
						LEFT OUTER JOIN		CMD_DICTIONARY	D			ON	C.DICTIONARYID = D.DICTIONARYID						           	   			   		    
						WHERE	C.LOOKUP_TYPE = 'DefectMapDefectGroup'
						AND		C.ENABLED_FLAG = 'Y'
						AND		D.LANGUAGETYPE = #{LANGUAGETYPE}        -- 다국어 코드
					) 					GRP
					LEFT OUTER JOIN		
					(
						SELECT	C.LOOKUP_CODE   AS CODEID
							,	D.DICTIONARYNAME						AS	SUBNAME
							,	C.PARENTCODEID
						FROM	CMD_LOOKUP_VALUES									C
						LEFT OUTER JOIN 	CMD_DICTIONARY	D			ON 	C.DICTIONARYID = D.DICTIONARYID
						WHERE	C.LOOKUP_TYPE = 'DefectMapDefectGroupSub'
						AND		C.ENABLED_FLAG = 'Y'
						AND		D.LANGUAGETYPE = #{LANGUAGETYPE}        -- 다국어 코드
					) 					SUB								ON	GRP.CODEID = SUB.PARENTCODEID
					WHERE 1 = 1
                              AND GRP.CODEID IN ('001','002')
                              AND SUB.CODEID IN ('1001','2001')
				)   T_AFT_ANALYSIS
            ON A.SEGMENTTYPE = T_AFT_ANALYSIS.SEGMENTTYPE 
            AND A.DEFECTCODE = T_AFT_ANALYSIS.CHK_S_CODE
-----------------------------------------------------------------            	
		INNER JOIN	BAS_PROCESSSEGMENTEXT	C	ON A.PROCESSSEGMENTID = C.PROCESSSEGMENTID 
										  AND A.ENTERPRISEID = C.ENTERPRISEID  
		INNER JOIN BAS_PRODUCTDEFINITION E      ON 	A.PRODUCTDEFID = E.PRODUCTDEFID
											   AND  A.PRODUCTDEFVERSION  = E.PRODUCTDEFVERSION                                     
		LEFT OUTER JOIN (	
							SELECT
		                           'AOIInspection'                               AS SEGMENTTYPE	
		                        ,   GRP.CODEID									AS GROUPCODE
								,	GRP.GROUPNAME							AS GROUPNAME
								,	GRP.DESCRIPTION 							AS COLOR
								,	SUB.CODEID									AS SUBCODE
								,	SUB.SUBNAME								AS SUBNAME
							FROM	
							(
								SELECT 	C.LOOKUP_CODE   AS CODEID
									,	C.DESCRIPTION
									,	D.DICTIONARYNAME						AS GROUPNAME
								FROM 	CMD_LOOKUP_VALUES									C
								LEFT OUTER JOIN		CMD_DICTIONARY	D	ON	C.DICTIONARYID = D.DICTIONARYID						           	   			   		    
								WHERE	C.LOOKUP_TYPE = 'DefectMapDefectGroup'
								AND		C.ENABLED_FLAG = 'Y'
								AND		D.LANGUAGETYPE = #{LANGUAGETYPE} 
							) 					GRP
							LEFT OUTER JOIN		
							(
								SELECT	C.LOOKUP_CODE AS CODEID
									,	D.DICTIONARYNAME						AS SUBNAME
									,	C.PARENTCODEID
								FROM	CMD_LOOKUP_VALUES									C
								LEFT OUTER JOIN 	CMD_DICTIONARY	D	ON 	C.DICTIONARYID = D.DICTIONARYID
								WHERE	C.LOOKUP_TYPE = 'DefectMapDefectGroupSub'
								AND		C.ENABLED_FLAG = 'Y'
								AND		D.LANGUAGETYPE = #{LANGUAGETYPE} 
							) 					
							SUB		ON GRP.CODEID = SUB.PARENTCODEID              
						) AOI		ON A.DEFECTCODE = AOI.SUBCODE
						          AND A.SEGMENTTYPE = AOI.SEGMENTTYPE 
        LEFT JOIN CMD_DICTIONARY         	DIC	ON	DIC.DICTIONARYID = C.PROCESSSEGMENTNAME
                                                AND DIC.LANGUAGETYPE = #{LANGUAGETYPE}    
        LEFT JOIN CMD_DICTIONARY         	DIC2	ON	DIC2.DICTIONARYID = E.PRODUCTDEFNAME
                                                AND DIC2.LANGUAGETYPE = #{LANGUAGETYPE}    	 
                                                
                                                
		---------------------------------
		-- (21.07.09) 추가
        INNER JOIN BAS_PRODUCTDEFINITION E      ON 	A.PRODUCTDEFID = E.PRODUCTDEFID
											   AND  A.PRODUCTDEFVERSION  = E.PRODUCTDEFVERSION
		---------------------------------
		
		-----------------------------------(21.08.10) 인계 시간 조건 추가        
		LEFT JOIN T_SENDTIME TT 
				ON TT.LOTID             			= A.LOTID
			   AND TT.PROCESSSEGMENTID  	= A.PROCESSSEGMENTID
		-----------------------------
		
		
		WHERE 1 = 1
		  AND A.SEGMENTTYPE = 'AOIInspection'
		  AND A.ENTERPRISEID = #{P_ENTERPRISEID}
		  AND A.PLANTID = #{P_PLANTID}		  
		<if test="P_PERIOD_PERIODFR != null and P_PERIOD_PERIODFR !='' and P_PERIOD_PERIODTO != null and P_PERIOD_PERIODTO !=''">
		  
		  -- (21.08.10) 인계 시간 조건 추가  A.CREATEDTIME   --> TT.SENDTIME
		  AND TT.SENDTIME <![CDATA[>=]]> TO_TIMESTAMP(SUBSTR(#{P_PERIOD_PERIODFR},1,14), 'YYYYMMDDHH24MISS')
		  AND TT.SENDTIME <![CDATA[<]]>  TO_TIMESTAMP(TO_CHAR(TO_DATE(SUBSTR(#{P_PERIOD_PERIODTO},1,8), 'YYYYMMDD'), 'YYYY-MM-DD') || ' ' || SUBSTR(#{P_PERIOD_PERIODTO}, 9, 6), 'YYYY-MM-DD HH24:MI:SS') 
		</if>
		<if test="P_LOTID != null and P_LOTID !=''"> 
		  AND A.LOTID = #{P_LOTID}
		</if>
		<if test="P_PRODUCTDEFID != null and P_PRODUCTDEFID !=''"> 
		  AND A.PRODUCTDEFID = #{P_PRODUCTDEFID}
		</if>
		<if test="P_PRODUCTDEFVERSION != null and P_PRODUCTDEFVERSION !='' and !(P_PRODUCTDEFVERSION eq '*'.toString())">
		   AND	EXISTS
				(
					SELECT	1
					FROM	(SELECT DATA AS VALUE 
							  FROM TABLE(CAST(FN_TO_ROWS(#{P_PRODUCTDEFVERSION}) AS TP_SIMPLE_TABLE)) 
							) LMP
					WHERE	A.PRODUCTDEFVERSION = LMP.VALUE
				)
		</if>
		<if test="P_AOIPROCESS != null and P_AOIPROCESS !=''">
		    -- AOI 공정
			AND	 EXISTS (SELECT 1 FROM ufn_selectStringToSplit(#{P_AOIPROCESS},',') WHERE value = A.PROCESSSEGMENTID) 
		</if>
		
		<if test="P_PRODUCTIONTYPE != null and P_PRODUCTIONTYPE !='' and !(P_PRODUCTIONTYPE eq '*'.toString()) ">
			-- (21.07.09) 생산구분 추가
			AND 	E.PRODUCTIONTYPE 			= #{P_PRODUCTIONTYPE}
		</if>
		)  A
		GROUP BY 
					A.PRODUCTDEFNAME		
				,	A.PRODUCTDEFID
				,	A.PRODUCTDEFVERSION
				,	A.LOTID
				,	A.PROCESSSEGMENTID
				,	A.PROCESSSEGMENTNAME	
		ORDER BY 
					A.PRODUCTDEFNAME	
				,	A.PRODUCTDEFID
				,	A.PRODUCTDEFVERSION
				,	A.LOTID
				,	A.PROCESSSEGMENTID
				,	A.PROCESSSEGMENTNAME							
    </select>
    
   <!-- AOI 분석 전/후 비교 조회 -->
    <select id="getDefectRateByRepairList" parameterType="map" resultType="hashmap">
			--  getDefectRateByRepairList 품목코드 입력시
			WITH	LOTLIST	AS 
			(
					SELECT	C.LOTSTARTDATE
						,	C.LOTID
						,	C.PRODUCTDEFID
						,	C.PRODUCTDEFVERSION
						,	C.PROCESSSEGMENTID
					FROM	PCM_LOT C
					WHERE	
                            --EXISTS
                        	C.LOTID IN		-- (21.06.17) 속도개선 lot 처럼 변경함 
							(	SELECT	A.LOTID		--1 (21.06.17) 속도개선 lot 처럼 변경함
								FROM	PCM_LOTWORKRESULT				A
										INNER JOIN	BAS_PROCESSSEGMENT	B	ON A.PROCESSSEGMENTID = B.PROCESSSEGMENTID 
								WHERE	1=1
					            -- (21.06.17) 속도개선 lot 처럼 변경함
				            	--AND		C.LOTID = A.LOTID
								AND		(
						          			
						          			-- (21.08.10) WORKENDTIME -> SENDTIME 변경
						          			(		B.PROCESSSEGMENTCLASSID = '7012'	
						          				AND	A.SENDTIME			-- (21.06.03  endtime로 다 변경)		A.WORKSTARTTIME 
						          				BETWEEN	TO_TIMESTAMP(#{P_PERIOD_PERIODFR}, 'YYYY-MM-DD HH24:MI:SS')	
									                					AND	TO_TIMESTAMP(#{P_PERIOD_PERIODTO}, 'YYYY-MM-DD HH24:MI:SS') 
					  						)
										)
							)
					<if test="P_LOTID != null and P_LOTID !='' and !(P_LOTID eq '*'.toString()) ">
						AND		C.LOTID = #{P_LOTID}
					</if>
					<if test="P_PRODUCTDEFID != null and P_PRODUCTDEFID !=''"> 
					  AND		C.PRODUCTDEFID = #{P_PRODUCTDEFID}
					</if>					
					<if test="P_PRODUCTDEFVERSION != null and P_PRODUCTDEFVERSION !='' and !(P_PRODUCTDEFVERSION eq '*'.toString()) ">
						AND		EXISTS
						(
							SELECT	1
							FROM	(SELECT DATA AS VALUE 
									  FROM TABLE(CAST(FN_TO_ROWS(#{P_PRODUCTDEFVERSION}) AS TP_SIMPLE_TABLE)) 
									) LMP
							WHERE	C.PRODUCTDEFVERSION = LMP.VALUE
						)
					</if>	
			)			
			
			-----------------------------(21.08.10) 인계 시간 조회
			, T_SENDTIME AS (
					SELECT	A.LOTID		
					, 			A.PROCESSSEGMENTID
					, 			MAX(A.SENDTIME) 		AS 	SENDTIME		       -- 인계 시간
					, 			B.PROCESSSEGMENTCLASSID
				FROM			PCM_LOTWORKRESULT				A
				INNER JOIN	BAS_PROCESSSEGMENT				B	
				ON  			A.PROCESSSEGMENTID = B.PROCESSSEGMENTID 
				AND 			B.PROCESSSEGMENTCLASSID IN ('7012','7014','7022')
				WHERE		1=1
				AND 			LOTID IN (
					SELECT LOTID
					  FROM LOTLIST
				)
				GROUP BY    A.LOTID		
					,       A.PROCESSSEGMENTID
					,       B.PROCESSSEGMENTCLASSID
			)
		-----------------------------
			
			
		SELECT 
			        '0'    AS  CHK
			   ,   A.PRODUCTDEFID
			   ,	   A.PRODUCTDEFVERSION
			   ,	   A.LOTID
			   ,	   A.PROCESSSEGMENTID
			   ,	   A.PROCESSSEGMENTNAME 
               ,  	MAX(NVL(A.INSPECTIONQTY,0))   AS INSPECTIONQTY                
               ,  	SUM(NVL(A.REPAIRTARGETQTY, 0))	 AS ANALYSISTARGET
               ,    SUM(NVL(A.REPAIRRESULTQTY, 0))  AS ANALYSISRESULT
               ,    ROUND(DECODE(SUM(NVL(A.REPAIRTARGETQTY, 0)), 0, 0,  SUM(NVL(A.REPAIRRESULTQTY, 0))/ SUM(NVL(A.REPAIRTARGETQTY, 0))) * 100, 2)  AS ANALYSISRATE
               ,    SUM(NVL(A.DEFECTCOUNT,0)) AS BEFOREDEFECTCNT
               ,    SUM(NVL(A.DEFECTCOUNT,0)) - SUM(NVL(A.REPAIRRESULTQTY, 0)) AS AFTERDEFECTCNT
               ,    ROUND(DECODE(MAX(NVL(A.INSPECTIONQTY,0)), 0, 0, SUM(NVL(A.DEFECTCOUNT,0))/ MAX(NVL(A.INSPECTIONQTY,0))) * 100, 2) AS BEFOREDEFECTRATE               
               ,    ROUND(DECODE(MAX(NVL(A.INSPECTIONQTY,0)), 0, 0,  (SUM(NVL(A.DEFECTCOUNT,0)) - SUM(NVL(A.REPAIRRESULTQTY, 0)))/ MAX(NVL(A.INSPECTIONQTY,0))) * 100, 2) AS AFTERDEFECTRATE       
               FROM
               (
               SELECT                  
					A.PRODUCTDEFID
				,	A.PRODUCTDEFVERSION
				,	A.LOTID
				,	A.PROCESSSEGMENTID
				,	DIC.DICTIONARYNAME 		AS PROCESSSEGMENTNAME 
                ,	A.INSPECTIONQTY                
               ,    A.REPAIRTARGETQTY
               ,    A.REPAIRRESULTQTY 
                ----------------------------------------------------------------(21.06.17)
                -- 블량 그룹 
                ,  (
                        CASE WHEN AOI.GROUPCODE = '005'  
                            THEN T_AFT_ANALYSIS.GROUPCODE
                            ELSE COALESCE(AOI.GROUPCODE, '999')
                            END
                    ) AS GROUPCODE
                -- 블량 그룹명 
                ,  (
                        CASE WHEN AOI.GROUPCODE = '005'  
                            THEN T_AFT_ANALYSIS.GROUPNAME
                            ELSE COALESCE(AOI.GROUPNAME, 'NONE')
                            END
                    ) AS GROUPNAME
                -- 불량 코드   
                ,	COALESCE(
                            CASE A.SEGMENTTYPE
                                WHEN 'AOIInspection' 
                                THEN (
                                       CASE WHEN AOI.GROUPCODE = '005'  
                                            THEN T_AFT_ANALYSIS.SUBCODE
                                            ELSE AOI.SUBCODE
                                            END 
                                    )
                                ELSE AOI.SUBCODE
                            END, '9999') 														AS	SUBCODE	 
                -- 불량 코드명
                ,	COALESCE(
                            CASE A.SEGMENTTYPE
                                WHEN 'AOIInspection' 
                                THEN (
                                       CASE WHEN AOI.GROUPCODE = '005'  
                                            THEN T_AFT_ANALYSIS.SUBNAME
                                            ELSE  AOI.SUBNAME
                                            END 
                                    )
                                ELSE AOI.SUBNAME
                            END, 'NONE')														AS	SUBNAME
                -- 불량 색상
                ,  COALESCE(
                            CASE A.SEGMENTTYPE
                                WHEN 'AOIInspection' 
                                THEN (
                                       CASE WHEN AOI.GROUPCODE = '005'  
                                            THEN T_AFT_ANALYSIS.COLOR
                                            ELSE AOI.COLOR
                                            END 
                                    )
                                ELSE AOI.COLOR
                            END, '#000000')														AS	COLOR
                    
                -- 불량 수량 
                , A.DEFECTCOUNT
               -----------------------------------------------------------------------------------------                   
		FROM PCM_QCAOIBBTWORKCOMPLETE	A
			INNER JOIN LOTLIST 					L	ON	A.LOTID = L.LOTID
													AND	A.PRODUCTDEFID = L.PRODUCTDEFID
													AND	A.PRODUCTDEFVERSION = L.PRODUCTDEFVERSION				
            -- (21.06.17) 완료된 상태 체크   -> (21.06.18) 여러건 존재함 하나만 나오도록 수정
            INNER JOIN (SELECT RESOURCEID
                            ,  INSPECTIONDEFID  
                            , PROCESSSEGMENTID, PROCESSSEGMENTVERSION
                         FROM  QAM_INSPECTIONRESULT   
                         GROUP BY  RESOURCEID, INSPECTIONDEFID    
                                    , PROCESSSEGMENTID, PROCESSSEGMENTVERSION
                         ) Q_INSP
            ON Q_INSP.RESOURCEID                 		=  A.LOTID
            AND Q_INSP.INSPECTIONDEFID 					= 	'AOIInspection'
            AND Q_INSP.PROCESSSEGMENTID					= A.PROCESSSEGMENTID
            AND Q_INSP.PROCESSSEGMENTVERSION			= A.PROCESSSEGMENTVERSION
            -----------------------------------------------------------------   	
            LEFT OUTER JOIN (
					SELECT	GRP.CODEID								AS	GROUPCODE
						,	GRP.GROUPNAME							AS	GROUPNAME
						,	GRP.DESCRIPTION 							AS	COLOR
						,	SUB.CODEID									AS	SUBCODE
						,	SUB.SUBNAME								AS	SUBNAME
						,	'AOIInspection'								AS	SEGMENTTYPE
						,   '005'                                       	AS  CHK_G_CODE
                                    ,   (
                                        CASE WHEN SUB.CODEID = '1001'
                                             THEN '5001'
                                             ELSE '5002'
                                             END
                                    )   													AS CHK_S_CODE
					FROM	
					(
						SELECT 	C.LOOKUP_CODE   AS CODEID
							,	C.DESCRIPTION
							,	D.DICTIONARYNAME						AS	GROUPNAME
						FROM 	CMD_LOOKUP_VALUES									C
						LEFT OUTER JOIN		CMD_DICTIONARY	D			ON	C.DICTIONARYID = D.DICTIONARYID						           	   			   		    
						WHERE	C.LOOKUP_TYPE = 'DefectMapDefectGroup'
						AND		C.ENABLED_FLAG = 'Y'
						AND		D.LANGUAGETYPE = #{LANGUAGETYPE}        -- 다국어 코드
					) 					GRP
					LEFT OUTER JOIN		
					(
						SELECT	C.LOOKUP_CODE   AS CODEID
							,	D.DICTIONARYNAME						AS	SUBNAME
							,	C.PARENTCODEID
						FROM	CMD_LOOKUP_VALUES									C
						LEFT OUTER JOIN 	CMD_DICTIONARY	D			ON 	C.DICTIONARYID = D.DICTIONARYID
						WHERE	C.LOOKUP_TYPE = 'DefectMapDefectGroupSub'
						AND		C.ENABLED_FLAG = 'Y'
						AND		D.LANGUAGETYPE = #{LANGUAGETYPE}        -- 다국어 코드
					) 					SUB								ON	GRP.CODEID = SUB.PARENTCODEID
					WHERE 1 = 1
                              AND GRP.CODEID IN ('001','002')
                              AND SUB.CODEID IN ('1001','2001')
				)   T_AFT_ANALYSIS
            ON A.SEGMENTTYPE = T_AFT_ANALYSIS.SEGMENTTYPE 
            AND A.DEFECTCODE = T_AFT_ANALYSIS.CHK_S_CODE
-----------------------------------------------------------------     	
		INNER JOIN	BAS_PROCESSSEGMENTEXT	C	ON A.PROCESSSEGMENTID = C.PROCESSSEGMENTID 
										  AND A.ENTERPRISEID = C.ENTERPRISEID                                      
		LEFT OUTER JOIN (
							SELECT
		                            'AOIInspection'                              AS SEGMENTTYPE	
		                        ,    GRP.CODEID									AS GROUPCODE
								,	GRP.GROUPNAME							AS GROUPNAME
								,	GRP.DESCRIPTION 							AS COLOR
								,	SUB.CODEID									AS SUBCODE
								,	SUB.SUBNAME								AS SUBNAME
							FROM	
							(
								SELECT 	C.LOOKUP_CODE   AS CODEID
									,	C.DESCRIPTION
									,	D.DICTIONARYNAME						AS GROUPNAME
								FROM 	CMD_LOOKUP_VALUES									C
								LEFT OUTER JOIN		CMD_DICTIONARY	D	ON	C.DICTIONARYID = D.DICTIONARYID						           	   			   		    
								WHERE	C.LOOKUP_TYPE = 'DefectMapDefectGroup'
								AND		C.ENABLED_FLAG = 'Y'
								AND		D.LANGUAGETYPE = #{LANGUAGETYPE} 
							) 					GRP
							LEFT OUTER JOIN		
							(
								SELECT	C.LOOKUP_CODE AS CODEID
									,	D.DICTIONARYNAME						AS SUBNAME
									,	C.PARENTCODEID
								FROM	CMD_LOOKUP_VALUES									C
								LEFT OUTER JOIN 	CMD_DICTIONARY	D	ON 	C.DICTIONARYID = D.DICTIONARYID
								WHERE	C.LOOKUP_TYPE = 'DefectMapDefectGroupSub'
								AND		C.ENABLED_FLAG = 'Y'
								AND		D.LANGUAGETYPE = #{LANGUAGETYPE} 
							) 					
							SUB		ON GRP.CODEID = SUB.PARENTCODEID              
						) AOI		ON A.DEFECTCODE = AOI.SUBCODE
								  AND A.SEGMENTTYPE = AOI.SEGMENTTYPE						
        LEFT JOIN CMD_DICTIONARY         	DIC	ON	DIC.DICTIONARYID = C.PROCESSSEGMENTNAME
                                                AND DIC.LANGUAGETYPE = #{LANGUAGETYPE}   
                                                
		--------------------------------
		-- (21.07.09) 추가
        INNER JOIN BAS_PRODUCTDEFINITION E      ON 	A.PRODUCTDEFID = E.PRODUCTDEFID
											   AND  A.PRODUCTDEFVERSION  = E.PRODUCTDEFVERSION 
		--------------------------------
		
		-----------------------------------(21.08.10) 인계 시간 조건 추가        
		LEFT JOIN T_SENDTIME TT 
				ON TT.LOTID             			= A.LOTID
			   AND TT.PROCESSSEGMENTID  	= A.PROCESSSEGMENTID
		-----------------------------
		
		WHERE 1 = 1
		  AND A.SEGMENTTYPE = 'AOIInspection'
		  AND A.ENTERPRISEID = #{P_ENTERPRISEID}
		  AND A.PLANTID = #{P_PLANTID}		  
		<if test="P_PERIOD_PERIODFR != null and P_PERIOD_PERIODFR !='' and P_PERIOD_PERIODTO != null and P_PERIOD_PERIODTO !=''">
		  
		  -- (21.08.10) 인계 시간 조건 추가 A.CREATEDTIME  --> TT.SENDTIME
		  AND TT.SENDTIME <![CDATA[>=]]> TO_TIMESTAMP(SUBSTR(#{P_PERIOD_PERIODFR},1,14), 'YYYYMMDDHH24MISS')
		  AND TT.SENDTIME <![CDATA[<]]>  TO_TIMESTAMP(TO_CHAR(TO_DATE(SUBSTR(#{P_PERIOD_PERIODTO},1,8), 'YYYYMMDD'), 'YYYY-MM-DD') || ' ' || SUBSTR(#{P_PERIOD_PERIODTO}, 9, 6), 'YYYY-MM-DD HH24:MI:SS') 
		</if>
		<if test="P_LOTID != null and P_LOTID !=''"> 
		  AND A.LOTID = #{P_LOTID}
		</if>
		<if test="P_PRODUCTDEFID != null and P_PRODUCTDEFID !=''"> 
		  AND A.PRODUCTDEFID = #{P_PRODUCTDEFID}
		</if>
		<if test="P_PRODUCTDEFVERSION != null and P_PRODUCTDEFVERSION !='' and !(P_PRODUCTDEFVERSION eq '*'.toString())">
		   AND	EXISTS
				(
					SELECT	1
					FROM	(SELECT DATA AS VALUE 
							  FROM TABLE(CAST(FN_TO_ROWS(#{P_PRODUCTDEFVERSION}) AS TP_SIMPLE_TABLE)) 
							) LMP
					WHERE	A.PRODUCTDEFVERSION = LMP.VALUE
				)
		</if>
		<if test="P_AOIPROCESS != null and P_AOIPROCESS !=''">
			-- AOI 공정
			AND	 EXISTS (SELECT 1 FROM ufn_selectStringToSplit(#{P_AOIPROCESS},',') WHERE value = A.PROCESSSEGMENTID) 
		</if>
		
		<if test="P_PRODUCTIONTYPE != null and P_PRODUCTIONTYPE !='' and !(P_PRODUCTIONTYPE eq '*'.toString()) ">
			-- (21.07.09) 생산구분 추가
			AND 	E.PRODUCTIONTYPE 			= #{P_PRODUCTIONTYPE}
		</if>
		
		) A
		GROUP BY
		        A.PRODUCTDEFID 
			,	A.PRODUCTDEFVERSION
			,	A.LOTID
			,	A.PROCESSSEGMENTID
			,   A.PROCESSSEGMENTNAME
		ORDER BY
		       A.PRODUCTDEFID 
			,	A.PRODUCTDEFVERSION
			,	A.LOTID
			,	A.PROCESSSEGMENTID
			,   A.PROCESSSEGMENTNAME		
    </select>
 
    <!-- AOI 분석 전/후 비교 조회 -->
    <select id="getDefectRateByRepairNullChartTotal" parameterType="map" resultType="hashmap">
			--  getDefectRateByRepairNullChartTotal 품목코드 미입력시
			WITH	LOTLIST	AS 
			(
					SELECT	C.LOTSTARTDATE
						,	C.LOTID
						,	C.PRODUCTDEFID
						,	C.PRODUCTDEFVERSION
						,	C.PROCESSSEGMENTID
					FROM	PCM_LOT C
					WHERE	
                            --EXISTS
                        	C.LOTID IN		-- (21.06.17) 속도개선 lot 처럼 변경함 
							(	SELECT	A.LOTID		--1 (21.06.17) 속도개선 lot 처럼 변경함
								FROM	PCM_LOTWORKRESULT				A
										INNER JOIN	BAS_PROCESSSEGMENT	B	ON A.PROCESSSEGMENTID = B.PROCESSSEGMENTID 
								WHERE	1=1
					            -- (21.06.17) 속도개선 lot 처럼 변경함
				            	--AND		C.LOTID = A.LOTID
								AND		(
						          			
						          			-- (21.08.10) WORKENDTIME -> SENDTIME 변경
						          			(		B.PROCESSSEGMENTCLASSID = '7012'	
						          				AND	A.SENDTIME			-- (21.06.03  endtime로 다 변경)		A.WORKSTARTTIME 
						          				BETWEEN	TO_TIMESTAMP(#{P_PERIOD_PERIODFR}, 'YYYY-MM-DD HH24:MI:SS')	
									                					AND	TO_TIMESTAMP(#{P_PERIOD_PERIODTO}, 'YYYY-MM-DD HH24:MI:SS') 
					  						)
										)
							)
					<if test="P_LOTID != null and P_LOTID !='' and !(P_LOTID eq '*'.toString()) ">
						AND		C.LOTID = #{P_LOTID}
					</if>
					<if test="P_PRODUCTDEFID != null and P_PRODUCTDEFID !=''"> 
					  AND		C.PRODUCTDEFID = #{P_PRODUCTDEFID}
					</if>					
					<if test="P_PRODUCTDEFVERSION != null and P_PRODUCTDEFVERSION !='' and !(P_PRODUCTDEFVERSION eq '*'.toString()) ">
						AND		EXISTS
						(
							SELECT	1
							FROM	(SELECT DATA AS VALUE 
									  FROM TABLE(CAST(FN_TO_ROWS(#{P_PRODUCTDEFVERSION}) AS TP_SIMPLE_TABLE)) 
									) LMP
							WHERE	C.PRODUCTDEFVERSION = LMP.VALUE
						)
					</if>	
			)	
			
			-----------------------------(21.08.10) 인계 시간 조회
			, T_SENDTIME AS (
					SELECT	A.LOTID		
					, 			A.PROCESSSEGMENTID
					, 			MAX(A.SENDTIME) 		AS 	SENDTIME		       -- 인계 시간
					, 			B.PROCESSSEGMENTCLASSID
				FROM			PCM_LOTWORKRESULT				A
				INNER JOIN	BAS_PROCESSSEGMENT				B	
				ON  			A.PROCESSSEGMENTID = B.PROCESSSEGMENTID 
				AND 			B.PROCESSSEGMENTCLASSID IN ('7012','7014','7022')
				WHERE		1=1
				AND 			LOTID IN (
					SELECT LOTID
					  FROM LOTLIST
				)
				GROUP BY    A.LOTID		
					,       A.PROCESSSEGMENTID
					,       B.PROCESSSEGMENTCLASSID
			)
		-----------------------------
		
		
					
		SELECT
			  DECODE(NAME, 'BEFOREDEFECTRATE', 'BEFORERATE', 'AFTERRATE') AS CODE
			, DECODE(NAME, 'BEFOREDEFECTRATE', '전 불량률', '후 불량률') AS NAME
			, DATA
		FROM
		(	
		SELECT
			  ROUND(AVG(BEFOREDEFECTRATE), 2) AS BEFOREDEFECTRATE
			, ROUND(AVG(AFTERDEFECTRATE), 2)   AS AFTERDEFECTRATE
		FROM
		(
		SELECT 
                   A.PRODUCTDEFID
			   ,	   A.PRODUCTDEFVERSION
			   ,	   A.LOTID
			   ,	    A.PROCESSSEGMENTID 
               ,    ROUND(DECODE(MAX(NVL(A.INSPECTIONQTY,0)), 0, 0, SUM(NVL(A.DEFECTCOUNT,0))/ MAX(NVL(A.INSPECTIONQTY,0))) * 100, 2) AS BEFOREDEFECTRATE               
               ,    ROUND(DECODE(MAX(NVL(A.INSPECTIONQTY,0)), 0, 0,  (SUM(NVL(A.DEFECTCOUNT,0)) - SUM(NVL(A.REPAIRRESULTQTY, 0)))/ MAX(NVL(A.INSPECTIONQTY,0))) * 100, 2) AS AFTERDEFECTRATE  
               FROM
               (
               SELECT                   
					A.PRODUCTDEFID
				,	A.PRODUCTDEFVERSION
				,	A.LOTID
				,	A.PROCESSSEGMENTID 
                ,	A.INSPECTIONQTY                
               ,    A.REPAIRTARGETQTY
               ,    A.REPAIRRESULTQTY                
                ----------------------------------------------------------------(21.06.17)
                -- 블량 그룹 
                ,  (
                        CASE WHEN AOI.GROUPCODE = '005'  
                            THEN T_AFT_ANALYSIS.GROUPCODE
                            ELSE COALESCE(AOI.GROUPCODE, '999')
                            END
                    ) AS GROUPCODE
                -- 블량 그룹명 
                ,  (
                        CASE WHEN AOI.GROUPCODE = '005'  
                            THEN T_AFT_ANALYSIS.GROUPNAME
                            ELSE COALESCE(AOI.GROUPNAME, 'NONE')
                            END
                    ) AS GROUPNAME
                -- 불량 코드   
                ,	COALESCE(
                            CASE A.SEGMENTTYPE
                                WHEN 'AOIInspection' 
                                THEN (
                                       CASE WHEN AOI.GROUPCODE = '005'  
                                            THEN T_AFT_ANALYSIS.SUBCODE
                                            ELSE AOI.SUBCODE
                                            END 
                                    )
                                ELSE AOI.SUBCODE
                            END, '9999') 														AS	SUBCODE	 
                -- 불량 코드명
                ,	COALESCE(
                            CASE A.SEGMENTTYPE
                                WHEN 'AOIInspection' 
                                THEN (
                                       CASE WHEN AOI.GROUPCODE = '005'  
                                            THEN T_AFT_ANALYSIS.SUBNAME
                                            ELSE  AOI.SUBNAME
                                            END 
                                    )
                                ELSE AOI.SUBNAME
                            END, 'NONE')														AS	SUBNAME
                -- 불량 색상
                ,  COALESCE(
                            CASE A.SEGMENTTYPE
                                WHEN 'AOIInspection' 
                                THEN (
                                       CASE WHEN AOI.GROUPCODE = '005'  
                                            THEN T_AFT_ANALYSIS.COLOR
                                            ELSE AOI.COLOR
                                            END 
                                    )
                                ELSE AOI.COLOR
                            END, '#000000')														AS	COLOR
                    
                -- 불량 수량 
                , A.DEFECTCOUNT
               -----------------------------------------------------------------------------------------                   
		FROM PCM_QCAOIBBTWORKCOMPLETE	A  
			INNER JOIN LOTLIST 					L	ON	A.LOTID = L.LOTID
													AND	A.PRODUCTDEFID = L.PRODUCTDEFID
													AND	A.PRODUCTDEFVERSION = L.PRODUCTDEFVERSION				    
            -- (21.06.17) 완료된 상태 체크   -> (21.06.18) 여러건 존재함 하나만 나오도록 수정
            INNER JOIN (SELECT RESOURCEID
                            ,  INSPECTIONDEFID  
                            , PROCESSSEGMENTID, PROCESSSEGMENTVERSION
                         FROM  QAM_INSPECTIONRESULT   
                         GROUP BY  RESOURCEID, INSPECTIONDEFID    
                                    , PROCESSSEGMENTID, PROCESSSEGMENTVERSION
                         ) Q_INSP
            ON Q_INSP.RESOURCEID                 		=  A.LOTID
            AND Q_INSP.INSPECTIONDEFID 					= 	'AOIInspection'
            AND Q_INSP.PROCESSSEGMENTID					= A.PROCESSSEGMENTID
            AND Q_INSP.PROCESSSEGMENTVERSION			= A.PROCESSSEGMENTVERSION
            -----------------------------------------------------------------   	
            LEFT OUTER JOIN (
					SELECT	GRP.CODEID								AS	GROUPCODE
						,	GRP.GROUPNAME							AS	GROUPNAME
						,	GRP.DESCRIPTION 							AS	COLOR
						,	SUB.CODEID									AS	SUBCODE
						,	SUB.SUBNAME								AS	SUBNAME
						,	'AOIInspection'								AS	SEGMENTTYPE
						,   '005'                                       	AS  CHK_G_CODE
                                    ,   (
                                        CASE WHEN SUB.CODEID = '1001'
                                             THEN '5001'
                                             ELSE '5002'
                                             END
                                    )   													AS CHK_S_CODE
					FROM	
					(
						SELECT 	C.LOOKUP_CODE   AS CODEID
							,	C.DESCRIPTION
							,	D.DICTIONARYNAME						AS	GROUPNAME
						FROM 	CMD_LOOKUP_VALUES									C
						LEFT OUTER JOIN		CMD_DICTIONARY	D			ON	C.DICTIONARYID = D.DICTIONARYID						           	   			   		    
						WHERE	C.LOOKUP_TYPE = 'DefectMapDefectGroup'
						AND		C.ENABLED_FLAG = 'Y'
						AND		D.LANGUAGETYPE = #{LANGUAGETYPE}        -- 다국어 코드
					) 					GRP
					LEFT OUTER JOIN		
					(
						SELECT	C.LOOKUP_CODE   AS CODEID
							,	D.DICTIONARYNAME						AS	SUBNAME
							,	C.PARENTCODEID
						FROM	CMD_LOOKUP_VALUES									C
						LEFT OUTER JOIN 	CMD_DICTIONARY	D			ON 	C.DICTIONARYID = D.DICTIONARYID
						WHERE	C.LOOKUP_TYPE = 'DefectMapDefectGroupSub'
						AND		C.ENABLED_FLAG = 'Y'
						AND		D.LANGUAGETYPE = #{LANGUAGETYPE}        -- 다국어 코드
					) 					SUB								ON	GRP.CODEID = SUB.PARENTCODEID
					WHERE 1 = 1
                              AND GRP.CODEID IN ('001','002')
                              AND SUB.CODEID IN ('1001','2001')
				)   T_AFT_ANALYSIS
            ON A.SEGMENTTYPE = T_AFT_ANALYSIS.SEGMENTTYPE 
            AND A.DEFECTCODE = T_AFT_ANALYSIS.CHK_S_CODE
-----------------------------------------------------------------     	                              
		LEFT OUTER JOIN (	
							SELECT	
									'AOIInspection'                             AS SEGMENTTYPE
		                        ,   GRP.CODEID									AS GROUPCODE
								,	GRP.GROUPNAME							AS GROUPNAME
								,	GRP.DESCRIPTION 							AS COLOR
								,	SUB.CODEID									AS SUBCODE
								,	SUB.SUBNAME								AS SUBNAME
							FROM	
							(
								SELECT 	C.LOOKUP_CODE   AS CODEID
									,	C.DESCRIPTION
									,	D.DICTIONARYNAME						AS GROUPNAME
								FROM 	CMD_LOOKUP_VALUES									C
								LEFT OUTER JOIN		CMD_DICTIONARY	D	ON	C.DICTIONARYID = D.DICTIONARYID						           	   			   		    
								WHERE	C.LOOKUP_TYPE = 'DefectMapDefectGroup'
								AND		C.ENABLED_FLAG = 'Y'
								AND		D.LANGUAGETYPE = #{LANGUAGETYPE} 
							) 					GRP
							LEFT OUTER JOIN		
							(
								SELECT	C.LOOKUP_CODE AS CODEID
									,	D.DICTIONARYNAME						AS SUBNAME
									,	C.PARENTCODEID
								FROM	CMD_LOOKUP_VALUES									C
								LEFT OUTER JOIN 	CMD_DICTIONARY	D	ON 	C.DICTIONARYID = D.DICTIONARYID
								WHERE	C.LOOKUP_TYPE = 'DefectMapDefectGroupSub'
								AND		C.ENABLED_FLAG = 'Y'
								AND		D.LANGUAGETYPE = #{LANGUAGETYPE} 
							) 					
							SUB		ON GRP.CODEID = SUB.PARENTCODEID              
						) AOI		ON A.DEFECTCODE = AOI.SUBCODE 
                                  AND A.SEGMENTTYPE = AOI.SEGMENTTYPE
                                  
		---------------------------------
		-- (21.07.12) 추가
        INNER JOIN BAS_PRODUCTDEFINITION E      ON 	A.PRODUCTDEFID = E.PRODUCTDEFID
											   AND  A.PRODUCTDEFVERSION  = E.PRODUCTDEFVERSION
		---------------------------------
		
		-----------------------------------(21.08.10) 인계 시간 조건 추가        
		LEFT JOIN T_SENDTIME TT 
				ON TT.LOTID             			= A.LOTID
			   AND TT.PROCESSSEGMENTID  	= A.PROCESSSEGMENTID
		-----------------------------
		
		WHERE 1 = 1
		  AND A.SEGMENTTYPE = 'AOIInspection'
		  AND A.ENTERPRISEID = #{P_ENTERPRISEID}
		  AND A.PLANTID = #{P_PLANTID}		  
		<if test="P_PERIOD_PERIODFR != null and P_PERIOD_PERIODFR !='' and P_PERIOD_PERIODTO != null and P_PERIOD_PERIODTO !=''">
		  -- (21.08.10) 인계 시간 조건 추가  A.CREATEDTIME -> TT.SENDTIME
		  AND TT.SENDTIME <![CDATA[>=]]> TO_TIMESTAMP(SUBSTR(#{P_PERIOD_PERIODFR},1,14), 'YYYYMMDDHH24MISS')
		  AND TT.SENDTIME <![CDATA[<]]>  TO_TIMESTAMP(TO_CHAR(TO_DATE(SUBSTR(#{P_PERIOD_PERIODTO},1,8), 'YYYYMMDD'), 'YYYY-MM-DD') || ' ' || SUBSTR(#{P_PERIOD_PERIODTO}, 9, 6), 'YYYY-MM-DD HH24:MI:SS') 
		</if>
		<if test="LOTID_LIST.length != 0">
                AND		A.LOTID IN
	           <foreach collection="LOTID_LIST" item="item" index="index" separator="," open="(" close=")">
	                    #{item}
	           </foreach>				
		</if>	
		<if test="PROCESSSEGMENTID_LIST.length != 0">
                AND		A.PROCESSSEGMENTID IN
	           <foreach collection="PROCESSSEGMENTID_LIST" item="item" index="index" separator="," open="(" close=")">
	                    #{item}
	           </foreach>				
		</if>		
		<if test="PRODUCTDEFIDVER_LIST.length != 0">
                AND		A.PRODUCTDEFID || A.PRODUCTDEFVERSION IN
	           <foreach collection="PRODUCTDEFIDVER_LIST" item="item" index="index" separator="," open="(" close=")">
	                    #{item}
	           </foreach>				
		</if>
		<if test="P_PROCESSSEGMENTID != null and P_PROCESSSEGMENTID !=''">
		   AND		A.PROCESSSEGMENTID = #{P_PROCESSSEGMENTID}
		</if>			
		<if test="P_AOIPROCESS != null and P_AOIPROCESS !=''">
			-- AOI 공정
			AND	 EXISTS (SELECT 1 FROM ufn_selectStringToSplit(#{P_AOIPROCESS},',') WHERE value = A.PROCESSSEGMENTID) 
		</if>
		
		<if test="P_PRODUCTIONTYPE != null and P_PRODUCTIONTYPE !='' and !(P_PRODUCTIONTYPE eq '*'.toString()) ">
			-- (21.07.12) 생산구분 추가
			AND 	E.PRODUCTIONTYPE 			= #{P_PRODUCTIONTYPE}
		</if>
		
		  ) A
		GROUP BY 	
					A.PRODUCTDEFID
				,	A.PRODUCTDEFVERSION
				,	A.LOTID
				,	A.PROCESSSEGMENTID	
		  )	  
		)
		UNPIVOT( DATA FOR NAME IN (BEFOREDEFECTRATE, AFTERDEFECTRATE))
    </select>
    
  <!-- AOI 분석 전/후 비교 조회 -->
    <select id="getDefectRateByRepairChartTotal" parameterType="map" resultType="hashmap">
			--  getDefectRateByRepairChartTotal 품목코드 입력시
			WITH	LOTLIST	AS 
			(
					SELECT	C.LOTSTARTDATE
						,	C.LOTID
						,	C.PRODUCTDEFID
						,	C.PRODUCTDEFVERSION
						,	C.PROCESSSEGMENTID
					FROM	PCM_LOT C
					WHERE	
                            --EXISTS
                        	C.LOTID IN		-- (21.06.17) 속도개선 lot 처럼 변경함 
							(	SELECT	A.LOTID		--1 (21.06.17) 속도개선 lot 처럼 변경함
								FROM	PCM_LOTWORKRESULT				A
										INNER JOIN	BAS_PROCESSSEGMENT	B	ON A.PROCESSSEGMENTID = B.PROCESSSEGMENTID 
								WHERE	1=1
					            -- (21.06.17) 속도개선 lot 처럼 변경함
				            	--AND		C.LOTID = A.LOTID
								AND		(
						          			
						          			-- (21.08.10) WORKENDTIME -> SENDTIME 변경
						          			(		B.PROCESSSEGMENTCLASSID = '7012'	
						          				AND	A.SENDTIME			-- (21.06.03  endtime로 다 변경)		A.WORKSTARTTIME 
						          				BETWEEN	TO_TIMESTAMP(#{P_PERIOD_PERIODFR}, 'YYYY-MM-DD HH24:MI:SS')	
									                					AND	TO_TIMESTAMP(#{P_PERIOD_PERIODTO}, 'YYYY-MM-DD HH24:MI:SS') 
					  						)
										)
							)
					<if test="P_LOTID != null and P_LOTID !='' and !(P_LOTID eq '*'.toString()) ">
						AND		C.LOTID = #{P_LOTID}
					</if>
					<if test="P_PRODUCTDEFID != null and P_PRODUCTDEFID !=''"> 
					  AND		C.PRODUCTDEFID = #{P_PRODUCTDEFID}
					</if>					
					<if test="P_PRODUCTDEFVERSION != null and P_PRODUCTDEFVERSION !='' and !(P_PRODUCTDEFVERSION eq '*'.toString()) ">
						AND		EXISTS
						(
							SELECT	1
							FROM	(SELECT DATA AS VALUE 
									  FROM TABLE(CAST(FN_TO_ROWS(#{P_PRODUCTDEFVERSION}) AS TP_SIMPLE_TABLE)) 
									) LMP
							WHERE	C.PRODUCTDEFVERSION = LMP.VALUE
						)
					</if>
			)	
			
			-----------------------------(21.08.10) 인계 시간 조회
			, T_SENDTIME AS (
					SELECT	A.LOTID		
					, 			A.PROCESSSEGMENTID
					, 			MAX(A.SENDTIME) 		AS 	SENDTIME		       -- 인계 시간
					, 			B.PROCESSSEGMENTCLASSID
				FROM			PCM_LOTWORKRESULT				A
				INNER JOIN	BAS_PROCESSSEGMENT				B	
				ON  			A.PROCESSSEGMENTID = B.PROCESSSEGMENTID 
				AND 			B.PROCESSSEGMENTCLASSID IN ('7012','7014','7022')
				WHERE		1=1
				AND 			LOTID IN (
					SELECT LOTID
					  FROM LOTLIST
				)
				GROUP BY    A.LOTID		
					,       A.PROCESSSEGMENTID
					,       B.PROCESSSEGMENTCLASSID
			)
		-----------------------------
			
					
		SELECT	
			   A.PROCESSSEGMENTID					AS CODE
		   ,   A.PROCESSSEGMENTNAME			AS NAME
		   --,   ROUND(AVG(DATA1), 2)                AS DATA1             
		   --,   ROUND(AVG(DATA2), 2) 				 AS DATA2
		   ---------------------------------------------------------------
		   -- (21.07.15) 검사수 때문에 수정
		   ,   ROUND(DECODE(SUM(NVL(A.INSPECTIONQTY,0)), 0, 0, SUM(NVL(A.LOT_DEFECT_CNT,0))/ SUM(NVL(A.INSPECTIONQTY,0))) * 100, 2) AS DATA1               
		   ,   ROUND(DECODE(SUM(NVL(A.INSPECTIONQTY,0)), 0, 0,  (SUM(NVL(A.LOT_DEFECT_CNT,0)) - SUM(NVL(A.REPAIRRESULTQTY, 0)))/ SUM(NVL(A.INSPECTIONQTY,0))) * 100, 2)  AS DATA2
		   ---------------------------------------------------------------
		FROM
		( 
		
		-----------------------------------------(21.07.15) 그룹 한번더 처리
        SELECT
			   	   A.PRODUCTDEFVERSION
			   ,	   A.LOTID
			   ,	   A.PROCESSSEGMENTID
			   ,	   A.PROCESSSEGMENTNAME 
			   
               , MAX(NVL(A.INSPECTIONQTY,0))
               , MAX(NVL(A.MAX_INSPECTIONQTY,0))
               
               , SUM(NVL(A.REPAIRRESULTQTY, 0)) AS REPAIRRESULTQTY
               , SUM(NVL(A.DEFECTCOUNT, 0))     AS LOT_DEFECT_CNT           	-- 검사공정별 lot별 불량 수
               , MAX(A.MAX_INSPECTIONQTY)       AS INSPECTIONQTY            	-- 검사골정별 lot별로 마지막 검사공정의 검사수
               
		FROM 
		 (
		 
		SELECT
			   	   AA.PRODUCTDEFVERSION
			   ,	   AA.LOTID
			   ,	   AA.PROCESSSEGMENTID
			   ,	   AA.PROCESSSEGMENTNAME 
			   --,   ROUND(DECODE(MAX(NVL(A.INSPECTIONQTY,0)), 0, 0, SUM(NVL(A.DEFECTCOUNT,0))/ MAX(NVL(A.INSPECTIONQTY,0))) * 100, 2) AS DATA1               
			   --,   ROUND(DECODE(MAX(NVL(A.INSPECTIONQTY,0)), 0, 0,  (SUM(NVL(A.DEFECTCOUNT,0)) - SUM(NVL(A.REPAIRRESULTQTY, 0)))/ MAX(NVL(A.INSPECTIONQTY,0))) * 100, 2)  AS DATA2  
			   
			   -------------------------------------------------------------------------------------
			   -- [21.07.15] 검사공정별 LOT별 공정순서가 가장 큰 수의 검사수만 구함
               , AA.USERSEQUENCE
               , AA.CREATEDTIME
               , AA.DEFECTCOUNT
               , AA.REPAIRRESULTQTY
               , AA.INSPECTIONQTY
               , MAX(AA.INSPECTIONQTY) KEEP(DENSE_RANK LAST ORDER BY TO_NUMBER(NVL(AA.USERSEQUENCE,0)), TO_CHAR(AA.CREATEDTIME, 'YYYY-MM-DD HH24:MI:SS')) OVER(PARTITION BY AA.PROCESSSEGMENTID, AA.LOTID)  MAX_INSPECTIONQTY
			   -------------------------------------------------------------------------------------
			   		
		FROM 
		 (
               SELECT                 
					A.PRODUCTDEFID
				,	A.PRODUCTDEFVERSION
				,	A.LOTID
				,	A.PROCESSSEGMENTID
				,	DIC.DICTIONARYNAME 		AS PROCESSSEGMENTNAME 
                ,	A.INSPECTIONQTY                
               ,    A.REPAIRTARGETQTY
               ,    A.REPAIRRESULTQTY 		   
                ----------------------------------------------------------------(21.06.17)
                -- 블량 그룹 
                ,  (
                        CASE WHEN AOI.GROUPCODE = '005'  
                            THEN T_AFT_ANALYSIS.GROUPCODE
                            ELSE COALESCE(AOI.GROUPCODE, '999')
                            END
                    ) AS GROUPCODE
                -- 블량 그룹명 
                ,  (
                        CASE WHEN AOI.GROUPCODE = '005'  
                            THEN T_AFT_ANALYSIS.GROUPNAME
                            ELSE COALESCE(AOI.GROUPNAME, 'NONE')
                            END
                    ) AS GROUPNAME
                -- 불량 코드   
                ,	COALESCE(
                            CASE A.SEGMENTTYPE
                                WHEN 'AOIInspection' 
                                THEN (
                                       CASE WHEN AOI.GROUPCODE = '005'  
                                            THEN T_AFT_ANALYSIS.SUBCODE
                                            ELSE AOI.SUBCODE
                                            END 
                                    )
                                ELSE AOI.SUBCODE
                            END, '9999') 														AS	SUBCODE	 
                -- 불량 코드명
                ,	COALESCE(
                            CASE A.SEGMENTTYPE
                                WHEN 'AOIInspection' 
                                THEN (
                                       CASE WHEN AOI.GROUPCODE = '005'  
                                            THEN T_AFT_ANALYSIS.SUBNAME
                                            ELSE  AOI.SUBNAME
                                            END 
                                    )
                                ELSE AOI.SUBNAME
                            END, 'NONE')														AS	SUBNAME
                -- 불량 색상
                ,  COALESCE(
                            CASE A.SEGMENTTYPE
                                WHEN 'AOIInspection' 
                                THEN (
                                       CASE WHEN AOI.GROUPCODE = '005'  
                                            THEN T_AFT_ANALYSIS.COLOR
                                            ELSE AOI.COLOR
                                            END 
                                    )
                                ELSE AOI.COLOR
                            END, '#000000')														AS	COLOR
                    
                -- 불량 수량 
                , A.DEFECTCOUNT
                
                -------------------------------------------
                -- (21.07.15) 공정 순서, 생성 시간  가져옴
                ,   A.USERSEQUENCE 
                ,   A.CREATEDTIME
                -------------------------------------------
                
               -----------------------------------------------------------------------------------------    		   
		FROM PCM_QCAOIBBTWORKCOMPLETE	A
			INNER JOIN LOTLIST 					L	ON	A.LOTID = L.LOTID
													AND	A.PRODUCTDEFID = L.PRODUCTDEFID
													AND	A.PRODUCTDEFVERSION = L.PRODUCTDEFVERSION				
            -- (21.06.17) 완료된 상태 체크   -> (21.06.18) 여러건 존재함 하나만 나오도록 수정
            INNER JOIN (SELECT RESOURCEID
                            ,  INSPECTIONDEFID  
                            , PROCESSSEGMENTID, PROCESSSEGMENTVERSION
                         FROM  QAM_INSPECTIONRESULT   
                         GROUP BY  RESOURCEID, INSPECTIONDEFID    
                                    , PROCESSSEGMENTID, PROCESSSEGMENTVERSION
                         ) Q_INSP
            ON Q_INSP.RESOURCEID                 		=  A.LOTID
            AND Q_INSP.INSPECTIONDEFID 					= 	'AOIInspection'
            AND Q_INSP.PROCESSSEGMENTID					= A.PROCESSSEGMENTID
            AND Q_INSP.PROCESSSEGMENTVERSION			= A.PROCESSSEGMENTVERSION
            -----------------------------------------------------------------   	
            LEFT OUTER JOIN (
					SELECT	GRP.CODEID								AS	GROUPCODE
						,	GRP.GROUPNAME							AS	GROUPNAME
						,	GRP.DESCRIPTION 							AS	COLOR
						,	SUB.CODEID									AS	SUBCODE
						,	SUB.SUBNAME								AS	SUBNAME
						,	'AOIInspection'								AS	SEGMENTTYPE
						,   '005'                                       	AS  CHK_G_CODE
                                    ,   (
                                        CASE WHEN SUB.CODEID = '1001'
                                             THEN '5001'
                                             ELSE '5002'
                                             END
                                    )   													AS CHK_S_CODE
					FROM	
					(
						SELECT 	C.LOOKUP_CODE   AS CODEID
							,	C.DESCRIPTION
							,	D.DICTIONARYNAME						AS	GROUPNAME
						FROM 	CMD_LOOKUP_VALUES									C
						LEFT OUTER JOIN		CMD_DICTIONARY	D			ON	C.DICTIONARYID = D.DICTIONARYID						           	   			   		    
						WHERE	C.LOOKUP_TYPE = 'DefectMapDefectGroup'
						AND		C.ENABLED_FLAG = 'Y'
						AND		D.LANGUAGETYPE = #{LANGUAGETYPE}        -- 다국어 코드
					) 					GRP
					LEFT OUTER JOIN		
					(
						SELECT	C.LOOKUP_CODE   AS CODEID
							,	D.DICTIONARYNAME						AS	SUBNAME
							,	C.PARENTCODEID
						FROM	CMD_LOOKUP_VALUES									C
						LEFT OUTER JOIN 	CMD_DICTIONARY	D			ON 	C.DICTIONARYID = D.DICTIONARYID
						WHERE	C.LOOKUP_TYPE = 'DefectMapDefectGroupSub'
						AND		C.ENABLED_FLAG = 'Y'
						AND		D.LANGUAGETYPE = #{LANGUAGETYPE}        -- 다국어 코드
					) 					SUB								ON	GRP.CODEID = SUB.PARENTCODEID
					WHERE 1 = 1
                              AND GRP.CODEID IN ('001','002')
                              AND SUB.CODEID IN ('1001','2001')
				)   T_AFT_ANALYSIS
            ON A.SEGMENTTYPE = T_AFT_ANALYSIS.SEGMENTTYPE 
            AND A.DEFECTCODE = T_AFT_ANALYSIS.CHK_S_CODE
-----------------------------------------------------------------     
		INNER JOIN	BAS_PROCESSSEGMENTEXT	C	ON A.PROCESSSEGMENTID = C.PROCESSSEGMENTID 
										  AND A.ENTERPRISEID = C.ENTERPRISEID                                       
		LEFT OUTER JOIN (
							SELECT
								   'AOIInspection'                              AS SEGMENTTYPE		
		                        ,   GRP.CODEID									AS GROUPCODE
								,	GRP.GROUPNAME							AS GROUPNAME
								,	GRP.DESCRIPTION 							AS COLOR
								,	SUB.CODEID									AS SUBCODE
								,	SUB.SUBNAME								AS SUBNAME
							FROM	
							(
								SELECT 	C.LOOKUP_CODE   AS CODEID
									,	C.DESCRIPTION
									,	D.DICTIONARYNAME						AS GROUPNAME
								FROM 	CMD_LOOKUP_VALUES									C
								LEFT OUTER JOIN		CMD_DICTIONARY	D	ON	C.DICTIONARYID = D.DICTIONARYID						           	   			   		    
								WHERE	C.LOOKUP_TYPE = 'DefectMapDefectGroup'
								AND		C.ENABLED_FLAG = 'Y'
								AND		D.LANGUAGETYPE = #{LANGUAGETYPE} 
							) 					GRP
							LEFT OUTER JOIN		
							(
								SELECT	C.LOOKUP_CODE AS CODEID
									,	D.DICTIONARYNAME						AS SUBNAME
									,	C.PARENTCODEID
								FROM	CMD_LOOKUP_VALUES									C
								LEFT OUTER JOIN 	CMD_DICTIONARY	D	ON 	C.DICTIONARYID = D.DICTIONARYID
								WHERE	C.LOOKUP_TYPE = 'DefectMapDefectGroupSub'
								AND		C.ENABLED_FLAG = 'Y'
								AND		D.LANGUAGETYPE = #{LANGUAGETYPE} 
							) 					
							SUB		ON GRP.CODEID = SUB.PARENTCODEID              
						) AOI		ON A.DEFECTCODE = AOI.SUBCODE
								  AND A.SEGMENTTYPE = AOI.SEGMENTTYPE						
        LEFT JOIN CMD_DICTIONARY         	DIC	ON	DIC.DICTIONARYID = C.PROCESSSEGMENTNAME
                                                AND DIC.LANGUAGETYPE = #{LANGUAGETYPE}  
                                                
                                                
		---------------------------------
		-- (21.07.09) 추가
        INNER JOIN BAS_PRODUCTDEFINITION E      ON 	A.PRODUCTDEFID = E.PRODUCTDEFID
											   AND  A.PRODUCTDEFVERSION  = E.PRODUCTDEFVERSION
		---------------------------------
		
		-----------------------------------(21.08.10) 인계 시간 조건 추가        
		LEFT JOIN T_SENDTIME TT 
				ON TT.LOTID             			= A.LOTID
			   AND TT.PROCESSSEGMENTID  	= A.PROCESSSEGMENTID
		-----------------------------
		
		WHERE 1 = 1
		  AND A.SEGMENTTYPE = 'AOIInspection'
		  AND A.ENTERPRISEID = #{P_ENTERPRISEID}
		  AND A.PLANTID = #{P_PLANTID}		  
		<if test="P_PERIOD_PERIODFR != null and P_PERIOD_PERIODFR !='' and P_PERIOD_PERIODTO != null and P_PERIOD_PERIODTO !=''">
		  
		  -- (21.08.10) 인계 시간 조건 추가  A.CREATEDTIME --> TT.SENDTIME
		  AND TT.SENDTIME <![CDATA[>=]]> TO_TIMESTAMP(SUBSTR(#{P_PERIOD_PERIODFR},1,14), 'YYYYMMDDHH24MISS')
		  AND TT.SENDTIME <![CDATA[<]]>  TO_TIMESTAMP(TO_CHAR(TO_DATE(SUBSTR(#{P_PERIOD_PERIODTO},1,8), 'YYYYMMDD'), 'YYYY-MM-DD') || ' ' || SUBSTR(#{P_PERIOD_PERIODTO}, 9, 6), 'YYYY-MM-DD HH24:MI:SS') 
		</if>
		<if test="LOTID_LIST.length != 0">
                AND		A.LOTID IN
	           <foreach collection="LOTID_LIST" item="item" index="index" separator="," open="(" close=")">
	                    #{item}
	           </foreach>				
		</if>	
		<if test="PROCESSSEGMENTID_LIST.length != 0">
                AND		A.PROCESSSEGMENTID IN
	           <foreach collection="PROCESSSEGMENTID_LIST" item="item" index="index" separator="," open="(" close=")">
	                    #{item}
	           </foreach>				
		</if>			
		<if test="PRODUCTDEFIDVER_LIST.length != 0">
                AND		A.PRODUCTDEFID || A.PRODUCTDEFVERSION IN
	           <foreach collection="PRODUCTDEFIDVER_LIST" item="item" index="index" separator="," open="(" close=")">
	                    #{item}
	           </foreach>				
		</if>
		<if test="P_PROCESSSEGMENTID != null and P_PROCESSSEGMENTID !=''">
		   AND		A.PROCESSSEGMENTID = #{P_PROCESSSEGMENTID}
		</if>		
		<if test="P_AOIPROCESS != null and P_AOIPROCESS !=''">
		   -- AOI 공정
			AND	 EXISTS (SELECT 1 FROM ufn_selectStringToSplit(#{P_AOIPROCESS},',') WHERE value = A.PROCESSSEGMENTID) 
		</if>
		
		<if test="P_PRODUCTIONTYPE != null and P_PRODUCTIONTYPE !='' and !(P_PRODUCTIONTYPE eq '*'.toString()) ">
			-- (21.07.09) 생산구분 추가
			AND 	E.PRODUCTIONTYPE 			= #{P_PRODUCTIONTYPE}
		</if>
		
		)	AA		-- (21.07.15) 그룹 추가 
		
		) A
		GROUP BY 
			       A.PRODUCTDEFVERSION
			   ,	   A.LOTID
			   ,	   A.PROCESSSEGMENTID
			   ,	   A.PROCESSSEGMENTNAME 
	    )	A	
		GROUP BY 
				A.PROCESSSEGMENTID
			,   A.PROCESSSEGMENTNAME
		ORDER BY 
				A.PROCESSSEGMENTID
			  , A.PROCESSSEGMENTNAME				  		
    </select>
    	
  <!-- AOI 분석 전/후 비교 조회 -->
    <select id="getDefectRateByRepairNullChartBeforeAfterList" parameterType="map" resultType="hashmap">
			-- getDefectRateByRepairNullChartBeforeAfterList  품목코드 미입력시
			WITH	LOTLIST	AS 
			(
					SELECT	C.LOTSTARTDATE
						,	C.LOTID
						,	C.PRODUCTDEFID
						,	C.PRODUCTDEFVERSION
						,	C.PROCESSSEGMENTID
					FROM	PCM_LOT C
					WHERE	
                            --EXISTS
                        	C.LOTID IN		-- (21.06.17) 속도개선 lot 처럼 변경함 
							(	SELECT	A.LOTID		--1 (21.06.17) 속도개선 lot 처럼 변경함
								FROM	PCM_LOTWORKRESULT				A
										INNER JOIN	BAS_PROCESSSEGMENT	B	ON A.PROCESSSEGMENTID = B.PROCESSSEGMENTID 
								WHERE	1=1
					            -- (21.06.17) 속도개선 lot 처럼 변경함
				            	--AND		C.LOTID = A.LOTID
								AND		(
						          			-- (21.08.10) WORKENDTIME -> SENDTIME 변경
						          			(		B.PROCESSSEGMENTCLASSID = '7012'	
						          				AND	A.SENDTIME			-- (21.06.03  endtime로 다 변경)		A.WORKSTARTTIME 
						          				BETWEEN	TO_TIMESTAMP(#{P_PERIOD_PERIODFR}, 'YYYY-MM-DD HH24:MI:SS')	
									                					AND	TO_TIMESTAMP(#{P_PERIOD_PERIODTO}, 'YYYY-MM-DD HH24:MI:SS') 
					  						)
										)
							)
					<if test="P_LOTID != null and P_LOTID !='' and !(P_LOTID eq '*'.toString()) ">
						AND		C.LOTID = #{P_LOTID}
					</if>
					<if test="P_PRODUCTDEFID != null and P_PRODUCTDEFID !=''"> 
					  AND		C.PRODUCTDEFID = #{P_PRODUCTDEFID}
					</if>					
					<if test="P_PRODUCTDEFVERSION != null and P_PRODUCTDEFVERSION !='' and !(P_PRODUCTDEFVERSION eq '*'.toString()) ">
						AND		EXISTS
						(
							SELECT	1
							FROM	(SELECT DATA AS VALUE 
									  FROM TABLE(CAST(FN_TO_ROWS(#{P_PRODUCTDEFVERSION}) AS TP_SIMPLE_TABLE)) 
									) LMP
							WHERE	C.PRODUCTDEFVERSION = LMP.VALUE
						)
					</if>
			)	
			
			-----------------------------(21.08.10) 인계 시간 조회
			, T_SENDTIME AS (
					SELECT	A.LOTID		
					, 			A.PROCESSSEGMENTID
					, 			MAX(A.SENDTIME) 		AS 	SENDTIME		       -- 인계 시간
					, 			B.PROCESSSEGMENTCLASSID
				FROM			PCM_LOTWORKRESULT				A
				INNER JOIN	BAS_PROCESSSEGMENT				B	
				ON  			A.PROCESSSEGMENTID = B.PROCESSSEGMENTID 
				AND 			B.PROCESSSEGMENTCLASSID IN ('7012','7014','7022')
				WHERE		1=1
				AND 			LOTID IN (
					SELECT LOTID
					  FROM LOTLIST
				)
				GROUP BY    A.LOTID		
					,       A.PROCESSSEGMENTID
					,       B.PROCESSSEGMENTCLASSID
			)
		-----------------------------
			
					
		SELECT	
				A.GROUPCODE						AS CODE
			,	A.GROUPNAME						AS NAME
			,   A.COLOR							    AS COLOR
			,   ROUND(DECODE(MAX(NVL(A.INSPECTIONQTY,0)), 0, 0, SUM(NVL(A.DEFECTCOUNT,0))/ MAX(NVL(A.INSPECTIONQTY,0))) * 100, 2)  AS BEFOREDEFECTRATE               
		    ,   ROUND(DECODE(MAX(NVL(A.INSPECTIONQTY,0)), 0, 0,  (SUM(NVL(A.DEFECTCOUNT,0)) - SUM(NVL(A.REPAIRRESULTQTY, 0)))/ MAX(NVL(A.INSPECTIONQTY,0))) * 100, 2) AS AFTERDEFECTRATE	
               FROM
               (
               SELECT              
					A.PRODUCTDEFID
				,	A.PRODUCTDEFVERSION
				,	A.LOTID
				,	A.PROCESSSEGMENTID 
                ,	A.INSPECTIONQTY                
               ,    A.REPAIRTARGETQTY
               ,    A.REPAIRRESULTQTY 		   
                ----------------------------------------------------------------(21.06.17)
                -- 블량 그룹 
                ,  (
                        CASE WHEN AOI.GROUPCODE = '005'  
                            THEN T_AFT_ANALYSIS.GROUPCODE
                            ELSE COALESCE(AOI.GROUPCODE, '999')
                            END
                    ) AS GROUPCODE
                -- 블량 그룹명 
                ,  (
                        CASE WHEN AOI.GROUPCODE = '005'  
                            THEN T_AFT_ANALYSIS.GROUPNAME
                            ELSE COALESCE(AOI.GROUPNAME, 'NONE')
                            END
                    ) AS GROUPNAME
                -- 불량 코드   
                ,	COALESCE(
                            CASE A.SEGMENTTYPE
                                WHEN 'AOIInspection' 
                                THEN (
                                       CASE WHEN AOI.GROUPCODE = '005'  
                                            THEN T_AFT_ANALYSIS.SUBCODE
                                            ELSE AOI.SUBCODE
                                            END 
                                    )
                                ELSE AOI.SUBCODE
                            END, '9999') 														AS	SUBCODE	 
                -- 불량 코드명
                ,	COALESCE(
                            CASE A.SEGMENTTYPE
                                WHEN 'AOIInspection' 
                                THEN (
                                       CASE WHEN AOI.GROUPCODE = '005'  
                                            THEN T_AFT_ANALYSIS.SUBNAME
                                            ELSE  AOI.SUBNAME
                                            END 
                                    )
                                ELSE AOI.SUBNAME
                            END, 'NONE')														AS	SUBNAME
                -- 불량 색상
                ,  COALESCE(
                            CASE A.SEGMENTTYPE
                                WHEN 'AOIInspection' 
                                THEN (
                                       CASE WHEN AOI.GROUPCODE = '005'  
                                            THEN T_AFT_ANALYSIS.COLOR
                                            ELSE AOI.COLOR
                                            END 
                                    )
                                ELSE AOI.COLOR
                            END, '#000000')														AS	COLOR
                    
                -- 불량 수량 
                , A.DEFECTCOUNT
               -----------------------------------------------------------------------------------------    		   
		FROM PCM_QCAOIBBTWORKCOMPLETE	A
			INNER JOIN LOTLIST 					L	ON	A.LOTID = L.LOTID
													AND	A.PRODUCTDEFID = L.PRODUCTDEFID
													AND	A.PRODUCTDEFVERSION = L.PRODUCTDEFVERSION				
            -- (21.06.17) 완료된 상태 체크   -> (21.06.18) 여러건 존재함 하나만 나오도록 수정
            INNER JOIN (SELECT RESOURCEID
                            ,  INSPECTIONDEFID  
                            , PROCESSSEGMENTID, PROCESSSEGMENTVERSION
                         FROM  QAM_INSPECTIONRESULT   
                         GROUP BY  RESOURCEID, INSPECTIONDEFID    
                                    , PROCESSSEGMENTID, PROCESSSEGMENTVERSION
                         ) Q_INSP
            ON Q_INSP.RESOURCEID                 		=  A.LOTID
            AND Q_INSP.INSPECTIONDEFID 					= 	'AOIInspection'
            AND Q_INSP.PROCESSSEGMENTID					= A.PROCESSSEGMENTID
            AND Q_INSP.PROCESSSEGMENTVERSION			= A.PROCESSSEGMENTVERSION
            -----------------------------------------------------------------   	
            LEFT OUTER JOIN (
					SELECT	GRP.CODEID								AS	GROUPCODE
						,	GRP.GROUPNAME							AS	GROUPNAME
						,	GRP.DESCRIPTION 							AS	COLOR
						,	SUB.CODEID									AS	SUBCODE
						,	SUB.SUBNAME								AS	SUBNAME
						,	'AOIInspection'								AS	SEGMENTTYPE
						,   '005'                                       	AS  CHK_G_CODE
                                    ,   (
                                        CASE WHEN SUB.CODEID = '1001'
                                             THEN '5001'
                                             ELSE '5002'
                                             END
                                    )   													AS CHK_S_CODE
					FROM	
					(
						SELECT 	C.LOOKUP_CODE   AS CODEID
							,	C.DESCRIPTION
							,	D.DICTIONARYNAME						AS	GROUPNAME
						FROM 	CMD_LOOKUP_VALUES									C
						LEFT OUTER JOIN		CMD_DICTIONARY	D			ON	C.DICTIONARYID = D.DICTIONARYID						           	   			   		    
						WHERE	C.LOOKUP_TYPE = 'DefectMapDefectGroup'
						AND		C.ENABLED_FLAG = 'Y'
						AND		D.LANGUAGETYPE = #{LANGUAGETYPE}        -- 다국어 코드
					) 					GRP
					LEFT OUTER JOIN		
					(
						SELECT	C.LOOKUP_CODE   AS CODEID
							,	D.DICTIONARYNAME						AS	SUBNAME
							,	C.PARENTCODEID
						FROM	CMD_LOOKUP_VALUES									C
						LEFT OUTER JOIN 	CMD_DICTIONARY	D			ON 	C.DICTIONARYID = D.DICTIONARYID
						WHERE	C.LOOKUP_TYPE = 'DefectMapDefectGroupSub'
						AND		C.ENABLED_FLAG = 'Y'
						AND		D.LANGUAGETYPE = #{LANGUAGETYPE}        -- 다국어 코드
					) 					SUB								ON	GRP.CODEID = SUB.PARENTCODEID
					WHERE 1 = 1
                              AND GRP.CODEID IN ('001','002')
                              AND SUB.CODEID IN ('1001','2001')
				)   T_AFT_ANALYSIS
            ON A.SEGMENTTYPE = T_AFT_ANALYSIS.SEGMENTTYPE 
            AND A.DEFECTCODE = T_AFT_ANALYSIS.CHK_S_CODE
-----------------------------------------------------------------     	
		INNER JOIN	BAS_PROCESSSEGMENTEXT	C	ON A.PROCESSSEGMENTID = C.PROCESSSEGMENTID 
										  AND A.ENTERPRISEID = C.ENTERPRISEID                                    
		LEFT OUTER JOIN (
							SELECT
									'AOIInspection'                             AS SEGMENTTYPE	
		                        ,   GRP.CODEID									AS GROUPCODE
								,	GRP.GROUPNAME							AS GROUPNAME
								,	GRP.DESCRIPTION 							AS COLOR
								,	SUB.CODEID									AS SUBCODE
								,	SUB.SUBNAME								AS SUBNAME
							FROM	
							(
								SELECT 	C.LOOKUP_CODE   AS CODEID
									,	C.DESCRIPTION
									,	D.DICTIONARYNAME						AS GROUPNAME
								FROM 	CMD_LOOKUP_VALUES									C
								LEFT OUTER JOIN		CMD_DICTIONARY	D	ON	C.DICTIONARYID = D.DICTIONARYID						           	   			   		    
								WHERE	C.LOOKUP_TYPE = 'DefectMapDefectGroup'
								AND		C.ENABLED_FLAG = 'Y'
								AND		D.LANGUAGETYPE = #{LANGUAGETYPE} 
							) 					GRP
							LEFT OUTER JOIN		
							(
								SELECT	C.LOOKUP_CODE AS CODEID
									,	D.DICTIONARYNAME						AS SUBNAME
									,	C.PARENTCODEID
								FROM	CMD_LOOKUP_VALUES									C
								LEFT OUTER JOIN 	CMD_DICTIONARY	D	ON 	C.DICTIONARYID = D.DICTIONARYID
								WHERE	C.LOOKUP_TYPE = 'DefectMapDefectGroupSub'
								AND		C.ENABLED_FLAG = 'Y'
								AND		D.LANGUAGETYPE = #{LANGUAGETYPE} 
							) 					
							SUB		ON GRP.CODEID = SUB.PARENTCODEID              
						) AOI		ON A.DEFECTCODE = AOI.SUBCODE  	  
                                  AND A.SEGMENTTYPE = AOI.SEGMENTTYPE
                                  
		---------------------------------
		-- (21.07.12) 추가
        INNER JOIN BAS_PRODUCTDEFINITION E      ON 	A.PRODUCTDEFID = E.PRODUCTDEFID
											   AND  A.PRODUCTDEFVERSION  = E.PRODUCTDEFVERSION
		---------------------------------
		
		-----------------------------------(21.08.10) 인계 시간 조건 추가        
		LEFT JOIN T_SENDTIME TT 
				ON TT.LOTID             			= A.LOTID
			   AND TT.PROCESSSEGMENTID  	= A.PROCESSSEGMENTID
		-----------------------------


		WHERE 1 = 1
		  AND A.SEGMENTTYPE = 'AOIInspection'
		  AND A.ENTERPRISEID = #{P_ENTERPRISEID}
		  AND A.PLANTID = #{P_PLANTID}		  
		<if test="P_PERIOD_PERIODFR != null and P_PERIOD_PERIODFR !='' and P_PERIOD_PERIODTO != null and P_PERIOD_PERIODTO !=''">
		  -- (21.08.10) 인계 시간 조건 추가 A.CREATEDTIME -> TT.SENDTIME
		  AND TT.SENDTIME <![CDATA[>=]]> TO_TIMESTAMP(SUBSTR(#{P_PERIOD_PERIODFR},1,14), 'YYYYMMDDHH24MISS')
		  AND TT.SENDTIME <![CDATA[<]]>  TO_TIMESTAMP(TO_CHAR(TO_DATE(SUBSTR(#{P_PERIOD_PERIODTO},1,8), 'YYYYMMDD'), 'YYYY-MM-DD') || ' ' || SUBSTR(#{P_PERIOD_PERIODTO}, 9, 6), 'YYYY-MM-DD HH24:MI:SS') 
		</if>
		<if test="LOTID_LIST.length != 0">
                AND		A.LOTID IN
	           <foreach collection="LOTID_LIST" item="item" index="index" separator="," open="(" close=")">
	                    #{item}
	           </foreach>				
		</if>	
		<if test="PROCESSSEGMENTID_LIST.length != 0">
                AND		A.PROCESSSEGMENTID IN
	           <foreach collection="PROCESSSEGMENTID_LIST" item="item" index="index" separator="," open="(" close=")">
	                    #{item}
	           </foreach>				
		</if>			
		<if test="PRODUCTDEFIDVER_LIST.length != 0">
                AND		A.PRODUCTDEFID || A.PRODUCTDEFVERSION IN
	           <foreach collection="PRODUCTDEFIDVER_LIST" item="item" index="index" separator="," open="(" close=")">
	                    #{item}
	           </foreach>				
		</if>
		<if test="P_AOIPROCESS != null and P_AOIPROCESS !=''">
		   -- AOI 공정
			AND	 EXISTS (SELECT 1 FROM ufn_selectStringToSplit(#{P_AOIPROCESS},',') WHERE value = A.PROCESSSEGMENTID) 
		</if>
		
		<if test="P_PRODUCTIONTYPE != null and P_PRODUCTIONTYPE !='' and !(P_PRODUCTIONTYPE eq '*'.toString()) ">
			-- (21.07.12) 생산구분 추가
			AND 	E.PRODUCTIONTYPE 			= #{P_PRODUCTIONTYPE}
		</if>
		
		
		)  A
		GROUP BY 
				A.GROUPCODE
			,	A.GROUPNAME		
			,   A.COLOR		
		ORDER BY 
				A.GROUPCODE
			,	A.GROUPNAME						
    </select>

 

  <!-- AOI 분석 전/후 비교 조회 -->
    <select id="getDefectRateByRepairNullBeforeDetail" parameterType="map" resultType="hashmap">
			-- getDefectRateByRepairNullBeforeDetail  품목코드 미입력시
			WITH	LOTLIST	AS 
			(
					SELECT	C.LOTSTARTDATE
						,	C.LOTID
						,	C.PRODUCTDEFID
						,	C.PRODUCTDEFVERSION
						,	C.PROCESSSEGMENTID
					FROM	PCM_LOT C
					WHERE	
                            --EXISTS
                        	C.LOTID IN		-- (21.06.17) 속도개선 lot 처럼 변경함 
							(	SELECT	A.LOTID		--1 (21.06.17) 속도개선 lot 처럼 변경함
								FROM	PCM_LOTWORKRESULT				A
										INNER JOIN	BAS_PROCESSSEGMENT	B	ON A.PROCESSSEGMENTID = B.PROCESSSEGMENTID 
								WHERE	1=1
					            -- (21.06.17) 속도개선 lot 처럼 변경함
				            	--AND		C.LOTID = A.LOTID
								AND		(
						          			-- (21.08.10) WORKENDTIME -> SENDTIME 변경
						          			(		B.PROCESSSEGMENTCLASSID = '7012'	
						          				AND	A.SENDTIME			-- (21.06.03  endtime로 다 변경)		A.WORKSTARTTIME 
						          				BETWEEN	TO_TIMESTAMP(#{P_PERIOD_PERIODFR}, 'YYYY-MM-DD HH24:MI:SS')	
									                					AND	TO_TIMESTAMP(#{P_PERIOD_PERIODTO}, 'YYYY-MM-DD HH24:MI:SS') 
					  						)
										)
							)
					<if test="P_LOTID != null and P_LOTID !='' and !(P_LOTID eq '*'.toString()) ">
						AND		C.LOTID = #{P_LOTID}
					</if>
					<if test="P_PRODUCTDEFID != null and P_PRODUCTDEFID !=''"> 
					  AND		C.PRODUCTDEFID = #{P_PRODUCTDEFID}
					</if>					
					<if test="P_PRODUCTDEFVERSION != null and P_PRODUCTDEFVERSION !='' and !(P_PRODUCTDEFVERSION eq '*'.toString()) ">
						AND		EXISTS
						(
							SELECT	1
							FROM	(SELECT DATA AS VALUE 
									  FROM TABLE(CAST(FN_TO_ROWS(#{P_PRODUCTDEFVERSION}) AS TP_SIMPLE_TABLE)) 
									) LMP
							WHERE	C.PRODUCTDEFVERSION = LMP.VALUE
						)
					</if>
			)			
			
			-----------------------------(21.08.10) 인계 시간 조회
			, T_SENDTIME AS (
					SELECT	A.LOTID		
					, 			A.PROCESSSEGMENTID
					, 			MAX(A.SENDTIME) 		AS 	SENDTIME		       -- 인계 시간
					, 			B.PROCESSSEGMENTCLASSID
				FROM			PCM_LOTWORKRESULT				A
				INNER JOIN	BAS_PROCESSSEGMENT				B	
				ON  			A.PROCESSSEGMENTID = B.PROCESSSEGMENTID 
				AND 			B.PROCESSSEGMENTCLASSID IN ('7012','7014','7022')
				WHERE		1=1
				AND 			LOTID IN (
					SELECT LOTID
					  FROM LOTLIST
				)
				GROUP BY    A.LOTID		
					,       A.PROCESSSEGMENTID
					,       B.PROCESSSEGMENTCLASSID
			)
		-----------------------------
			
			
			
		SELECT
				  '0'    AS  CHK	
				, G.GROUPCODE
				, G.GROUPNAME
				, G.BEFOREDEFECTCNT			AS GROUPCNT
				, G.BEFOREDEFECTRATE		AS GROUPRATE				
				, S.SUBCODE
				, S.SUBNAME
				, S.BEFOREDEFECTCNT		  AS SUBCNT
				, S.BEFOREDEFECTRATE	  AS SUBRATE		        		
		FROM
		(
		SELECT	
				A.GROUPCODE						    AS GROUPCODE
			,	A.GROUPNAME						    AS GROUPNAME			
		   ,    SUM(NVL(A.DEFECTCOUNT,0)) AS BEFOREDEFECTCNT
			,   ROUND(DECODE(MAX(NVL(A.INSPECTIONQTY,0)), 0, 0, SUM(NVL(A.DEFECTCOUNT,0))/ MAX(NVL(A.INSPECTIONQTY,0))) * 100, 2)  AS BEFOREDEFECTRATE      
			
               FROM
               (

			   SELECT

					A.PRODUCTDEFID
				,	A.PRODUCTDEFVERSION
				,	A.LOTID
				,	A.PROCESSSEGMENTID
                ,	B.INSPECTIONQTY                
               ,    A.REPAIRTARGETQTY
               ,    A.REPAIRRESULTQTY 			
                ,  A.GROUPCODE
                ,  A.GROUPNAME
                ,  A.SUBCODE	 
                ,  A.SUBNAME
                ,  A.COLOR
                , A.DEFECTCOUNT
			   FROM
			   (
               SELECT                    
					A.PRODUCTDEFID
				,	A.PRODUCTDEFVERSION
				,	A.LOTID
				,	A.PROCESSSEGMENTID
                ,	A.INSPECTIONQTY                
               ,    A.REPAIRTARGETQTY
               ,    A.REPAIRRESULTQTY 			
                ----------------------------------------------------------------(21.06.17)
                -- 블량 그룹 
                ,  (
                        CASE WHEN AOI.GROUPCODE = '005'  
                            THEN T_AFT_ANALYSIS.GROUPCODE
                            ELSE COALESCE(AOI.GROUPCODE, '999')
                            END
                    ) AS GROUPCODE
                -- 블량 그룹명 
                ,  (
                        CASE WHEN AOI.GROUPCODE = '005'  
                            THEN T_AFT_ANALYSIS.GROUPNAME
                            ELSE COALESCE(AOI.GROUPNAME, 'NONE')
                            END
                    ) AS GROUPNAME
                -- 불량 코드   
                ,	COALESCE(
                            CASE A.SEGMENTTYPE
                                WHEN 'AOIInspection' 
                                THEN (
                                       CASE WHEN AOI.GROUPCODE = '005'  
                                            THEN T_AFT_ANALYSIS.SUBCODE
                                            ELSE AOI.SUBCODE
                                            END 
                                    )
                                ELSE AOI.SUBCODE
                            END, '9999') 														AS	SUBCODE	 
                -- 불량 코드명
                ,	COALESCE(
                            CASE A.SEGMENTTYPE
                                WHEN 'AOIInspection' 
                                THEN (
                                       CASE WHEN AOI.GROUPCODE = '005'  
                                            THEN T_AFT_ANALYSIS.SUBNAME
                                            ELSE  AOI.SUBNAME
                                            END 
                                    )
                                ELSE AOI.SUBNAME
                            END, 'NONE')														AS	SUBNAME
                -- 불량 색상
                ,  COALESCE(
                            CASE A.SEGMENTTYPE
                                WHEN 'AOIInspection' 
                                THEN (
                                       CASE WHEN AOI.GROUPCODE = '005'  
                                            THEN T_AFT_ANALYSIS.COLOR
                                            ELSE AOI.COLOR
                                            END 
                                    )
                                ELSE AOI.COLOR
                            END, '#000000')														AS	COLOR
                    
                -- 불량 수량 
                , A.DEFECTCOUNT
               -----------------------------------------------------------------------------------------    			
		FROM PCM_QCAOIBBTWORKCOMPLETE	A    
			INNER JOIN LOTLIST 					L	ON	A.LOTID = L.LOTID
													AND	A.PRODUCTDEFID = L.PRODUCTDEFID
													AND	A.PRODUCTDEFVERSION = L.PRODUCTDEFVERSION				    
            -- (21.06.17) 완료된 상태 체크   -> (21.06.18) 여러건 존재함 하나만 나오도록 수정
            INNER JOIN (SELECT RESOURCEID
                            ,  INSPECTIONDEFID  
                            , PROCESSSEGMENTID, PROCESSSEGMENTVERSION
                         FROM  QAM_INSPECTIONRESULT   
                         GROUP BY  RESOURCEID, INSPECTIONDEFID    
                                    , PROCESSSEGMENTID, PROCESSSEGMENTVERSION
                         ) Q_INSP
            ON Q_INSP.RESOURCEID                 		=  A.LOTID
            AND Q_INSP.INSPECTIONDEFID 					= 	'AOIInspection'
            AND Q_INSP.PROCESSSEGMENTID					= A.PROCESSSEGMENTID
            AND Q_INSP.PROCESSSEGMENTVERSION			= A.PROCESSSEGMENTVERSION
            -----------------------------------------------------------------   	
            LEFT OUTER JOIN (
					SELECT	GRP.CODEID								AS	GROUPCODE
						,	GRP.GROUPNAME							AS	GROUPNAME
						,	GRP.DESCRIPTION 							AS	COLOR
						,	SUB.CODEID									AS	SUBCODE
						,	SUB.SUBNAME								AS	SUBNAME
						,	'AOIInspection'								AS	SEGMENTTYPE
						,   '005'                                       	AS  CHK_G_CODE
                                    ,   (
                                        CASE WHEN SUB.CODEID = '1001'
                                             THEN '5001'
                                             ELSE '5002'
                                             END
                                    )   													AS CHK_S_CODE
					FROM	
					(
						SELECT 	C.LOOKUP_CODE   AS CODEID
							,	C.DESCRIPTION
							,	D.DICTIONARYNAME						AS	GROUPNAME
						FROM 	CMD_LOOKUP_VALUES									C
						LEFT OUTER JOIN		CMD_DICTIONARY	D			ON	C.DICTIONARYID = D.DICTIONARYID						           	   			   		    
						WHERE	C.LOOKUP_TYPE = 'DefectMapDefectGroup'
						AND		C.ENABLED_FLAG = 'Y'
						AND		D.LANGUAGETYPE = #{LANGUAGETYPE}        -- 다국어 코드
					) 					GRP
					LEFT OUTER JOIN		
					(
						SELECT	C.LOOKUP_CODE   AS CODEID
							,	D.DICTIONARYNAME						AS	SUBNAME
							,	C.PARENTCODEID
						FROM	CMD_LOOKUP_VALUES									C
						LEFT OUTER JOIN 	CMD_DICTIONARY	D			ON 	C.DICTIONARYID = D.DICTIONARYID
						WHERE	C.LOOKUP_TYPE = 'DefectMapDefectGroupSub'
						AND		C.ENABLED_FLAG = 'Y'
						AND		D.LANGUAGETYPE = #{LANGUAGETYPE}        -- 다국어 코드
					) 					SUB								ON	GRP.CODEID = SUB.PARENTCODEID
					WHERE 1 = 1
                              AND GRP.CODEID IN ('001','002')
                              AND SUB.CODEID IN ('1001','2001')
				)   T_AFT_ANALYSIS
            ON A.SEGMENTTYPE = T_AFT_ANALYSIS.SEGMENTTYPE 
            AND A.DEFECTCODE = T_AFT_ANALYSIS.CHK_S_CODE
-----------------------------------------------------------------      		                          
		LEFT OUTER JOIN (	
						  SELECT	
								   'AOIInspection'                              AS SEGMENTTYPE
								,   GRP.CODEID									AS GROUPCODE
								,	GRP.GROUPNAME							AS GROUPNAME
								,	GRP.DESCRIPTION 							AS COLOR
								,	SUB.CODEID									AS SUBCODE
								,	SUB.SUBNAME								AS SUBNAME
							FROM	
							(
								SELECT 	C.LOOKUP_CODE   AS CODEID
									,	C.DESCRIPTION
									,	D.DICTIONARYNAME						AS GROUPNAME
								FROM 	CMD_LOOKUP_VALUES									C
								LEFT OUTER JOIN		CMD_DICTIONARY	D	ON	C.DICTIONARYID = D.DICTIONARYID						           	   			   		    
								WHERE	C.LOOKUP_TYPE = 'DefectMapDefectGroup'
								AND		C.ENABLED_FLAG = 'Y'
								AND		D.LANGUAGETYPE = #{LANGUAGETYPE} 
							) 					GRP
							LEFT OUTER JOIN		
							(
								SELECT	C.LOOKUP_CODE AS CODEID
									,	D.DICTIONARYNAME						AS SUBNAME
									,	C.PARENTCODEID
								FROM	CMD_LOOKUP_VALUES									C
								LEFT OUTER JOIN 	CMD_DICTIONARY	D	ON 	C.DICTIONARYID = D.DICTIONARYID
								WHERE	C.LOOKUP_TYPE = 'DefectMapDefectGroupSub'
								AND		C.ENABLED_FLAG = 'Y'
								AND		D.LANGUAGETYPE = #{LANGUAGETYPE} 
							) 					
							SUB		ON GRP.CODEID = SUB.PARENTCODEID              
						) AOI		ON A.DEFECTCODE = AOI.SUBCODE
                                  AND A.SEGMENTTYPE = AOI.SEGMENTTYPE
		                                  
        ---------------------------------[1]
		-- (21.07.12) 추가
        INNER JOIN BAS_PRODUCTDEFINITION E      ON 	A.PRODUCTDEFID = E.PRODUCTDEFID
											   AND  A.PRODUCTDEFVERSION  = E.PRODUCTDEFVERSION
		---------------------------------
		-----------------------------------(21.08.10) 인계 시간 조건 추가        
		LEFT JOIN T_SENDTIME TT 
				ON TT.LOTID             			= A.LOTID
			   AND TT.PROCESSSEGMENTID  	= A.PROCESSSEGMENTID
		-----------------------------
		                         

		WHERE 1 = 1
		  AND A.SEGMENTTYPE = 'AOIInspection'
		  AND A.ENTERPRISEID = #{P_ENTERPRISEID}
		  AND A.PLANTID = #{P_PLANTID}		  
		<if test="P_PERIOD_PERIODFR != null and P_PERIOD_PERIODFR !='' and P_PERIOD_PERIODTO != null and P_PERIOD_PERIODTO !=''">
		  -- (21.08.10) 인계 시간 조건 추가 A.CREATEDTIME -> TT.SENDTIME
		  AND TT.SENDTIME <![CDATA[>=]]> TO_TIMESTAMP(SUBSTR(#{P_PERIOD_PERIODFR},1,14), 'YYYYMMDDHH24MISS')
		  AND TT.SENDTIME <![CDATA[<]]>  TO_TIMESTAMP(TO_CHAR(TO_DATE(SUBSTR(#{P_PERIOD_PERIODTO},1,8), 'YYYYMMDD'), 'YYYY-MM-DD') || ' ' || SUBSTR(#{P_PERIOD_PERIODTO}, 9, 6), 'YYYY-MM-DD HH24:MI:SS') 
		</if>
		<if test="LOTID_LIST.length != 0">
                AND		A.LOTID IN
	           <foreach collection="LOTID_LIST" item="item" index="index" separator="," open="(" close=")">
	                    #{item}
	           </foreach>				
		</if>	
		<if test="PROCESSSEGMENTID_LIST.length != 0">
                AND		A.PROCESSSEGMENTID IN
	           <foreach collection="PROCESSSEGMENTID_LIST" item="item" index="index" separator="," open="(" close=")">
	                    #{item}
	           </foreach>				
		</if>		
		<if test="PRODUCTDEFIDVER_LIST.length != 0">
                AND		A.PRODUCTDEFID || A.PRODUCTDEFVERSION IN
	           <foreach collection="PRODUCTDEFIDVER_LIST" item="item" index="index" separator="," open="(" close=")">
	                    #{item}
	           </foreach>				
		</if>
		<if test="P_AOIPROCESS != null and P_AOIPROCESS !=''">
			-- AOI 공정
			AND	 EXISTS (SELECT 1 FROM ufn_selectStringToSplit(#{P_AOIPROCESS},',') WHERE value = A.PROCESSSEGMENTID) 
		</if>
		
		<if test="P_PRODUCTIONTYPE != null and P_PRODUCTIONTYPE !='' and !(P_PRODUCTIONTYPE eq '*'.toString()) ">
			-- (21.07.12) 생산구분 추가[1]
			AND 	E.PRODUCTIONTYPE 			= #{P_PRODUCTIONTYPE}
		</if>
		
		) A
		, 
           
		   (
		   SELECT
					A.SEGMENTTYPE    
                ,   A.PROCESSSEGMENTID
                ,   SUM(A.INSPECTIONQTY) AS INSPECTIONQTY
            FROM
           (
		   SELECT
					A.SEGMENTTYPE    
                ,   A.PROCESSSEGMENTID
                ,   A.LOTID
                ,	MAX(A.INSPECTIONQTY) AS INSPECTIONQTY			
		FROM PCM_QCAOIBBTWORKCOMPLETE	A    
			INNER JOIN LOTLIST 					L	ON	A.LOTID = L.LOTID
													AND	A.PRODUCTDEFID = L.PRODUCTDEFID
													AND	A.PRODUCTDEFVERSION = L.PRODUCTDEFVERSION				    
            -- (21.06.17) 완료된 상태 체크   -> (21.06.18) 여러건 존재함 하나만 나오도록 수정
            INNER JOIN (SELECT RESOURCEID
                            ,  INSPECTIONDEFID  
                            , PROCESSSEGMENTID, PROCESSSEGMENTVERSION
                         FROM  QAM_INSPECTIONRESULT   
                         GROUP BY  RESOURCEID, INSPECTIONDEFID    
                                    , PROCESSSEGMENTID, PROCESSSEGMENTVERSION
                         ) Q_INSP
            ON Q_INSP.RESOURCEID                 		=  A.LOTID
            AND Q_INSP.INSPECTIONDEFID 					= 	'AOIInspection'
            AND Q_INSP.PROCESSSEGMENTID					= A.PROCESSSEGMENTID
            AND Q_INSP.PROCESSSEGMENTVERSION			= A.PROCESSSEGMENTVERSION
            -----------------------------------------------------------------   	
            LEFT OUTER JOIN (
					SELECT	GRP.CODEID								AS	GROUPCODE
						,	GRP.GROUPNAME							AS	GROUPNAME
						,	GRP.DESCRIPTION 							AS	COLOR
						,	SUB.CODEID									AS	SUBCODE
						,	SUB.SUBNAME								AS	SUBNAME
						,	'AOIInspection'								AS	SEGMENTTYPE
						,   '005'                                       	AS  CHK_G_CODE
                                    ,   (
                                        CASE WHEN SUB.CODEID = '1001'
                                             THEN '5001'
                                             ELSE '5002'
                                             END
                                    )   													AS CHK_S_CODE
					FROM	
					(
						SELECT 	C.LOOKUP_CODE   AS CODEID
							,	C.DESCRIPTION
							,	D.DICTIONARYNAME						AS	GROUPNAME
						FROM 	CMD_LOOKUP_VALUES									C
						LEFT OUTER JOIN		CMD_DICTIONARY	D			ON	C.DICTIONARYID = D.DICTIONARYID						           	   			   		    
						WHERE	C.LOOKUP_TYPE = 'DefectMapDefectGroup'
						AND		C.ENABLED_FLAG = 'Y'
						AND		D.LANGUAGETYPE = #{LANGUAGETYPE}        -- 다국어 코드
					) 					GRP
					LEFT OUTER JOIN		
					(
						SELECT	C.LOOKUP_CODE   AS CODEID
							,	D.DICTIONARYNAME						AS	SUBNAME
							,	C.PARENTCODEID
						FROM	CMD_LOOKUP_VALUES									C
						LEFT OUTER JOIN 	CMD_DICTIONARY	D			ON 	C.DICTIONARYID = D.DICTIONARYID
						WHERE	C.LOOKUP_TYPE = 'DefectMapDefectGroupSub'
						AND		C.ENABLED_FLAG = 'Y'
						AND		D.LANGUAGETYPE = #{LANGUAGETYPE}        -- 다국어 코드
					) 					SUB								ON	GRP.CODEID = SUB.PARENTCODEID
					WHERE 1 = 1
                              AND GRP.CODEID IN ('001','002')
                              AND SUB.CODEID IN ('1001','2001')
				)   T_AFT_ANALYSIS
            ON A.SEGMENTTYPE = T_AFT_ANALYSIS.SEGMENTTYPE 
            AND A.DEFECTCODE = T_AFT_ANALYSIS.CHK_S_CODE
-----------------------------------------------------------------      		                          
		LEFT OUTER JOIN (	
						  SELECT	
								   'AOIInspection'                              AS SEGMENTTYPE
								,   GRP.CODEID									AS GROUPCODE
								,	GRP.GROUPNAME							AS GROUPNAME
								,	GRP.DESCRIPTION 							AS COLOR
								,	SUB.CODEID									AS SUBCODE
								,	SUB.SUBNAME								AS SUBNAME
							FROM	
							(
								SELECT 	C.LOOKUP_CODE   AS CODEID
									,	C.DESCRIPTION
									,	D.DICTIONARYNAME						AS GROUPNAME
								FROM 	CMD_LOOKUP_VALUES									C
								LEFT OUTER JOIN		CMD_DICTIONARY	D	ON	C.DICTIONARYID = D.DICTIONARYID						           	   			   		    
								WHERE	C.LOOKUP_TYPE = 'DefectMapDefectGroup'
								AND		C.ENABLED_FLAG = 'Y'
								AND		D.LANGUAGETYPE = #{LANGUAGETYPE} 
							) 					GRP
							LEFT OUTER JOIN		
							(
								SELECT	C.LOOKUP_CODE AS CODEID
									,	D.DICTIONARYNAME						AS SUBNAME
									,	C.PARENTCODEID
								FROM	CMD_LOOKUP_VALUES									C
								LEFT OUTER JOIN 	CMD_DICTIONARY	D	ON 	C.DICTIONARYID = D.DICTIONARYID
								WHERE	C.LOOKUP_TYPE = 'DefectMapDefectGroupSub'
								AND		C.ENABLED_FLAG = 'Y'
								AND		D.LANGUAGETYPE = #{LANGUAGETYPE} 
							) 					
							SUB		ON GRP.CODEID = SUB.PARENTCODEID              
						) AOI		ON A.DEFECTCODE = AOI.SUBCODE
                                  AND A.SEGMENTTYPE = AOI.SEGMENTTYPE
                                  
		---------------------------------[2]
		-- (21.07.12) 추가
        INNER JOIN BAS_PRODUCTDEFINITION E      ON 	A.PRODUCTDEFID = E.PRODUCTDEFID
											   AND  A.PRODUCTDEFVERSION  = E.PRODUCTDEFVERSION
		---------------------------------
		-----------------------------------(21.08.10) 인계 시간 조건 추가        
		LEFT JOIN T_SENDTIME TT 
				ON TT.LOTID             			= A.LOTID
			   AND TT.PROCESSSEGMENTID  	= A.PROCESSSEGMENTID
		-----------------------------
                                  
		WHERE 1 = 1
		  AND A.SEGMENTTYPE = 'AOIInspection'
		  AND A.ENTERPRISEID = #{P_ENTERPRISEID}
		  AND A.PLANTID = #{P_PLANTID}		  
		<if test="P_PERIOD_PERIODFR != null and P_PERIOD_PERIODFR !='' and P_PERIOD_PERIODTO != null and P_PERIOD_PERIODTO !=''">
		  -- (21.08.10) 인계 시간 조건 추가 A.CREATEDTIME -> TT.SENDTIME
		  AND TT.SENDTIME <![CDATA[>=]]> TO_TIMESTAMP(SUBSTR(#{P_PERIOD_PERIODFR},1,14), 'YYYYMMDDHH24MISS')
		  AND TT.SENDTIME <![CDATA[<]]>  TO_TIMESTAMP(TO_CHAR(TO_DATE(SUBSTR(#{P_PERIOD_PERIODTO},1,8), 'YYYYMMDD'), 'YYYY-MM-DD') || ' ' || SUBSTR(#{P_PERIOD_PERIODTO}, 9, 6), 'YYYY-MM-DD HH24:MI:SS') 
		</if>
		<if test="LOTID_LIST.length != 0">
                AND		A.LOTID IN
	           <foreach collection="LOTID_LIST" item="item" index="index" separator="," open="(" close=")">
	                    #{item}
	           </foreach>				
		</if>	
		<if test="PROCESSSEGMENTID_LIST.length != 0">
                AND		A.PROCESSSEGMENTID IN
	           <foreach collection="PROCESSSEGMENTID_LIST" item="item" index="index" separator="," open="(" close=")">
	                    #{item}
	           </foreach>				
		</if>		
		<if test="PRODUCTDEFIDVER_LIST.length != 0">
                AND		A.PRODUCTDEFID || A.PRODUCTDEFVERSION IN
	           <foreach collection="PRODUCTDEFIDVER_LIST" item="item" index="index" separator="," open="(" close=")">
	                    #{item}
	           </foreach>				
		</if>
		<if test="P_AOIPROCESS != null and P_AOIPROCESS !=''">
			-- AOI 공정
			AND	 EXISTS (SELECT 1 FROM ufn_selectStringToSplit(#{P_AOIPROCESS},',') WHERE value = A.PROCESSSEGMENTID) 
		</if>
		
		<if test="P_PRODUCTIONTYPE != null and P_PRODUCTIONTYPE !='' and !(P_PRODUCTIONTYPE eq '*'.toString()) ">
			-- (21.07.12) 생산구분 추가[2]
			AND 	E.PRODUCTIONTYPE 			= #{P_PRODUCTIONTYPE}
		</if>
		
        GROUP BY 
		 			A.SEGMENTTYPE    
                ,   A.PROCESSSEGMENTID
                ,   A.LOTID
        ) A
        GROUP BY 
		 			A.SEGMENTTYPE    
                ,   A.PROCESSSEGMENTID 
	    ) B
		WHERE A.PROCESSSEGMENTID = B.PROCESSSEGMENTID
		) A
		GROUP BY 
				A.GROUPCODE					
			,	A.GROUPNAME															
		   )	  G -- GROUPCODE		
		  , (
				SELECT	
						A.GROUPCODE						 
					,	A.GROUPNAME						
					,	A.SUBCODE
					,	A.SUBNAME			
				   ,    SUM(NVL(A.DEFECTCOUNT,0)) AS BEFOREDEFECTCNT
					,   ROUND(DECODE(MAX(NVL(A.INSPECTIONQTY,0)), 0, 0, SUM(NVL(A.DEFECTCOUNT,0))/ MAX(NVL(A.INSPECTIONQTY,0))) * 100, 2) AS BEFOREDEFECTRATE    
               FROM
               (
 			   SELECT

					A.PRODUCTDEFID
				,	A.PRODUCTDEFVERSION
				,	A.LOTID
				,	A.PROCESSSEGMENTID
                ,	B.INSPECTIONQTY                
               ,    A.REPAIRTARGETQTY
               ,    A.REPAIRRESULTQTY 			
                ,  A.GROUPCODE
                ,  A.GROUPNAME
                ,  A.SUBCODE	 
                ,  A.SUBNAME
                ,  A.COLOR
                , A.DEFECTCOUNT
			   FROM
			   (
               SELECT                    
					A.PRODUCTDEFID
				,	A.PRODUCTDEFVERSION
				,	A.LOTID
				,	A.PROCESSSEGMENTID
                ,	A.INSPECTIONQTY                
               ,    A.REPAIRTARGETQTY
               ,    A.REPAIRRESULTQTY 			
                ----------------------------------------------------------------(21.06.17)
                -- 블량 그룹 
                ,  (
                        CASE WHEN AOI.GROUPCODE = '005'  
                            THEN T_AFT_ANALYSIS.GROUPCODE
                            ELSE COALESCE(AOI.GROUPCODE, '999')
                            END
                    ) AS GROUPCODE
                -- 블량 그룹명 
                ,  (
                        CASE WHEN AOI.GROUPCODE = '005'  
                            THEN T_AFT_ANALYSIS.GROUPNAME
                            ELSE COALESCE(AOI.GROUPNAME, 'NONE')
                            END
                    ) AS GROUPNAME
                -- 불량 코드   
                ,	COALESCE(
                            CASE A.SEGMENTTYPE
                                WHEN 'AOIInspection' 
                                THEN (
                                       CASE WHEN AOI.GROUPCODE = '005'  
                                            THEN T_AFT_ANALYSIS.SUBCODE
                                            ELSE AOI.SUBCODE
                                            END 
                                    )
                                ELSE AOI.SUBCODE
                            END, '9999') 														AS	SUBCODE	 
                -- 불량 코드명
                ,	COALESCE(
                            CASE A.SEGMENTTYPE
                                WHEN 'AOIInspection' 
                                THEN (
                                       CASE WHEN AOI.GROUPCODE = '005'  
                                            THEN T_AFT_ANALYSIS.SUBNAME
                                            ELSE  AOI.SUBNAME
                                            END 
                                    )
                                ELSE AOI.SUBNAME
                            END, 'NONE')														AS	SUBNAME
                -- 불량 색상
                ,  COALESCE(
                            CASE A.SEGMENTTYPE
                                WHEN 'AOIInspection' 
                                THEN (
                                       CASE WHEN AOI.GROUPCODE = '005'  
                                            THEN T_AFT_ANALYSIS.COLOR
                                            ELSE AOI.COLOR
                                            END 
                                    )
                                ELSE AOI.COLOR
                            END, '#000000')														AS	COLOR
                    
                -- 불량 수량 
                , A.DEFECTCOUNT
               -----------------------------------------------------------------------------------------    			
		FROM PCM_QCAOIBBTWORKCOMPLETE	A    
			INNER JOIN LOTLIST 					L	ON	A.LOTID = L.LOTID
													AND	A.PRODUCTDEFID = L.PRODUCTDEFID
													AND	A.PRODUCTDEFVERSION = L.PRODUCTDEFVERSION				    
            -- (21.06.17) 완료된 상태 체크   -> (21.06.18) 여러건 존재함 하나만 나오도록 수정
            INNER JOIN (SELECT RESOURCEID
                            ,  INSPECTIONDEFID  
                            , PROCESSSEGMENTID, PROCESSSEGMENTVERSION
                         FROM  QAM_INSPECTIONRESULT   
                         GROUP BY  RESOURCEID, INSPECTIONDEFID    
                                    , PROCESSSEGMENTID, PROCESSSEGMENTVERSION
                         ) Q_INSP
            ON Q_INSP.RESOURCEID                 		=  A.LOTID
            AND Q_INSP.INSPECTIONDEFID 					= 	'AOIInspection'
            AND Q_INSP.PROCESSSEGMENTID					= A.PROCESSSEGMENTID
            AND Q_INSP.PROCESSSEGMENTVERSION			= A.PROCESSSEGMENTVERSION
            -----------------------------------------------------------------   	
            LEFT OUTER JOIN (
					SELECT	GRP.CODEID								AS	GROUPCODE
						,	GRP.GROUPNAME							AS	GROUPNAME
						,	GRP.DESCRIPTION 							AS	COLOR
						,	SUB.CODEID									AS	SUBCODE
						,	SUB.SUBNAME								AS	SUBNAME
						,	'AOIInspection'								AS	SEGMENTTYPE
						,   '005'                                       	AS  CHK_G_CODE
                                    ,   (
                                        CASE WHEN SUB.CODEID = '1001'
                                             THEN '5001'
                                             ELSE '5002'
                                             END
                                    )   													AS CHK_S_CODE
					FROM	
					(
						SELECT 	C.LOOKUP_CODE   AS CODEID
							,	C.DESCRIPTION
							,	D.DICTIONARYNAME						AS	GROUPNAME
						FROM 	CMD_LOOKUP_VALUES									C
						LEFT OUTER JOIN		CMD_DICTIONARY	D			ON	C.DICTIONARYID = D.DICTIONARYID						           	   			   		    
						WHERE	C.LOOKUP_TYPE = 'DefectMapDefectGroup'
						AND		C.ENABLED_FLAG = 'Y'
						AND		D.LANGUAGETYPE = #{LANGUAGETYPE}        -- 다국어 코드
					) 					GRP
					LEFT OUTER JOIN		
					(
						SELECT	C.LOOKUP_CODE   AS CODEID
							,	D.DICTIONARYNAME						AS	SUBNAME
							,	C.PARENTCODEID
						FROM	CMD_LOOKUP_VALUES									C
						LEFT OUTER JOIN 	CMD_DICTIONARY	D			ON 	C.DICTIONARYID = D.DICTIONARYID
						WHERE	C.LOOKUP_TYPE = 'DefectMapDefectGroupSub'
						AND		C.ENABLED_FLAG = 'Y'
						AND		D.LANGUAGETYPE = #{LANGUAGETYPE}        -- 다국어 코드
					) 					SUB								ON	GRP.CODEID = SUB.PARENTCODEID
					WHERE 1 = 1
                              AND GRP.CODEID IN ('001','002')
                              AND SUB.CODEID IN ('1001','2001')
				)   T_AFT_ANALYSIS
            ON A.SEGMENTTYPE = T_AFT_ANALYSIS.SEGMENTTYPE 
            AND A.DEFECTCODE = T_AFT_ANALYSIS.CHK_S_CODE
-----------------------------------------------------------------      		                          
		LEFT OUTER JOIN (	
						  SELECT	
								   'AOIInspection'                              AS SEGMENTTYPE
								,   GRP.CODEID									AS GROUPCODE
								,	GRP.GROUPNAME							AS GROUPNAME
								,	GRP.DESCRIPTION 							AS COLOR
								,	SUB.CODEID									AS SUBCODE
								,	SUB.SUBNAME								AS SUBNAME
							FROM	
							(
								SELECT 	C.LOOKUP_CODE   AS CODEID
									,	C.DESCRIPTION
									,	D.DICTIONARYNAME						AS GROUPNAME
								FROM 	CMD_LOOKUP_VALUES									C
								LEFT OUTER JOIN		CMD_DICTIONARY	D	ON	C.DICTIONARYID = D.DICTIONARYID						           	   			   		    
								WHERE	C.LOOKUP_TYPE = 'DefectMapDefectGroup'
								AND		C.ENABLED_FLAG = 'Y'
								AND		D.LANGUAGETYPE = #{LANGUAGETYPE} 
							) 					GRP
							LEFT OUTER JOIN		
							(
								SELECT	C.LOOKUP_CODE AS CODEID
									,	D.DICTIONARYNAME						AS SUBNAME
									,	C.PARENTCODEID
								FROM	CMD_LOOKUP_VALUES									C
								LEFT OUTER JOIN 	CMD_DICTIONARY	D	ON 	C.DICTIONARYID = D.DICTIONARYID
								WHERE	C.LOOKUP_TYPE = 'DefectMapDefectGroupSub'
								AND		C.ENABLED_FLAG = 'Y'
								AND		D.LANGUAGETYPE = #{LANGUAGETYPE} 
							) 					
							SUB		ON GRP.CODEID = SUB.PARENTCODEID              
						) AOI		ON A.DEFECTCODE = AOI.SUBCODE
                                  AND A.SEGMENTTYPE = AOI.SEGMENTTYPE
                                  
		---------------------------------[3]
		-- (21.07.12) 추가
        INNER JOIN BAS_PRODUCTDEFINITION E      ON 	A.PRODUCTDEFID = E.PRODUCTDEFID
											   AND  A.PRODUCTDEFVERSION  = E.PRODUCTDEFVERSION
		---------------------------------
		-----------------------------------(21.08.10) 인계 시간 조건 추가        
		LEFT JOIN T_SENDTIME TT 
				ON TT.LOTID             			= A.LOTID
			   AND TT.PROCESSSEGMENTID  	= A.PROCESSSEGMENTID
		-----------------------------
                                  
		WHERE 1 = 1
		  AND A.SEGMENTTYPE = 'AOIInspection'
		  AND A.ENTERPRISEID = #{P_ENTERPRISEID}
		  AND A.PLANTID = #{P_PLANTID}		  
		<if test="P_PERIOD_PERIODFR != null and P_PERIOD_PERIODFR !='' and P_PERIOD_PERIODTO != null and P_PERIOD_PERIODTO !=''">
		  -- (21.08.10) 인계 시간 조건 추가  A.CREATEDTIME -> TT.SENDTIME
		  AND TT.SENDTIME <![CDATA[>=]]> TO_TIMESTAMP(SUBSTR(#{P_PERIOD_PERIODFR},1,14), 'YYYYMMDDHH24MISS')
		  AND TT.SENDTIME <![CDATA[<]]>  TO_TIMESTAMP(TO_CHAR(TO_DATE(SUBSTR(#{P_PERIOD_PERIODTO},1,8), 'YYYYMMDD'), 'YYYY-MM-DD') || ' ' || SUBSTR(#{P_PERIOD_PERIODTO}, 9, 6), 'YYYY-MM-DD HH24:MI:SS') 
		</if>
		<if test="LOTID_LIST.length != 0">
                AND		A.LOTID IN
	           <foreach collection="LOTID_LIST" item="item" index="index" separator="," open="(" close=")">
	                    #{item}
	           </foreach>				
		</if>	
		<if test="PROCESSSEGMENTID_LIST.length != 0">
                AND		A.PROCESSSEGMENTID IN
	           <foreach collection="PROCESSSEGMENTID_LIST" item="item" index="index" separator="," open="(" close=")">
	                    #{item}
	           </foreach>				
		</if>		
		<if test="PRODUCTDEFIDVER_LIST.length != 0">
                AND		A.PRODUCTDEFID || A.PRODUCTDEFVERSION IN
	           <foreach collection="PRODUCTDEFIDVER_LIST" item="item" index="index" separator="," open="(" close=")">
	                    #{item}
	           </foreach>				
		</if>
		<if test="P_AOIPROCESS != null and P_AOIPROCESS !=''">
			-- AOI 공정
			AND	 EXISTS (SELECT 1 FROM ufn_selectStringToSplit(#{P_AOIPROCESS},',') WHERE value = A.PROCESSSEGMENTID) 
		</if>
		
		<if test="P_PRODUCTIONTYPE != null and P_PRODUCTIONTYPE !='' and !(P_PRODUCTIONTYPE eq '*'.toString()) ">
			-- (21.07.12) 생산구분 추가[3]
			AND 	E.PRODUCTIONTYPE 			= #{P_PRODUCTIONTYPE}
		</if>
		
		) A
		, 
           
		   (
		   SELECT
					A.SEGMENTTYPE    
                ,   A.PROCESSSEGMENTID
                ,   SUM(A.INSPECTIONQTY) AS INSPECTIONQTY
            FROM
           (
		   SELECT
					A.SEGMENTTYPE    
                ,   A.PROCESSSEGMENTID
                ,   A.LOTID
                ,	MAX(A.INSPECTIONQTY) AS INSPECTIONQTY			
		FROM PCM_QCAOIBBTWORKCOMPLETE	A    
			INNER JOIN LOTLIST 					L	ON	A.LOTID = L.LOTID
													AND	A.PRODUCTDEFID = L.PRODUCTDEFID
													AND	A.PRODUCTDEFVERSION = L.PRODUCTDEFVERSION				    
            -- (21.06.17) 완료된 상태 체크   -> (21.06.18) 여러건 존재함 하나만 나오도록 수정
            INNER JOIN (SELECT RESOURCEID
                            ,  INSPECTIONDEFID  
                            , PROCESSSEGMENTID, PROCESSSEGMENTVERSION
                         FROM  QAM_INSPECTIONRESULT   
                         GROUP BY  RESOURCEID, INSPECTIONDEFID    
                                    , PROCESSSEGMENTID, PROCESSSEGMENTVERSION
                         ) Q_INSP
            ON Q_INSP.RESOURCEID                 		=  A.LOTID
            AND Q_INSP.INSPECTIONDEFID 					= 	'AOIInspection'
            AND Q_INSP.PROCESSSEGMENTID					= A.PROCESSSEGMENTID
            AND Q_INSP.PROCESSSEGMENTVERSION			= A.PROCESSSEGMENTVERSION
            -----------------------------------------------------------------   	
            LEFT OUTER JOIN (
					SELECT	GRP.CODEID								AS	GROUPCODE
						,	GRP.GROUPNAME							AS	GROUPNAME
						,	GRP.DESCRIPTION 							AS	COLOR
						,	SUB.CODEID									AS	SUBCODE
						,	SUB.SUBNAME								AS	SUBNAME
						,	'AOIInspection'								AS	SEGMENTTYPE
						,   '005'                                       	AS  CHK_G_CODE
                                    ,   (
                                        CASE WHEN SUB.CODEID = '1001'
                                             THEN '5001'
                                             ELSE '5002'
                                             END
                                    )   													AS CHK_S_CODE
					FROM	
					(
						SELECT 	C.LOOKUP_CODE   AS CODEID
							,	C.DESCRIPTION
							,	D.DICTIONARYNAME						AS	GROUPNAME
						FROM 	CMD_LOOKUP_VALUES									C
						LEFT OUTER JOIN		CMD_DICTIONARY	D			ON	C.DICTIONARYID = D.DICTIONARYID						           	   			   		    
						WHERE	C.LOOKUP_TYPE = 'DefectMapDefectGroup'
						AND		C.ENABLED_FLAG = 'Y'
						AND		D.LANGUAGETYPE = #{LANGUAGETYPE}        -- 다국어 코드
					) 					GRP
					LEFT OUTER JOIN		
					(
						SELECT	C.LOOKUP_CODE   AS CODEID
							,	D.DICTIONARYNAME						AS	SUBNAME
							,	C.PARENTCODEID
						FROM	CMD_LOOKUP_VALUES									C
						LEFT OUTER JOIN 	CMD_DICTIONARY	D			ON 	C.DICTIONARYID = D.DICTIONARYID
						WHERE	C.LOOKUP_TYPE = 'DefectMapDefectGroupSub'
						AND		C.ENABLED_FLAG = 'Y'
						AND		D.LANGUAGETYPE = #{LANGUAGETYPE}        -- 다국어 코드
					) 					SUB								ON	GRP.CODEID = SUB.PARENTCODEID
					WHERE 1 = 1
                              AND GRP.CODEID IN ('001','002')
                              AND SUB.CODEID IN ('1001','2001')
				)   T_AFT_ANALYSIS
            ON A.SEGMENTTYPE = T_AFT_ANALYSIS.SEGMENTTYPE 
            AND A.DEFECTCODE = T_AFT_ANALYSIS.CHK_S_CODE
-----------------------------------------------------------------      		                          
		LEFT OUTER JOIN (	
						  SELECT	
								   'AOIInspection'                              AS SEGMENTTYPE
								,   GRP.CODEID									AS GROUPCODE
								,	GRP.GROUPNAME							AS GROUPNAME
								,	GRP.DESCRIPTION 							AS COLOR
								,	SUB.CODEID									AS SUBCODE
								,	SUB.SUBNAME								AS SUBNAME
							FROM	
							(
								SELECT 	C.LOOKUP_CODE   AS CODEID
									,	C.DESCRIPTION
									,	D.DICTIONARYNAME						AS GROUPNAME
								FROM 	CMD_LOOKUP_VALUES									C
								LEFT OUTER JOIN		CMD_DICTIONARY	D	ON	C.DICTIONARYID = D.DICTIONARYID						           	   			   		    
								WHERE	C.LOOKUP_TYPE = 'DefectMapDefectGroup'
								AND		C.ENABLED_FLAG = 'Y'
								AND		D.LANGUAGETYPE = #{LANGUAGETYPE} 
							) 					GRP
							LEFT OUTER JOIN		
							(
								SELECT	C.LOOKUP_CODE AS CODEID
									,	D.DICTIONARYNAME						AS SUBNAME
									,	C.PARENTCODEID
								FROM	CMD_LOOKUP_VALUES									C
								LEFT OUTER JOIN 	CMD_DICTIONARY	D	ON 	C.DICTIONARYID = D.DICTIONARYID
								WHERE	C.LOOKUP_TYPE = 'DefectMapDefectGroupSub'
								AND		C.ENABLED_FLAG = 'Y'
								AND		D.LANGUAGETYPE = #{LANGUAGETYPE} 
							) 					
							SUB		ON GRP.CODEID = SUB.PARENTCODEID              
						) AOI		ON A.DEFECTCODE = AOI.SUBCODE
                                  AND A.SEGMENTTYPE = AOI.SEGMENTTYPE
                                  
		---------------------------------[4]
		-- (21.07.12) 추가
        INNER JOIN BAS_PRODUCTDEFINITION E      ON 	A.PRODUCTDEFID = E.PRODUCTDEFID
											   AND  A.PRODUCTDEFVERSION  = E.PRODUCTDEFVERSION
		---------------------------------
		-----------------------------------(21.08.10) 인계 시간 조건 추가        
		LEFT JOIN T_SENDTIME TT 
				ON TT.LOTID             			= A.LOTID
			   AND TT.PROCESSSEGMENTID  	= A.PROCESSSEGMENTID
		-----------------------------
                                  
		WHERE 1 = 1
		  AND A.SEGMENTTYPE = 'AOIInspection'
		  AND A.ENTERPRISEID = #{P_ENTERPRISEID}
		  AND A.PLANTID = #{P_PLANTID}		  
		<if test="P_PERIOD_PERIODFR != null and P_PERIOD_PERIODFR !='' and P_PERIOD_PERIODTO != null and P_PERIOD_PERIODTO !=''">
		  -- (21.08.10) 인계 시간 조건 추가 A.CREATEDTIME -> TT.SENDTIME
		  AND TT.SENDTIME <![CDATA[>=]]> TO_TIMESTAMP(SUBSTR(#{P_PERIOD_PERIODFR},1,14), 'YYYYMMDDHH24MISS')
		  AND TT.SENDTIME <![CDATA[<]]>  TO_TIMESTAMP(TO_CHAR(TO_DATE(SUBSTR(#{P_PERIOD_PERIODTO},1,8), 'YYYYMMDD'), 'YYYY-MM-DD') || ' ' || SUBSTR(#{P_PERIOD_PERIODTO}, 9, 6), 'YYYY-MM-DD HH24:MI:SS') 
		</if>
		<if test="LOTID_LIST.length != 0">
                AND		A.LOTID IN
	           <foreach collection="LOTID_LIST" item="item" index="index" separator="," open="(" close=")">
	                    #{item}
	           </foreach>				
		</if>	
		<if test="PROCESSSEGMENTID_LIST.length != 0">
                AND		A.PROCESSSEGMENTID IN
	           <foreach collection="PROCESSSEGMENTID_LIST" item="item" index="index" separator="," open="(" close=")">
	                    #{item}
	           </foreach>				
		</if>		
		<if test="PRODUCTDEFIDVER_LIST.length != 0">
                AND		A.PRODUCTDEFID || A.PRODUCTDEFVERSION IN
	           <foreach collection="PRODUCTDEFIDVER_LIST" item="item" index="index" separator="," open="(" close=")">
	                    #{item}
	           </foreach>				
		</if>
		<if test="P_AOIPROCESS != null and P_AOIPROCESS !=''">
			-- AOI 공정
			AND	 EXISTS (SELECT 1 FROM ufn_selectStringToSplit(#{P_AOIPROCESS},',') WHERE value = A.PROCESSSEGMENTID) 
		</if>
		
		<if test="P_PRODUCTIONTYPE != null and P_PRODUCTIONTYPE !='' and !(P_PRODUCTIONTYPE eq '*'.toString()) ">
			-- (21.07.12) 생산구분 추가[4]
			AND 	E.PRODUCTIONTYPE 			= #{P_PRODUCTIONTYPE}
		</if>
		
		
        GROUP BY 
		 			A.SEGMENTTYPE    
                ,   A.PROCESSSEGMENTID
                ,   A.LOTID
        ) A
        GROUP BY 
		 			A.SEGMENTTYPE    
                ,   A.PROCESSSEGMENTID 
	    ) B
		WHERE A.PROCESSSEGMENTID = B.PROCESSSEGMENTID
				)  A
				GROUP BY 
						A.GROUPCODE						
					,	A.GROUPNAME					    
					,	A.SUBCODE
					,	A.SUBNAME											
			   )	  S -- SUBCODE	
			 WHERE 1 = 1
				AND G.GROUPCODE = S.GROUPCODE
				AND G.BEFOREDEFECTRATE <![CDATA[>]]> 0
			<if test="P_GROUPCODE != null and P_GROUPCODE !=''">
				AND G.GROUPCODE = #{P_GROUPCODE}
			</if>		    
			ORDER BY 	
					G.GROUPCODE
				  , 	S.SUBCODE	    	   			
    </select>

  <!-- AOI 분석 전/후 비교 조회 -->
    <select id="getDefectRateByRepairBeforeDetail" parameterType="map" resultType="hashmap">
			-- getDefectRateByRepairBeforeDetail 품목코드 입력시
			WITH	LOTLIST	AS 
			(
					SELECT	C.LOTSTARTDATE
						,	C.LOTID
						,	C.PRODUCTDEFID
						,	C.PRODUCTDEFVERSION
						,	C.PROCESSSEGMENTID
					FROM	PCM_LOT C
					WHERE	
                            --EXISTS
                        	C.LOTID IN		-- (21.06.17) 속도개선 lot 처럼 변경함 
							(	SELECT	A.LOTID		--1 (21.06.17) 속도개선 lot 처럼 변경함
								FROM	PCM_LOTWORKRESULT				A
										INNER JOIN	BAS_PROCESSSEGMENT	B	ON A.PROCESSSEGMENTID = B.PROCESSSEGMENTID 
								WHERE	1=1
					            -- (21.06.17) 속도개선 lot 처럼 변경함
				            	--AND		C.LOTID = A.LOTID
								AND		(
						          			-- (21.08.10) WORKENDTIME -> SENDTIME 변경
						          			(		B.PROCESSSEGMENTCLASSID = '7012'	
						          				AND	A.SENDTIME			-- (21.06.03  endtime로 다 변경)		A.WORKSTARTTIME 
						          				BETWEEN	TO_TIMESTAMP(#{P_PERIOD_PERIODFR}, 'YYYY-MM-DD HH24:MI:SS')	
									                					AND	TO_TIMESTAMP(#{P_PERIOD_PERIODTO}, 'YYYY-MM-DD HH24:MI:SS') 
					  						)
										)
							)
					<if test="P_LOTID != null and P_LOTID !='' and !(P_LOTID eq '*'.toString()) ">
						AND		C.LOTID = #{P_LOTID}
					</if>
					<if test="P_PRODUCTDEFID != null and P_PRODUCTDEFID !=''"> 
					  AND		C.PRODUCTDEFID = #{P_PRODUCTDEFID}
					</if>					
					<if test="P_PRODUCTDEFVERSION != null and P_PRODUCTDEFVERSION !='' and !(P_PRODUCTDEFVERSION eq '*'.toString()) ">
						AND		EXISTS
						(
							SELECT	1
							FROM	(SELECT DATA AS VALUE 
									  FROM TABLE(CAST(FN_TO_ROWS(#{P_PRODUCTDEFVERSION}) AS TP_SIMPLE_TABLE)) 
									) LMP
							WHERE	C.PRODUCTDEFVERSION = LMP.VALUE
						)
					</if>
			)		
			
			-----------------------------(21.08.10) 인계 시간 조회
			, T_SENDTIME AS (
					SELECT	A.LOTID		
					, 			A.PROCESSSEGMENTID
					, 			MAX(A.SENDTIME) 		AS 	SENDTIME		       -- 인계 시간
					, 			B.PROCESSSEGMENTCLASSID
				FROM			PCM_LOTWORKRESULT				A
				INNER JOIN	BAS_PROCESSSEGMENT				B	
				ON  			A.PROCESSSEGMENTID = B.PROCESSSEGMENTID 
				AND 			B.PROCESSSEGMENTCLASSID IN ('7012','7014','7022')
				WHERE		1=1
				AND 			LOTID IN (
					SELECT LOTID
					  FROM LOTLIST
				)
				GROUP BY    A.LOTID		
					,       A.PROCESSSEGMENTID
					,       B.PROCESSSEGMENTCLASSID
			)
		-----------------------------
				
		SELECT
				  '0'    AS  CHK	
				, T.PROCESSSEGMENTID
				, T.PROCESSSEGMENTNAME				          
				, G.GROUPCODE
				, G.GROUPNAME
				, G.BEFOREDEFECTCNT			AS GROUPCNT
				, G.BEFOREDEFECTRATE		AS GROUPRATE				
				, S.SUBCODE
				, S.SUBNAME
				, S.BEFOREDEFECTCNT		  AS SUBCNT
				, S.BEFOREDEFECTRATE	  AS SUBRATE	
				, T.BEFOREDEFECTRATE	  AS SEGTOTRATE
		FROM
		(
		SELECT	
				A.PROCESSSEGMENTID
			,   A.PROCESSSEGMENTNAME				
			,   SUM(NVL(A.DEFECTCOUNT,0)) AS BEFOREDEFECTCNT
			,   ROUND(DECODE(MAX(NVL(A.INSPECTIONQTY,0)), 0, 0, SUM(NVL(A.DEFECTCOUNT,0))/ MAX(NVL(A.INSPECTIONQTY,0))) * 100, 2) AS BEFOREDEFECTRATE     

               FROM
               (
			    SELECT
					A.PRODUCTDEFID
				,	A.PRODUCTDEFVERSION
				,	A.LOTID
				,	A.PROCESSSEGMENTID
				,	A.PROCESSSEGMENTNAME 
                ,	B.INSPECTIONQTY                
               ,    A.REPAIRTARGETQTY
               ,    A.REPAIRRESULTQTY 
                ,  A.GROUPCODE 
                ,  A.GROUPNAME
                ,	A.SUBCODE	 
                ,	A.SUBNAME
                ,  A.COLOR
                , A.DEFECTCOUNT
				FROM
			   (
               SELECT                
					A.PRODUCTDEFID
				,	A.PRODUCTDEFVERSION
				,	A.LOTID
				,	A.PROCESSSEGMENTID
				,	DIC.DICTIONARYNAME 		AS PROCESSSEGMENTNAME 
                ,	A.INSPECTIONQTY                
               ,    A.REPAIRTARGETQTY
               ,    A.REPAIRRESULTQTY 
                 ----------------------------------------------------------------(21.06.17)
                -- 블량 그룹 
                ,  (
                        CASE WHEN AOI.GROUPCODE = '005'  
                            THEN T_AFT_ANALYSIS.GROUPCODE
                            ELSE COALESCE(AOI.GROUPCODE, '999')
                            END
                    ) AS GROUPCODE
                -- 블량 그룹명 
                ,  (
                        CASE WHEN AOI.GROUPCODE = '005'  
                            THEN T_AFT_ANALYSIS.GROUPNAME
                            ELSE COALESCE(AOI.GROUPNAME, 'NONE')
                            END
                    ) AS GROUPNAME
                -- 불량 코드   
                ,	COALESCE(
                            CASE A.SEGMENTTYPE
                                WHEN 'AOIInspection' 
                                THEN (
                                       CASE WHEN AOI.GROUPCODE = '005'  
                                            THEN T_AFT_ANALYSIS.SUBCODE
                                            ELSE AOI.SUBCODE
                                            END 
                                    )
                                ELSE AOI.SUBCODE
                            END, '9999') 														AS	SUBCODE	 
                -- 불량 코드명
                ,	COALESCE(
                            CASE A.SEGMENTTYPE
                                WHEN 'AOIInspection' 
                                THEN (
                                       CASE WHEN AOI.GROUPCODE = '005'  
                                            THEN T_AFT_ANALYSIS.SUBNAME
                                            ELSE  AOI.SUBNAME
                                            END 
                                    )
                                ELSE AOI.SUBNAME
                            END, 'NONE')														AS	SUBNAME
                -- 불량 색상
                ,  COALESCE(
                            CASE A.SEGMENTTYPE
                                WHEN 'AOIInspection' 
                                THEN (
                                       CASE WHEN AOI.GROUPCODE = '005'  
                                            THEN T_AFT_ANALYSIS.COLOR
                                            ELSE AOI.COLOR
                                            END 
                                    )
                                ELSE AOI.COLOR
                            END, '#000000')														AS	COLOR
                    
                -- 불량 수량 
                , A.DEFECTCOUNT
               -----------------------------------------------------------------------------------------    
		FROM PCM_QCAOIBBTWORKCOMPLETE	A
			INNER JOIN LOTLIST 					L	ON	A.LOTID = L.LOTID
													AND	A.PRODUCTDEFID = L.PRODUCTDEFID
													AND	A.PRODUCTDEFVERSION = L.PRODUCTDEFVERSION				
            -- (21.06.17) 완료된 상태 체크   -> (21.06.18) 여러건 존재함 하나만 나오도록 수정
            INNER JOIN (SELECT RESOURCEID
                            ,  INSPECTIONDEFID  
                            , PROCESSSEGMENTID, PROCESSSEGMENTVERSION
                         FROM  QAM_INSPECTIONRESULT   
                         GROUP BY  RESOURCEID, INSPECTIONDEFID    
                                    , PROCESSSEGMENTID, PROCESSSEGMENTVERSION
                         ) Q_INSP
            ON Q_INSP.RESOURCEID                 		=  A.LOTID
            AND Q_INSP.INSPECTIONDEFID 					= 	'AOIInspection'
            AND Q_INSP.PROCESSSEGMENTID					= A.PROCESSSEGMENTID
            AND Q_INSP.PROCESSSEGMENTVERSION			= A.PROCESSSEGMENTVERSION
            -----------------------------------------------------------------   	
            LEFT OUTER JOIN (
					SELECT	GRP.CODEID								AS	GROUPCODE
						,	GRP.GROUPNAME							AS	GROUPNAME
						,	GRP.DESCRIPTION 							AS	COLOR
						,	SUB.CODEID									AS	SUBCODE
						,	SUB.SUBNAME								AS	SUBNAME
						,	'AOIInspection'								AS	SEGMENTTYPE
						,   '005'                                       	AS  CHK_G_CODE
                                    ,   (
                                        CASE WHEN SUB.CODEID = '1001'
                                             THEN '5001'
                                             ELSE '5002'
                                             END
                                    )   													AS CHK_S_CODE
					FROM	
					(
						SELECT 	C.LOOKUP_CODE   AS CODEID
							,	C.DESCRIPTION
							,	D.DICTIONARYNAME						AS	GROUPNAME
						FROM 	CMD_LOOKUP_VALUES									C
						LEFT OUTER JOIN		CMD_DICTIONARY	D			ON	C.DICTIONARYID = D.DICTIONARYID						           	   			   		    
						WHERE	C.LOOKUP_TYPE = 'DefectMapDefectGroup'
						AND		C.ENABLED_FLAG = 'Y'
						AND		D.LANGUAGETYPE = #{LANGUAGETYPE}        -- 다국어 코드
					) 					GRP
					LEFT OUTER JOIN		
					(
						SELECT	C.LOOKUP_CODE   AS CODEID
							,	D.DICTIONARYNAME						AS	SUBNAME
							,	C.PARENTCODEID
						FROM	CMD_LOOKUP_VALUES									C
						LEFT OUTER JOIN 	CMD_DICTIONARY	D			ON 	C.DICTIONARYID = D.DICTIONARYID
						WHERE	C.LOOKUP_TYPE = 'DefectMapDefectGroupSub'
						AND		C.ENABLED_FLAG = 'Y'
						AND		D.LANGUAGETYPE = #{LANGUAGETYPE}        -- 다국어 코드
					) 					SUB								ON	GRP.CODEID = SUB.PARENTCODEID
					WHERE 1 = 1
                              AND GRP.CODEID IN ('001','002')
                              AND SUB.CODEID IN ('1001','2001')
				)   T_AFT_ANALYSIS
            ON A.SEGMENTTYPE = T_AFT_ANALYSIS.SEGMENTTYPE 
            AND A.DEFECTCODE = T_AFT_ANALYSIS.CHK_S_CODE
-----------------------------------------------------------------     		
		INNER JOIN	BAS_PROCESSSEGMENTEXT	C	ON A.PROCESSSEGMENTID = C.PROCESSSEGMENTID 
										  AND A.ENTERPRISEID = C.ENTERPRISEID                                   
		LEFT OUTER JOIN (	
						  SELECT	
						  		    'AOIInspection'                             AS SEGMENTTYPE
		                        ,   GRP.CODEID									AS GROUPCODE
								,	GRP.GROUPNAME							AS GROUPNAME
								,	GRP.DESCRIPTION 							AS COLOR
								,	SUB.CODEID									AS SUBCODE
								,	SUB.SUBNAME								AS SUBNAME
							FROM	
							(
								SELECT 	C.LOOKUP_CODE   AS CODEID
									,	C.DESCRIPTION
									,	D.DICTIONARYNAME						AS GROUPNAME
								FROM 	CMD_LOOKUP_VALUES									C
								LEFT OUTER JOIN		CMD_DICTIONARY	D	ON	C.DICTIONARYID = D.DICTIONARYID						           	   			   		    
								WHERE	C.LOOKUP_TYPE = 'DefectMapDefectGroup'
								AND		C.ENABLED_FLAG = 'Y'
								AND		D.LANGUAGETYPE = #{LANGUAGETYPE} 
							) 					GRP
							LEFT OUTER JOIN		
							(
								SELECT	C.LOOKUP_CODE AS CODEID
									,	D.DICTIONARYNAME						AS SUBNAME
									,	C.PARENTCODEID
								FROM	CMD_LOOKUP_VALUES									C
								LEFT OUTER JOIN 	CMD_DICTIONARY	D	ON 	C.DICTIONARYID = D.DICTIONARYID
								WHERE	C.LOOKUP_TYPE = 'DefectMapDefectGroupSub'
								AND		C.ENABLED_FLAG = 'Y'
								AND		D.LANGUAGETYPE = #{LANGUAGETYPE} 
							) 					
							SUB		ON GRP.CODEID = SUB.PARENTCODEID              
						) AOI		ON A.DEFECTCODE = AOI.SUBCODE
								  AND A.SEGMENTTYPE = AOI.SEGMENTTYPE						
        LEFT JOIN CMD_DICTIONARY         	DIC	ON	DIC.DICTIONARYID = C.PROCESSSEGMENTNAME
                                                AND DIC.LANGUAGETYPE = #{LANGUAGETYPE}      
                                                
        
        ---------------------------------[1]
		-- (21.07.12) 추가
        INNER JOIN BAS_PRODUCTDEFINITION E      ON 	A.PRODUCTDEFID = E.PRODUCTDEFID
											   AND  A.PRODUCTDEFVERSION  = E.PRODUCTDEFVERSION
		---------------------------------
		
		-----------------------------------(21.08.10) 인계 시간 조건 추가        
		LEFT JOIN T_SENDTIME TT 
				ON TT.LOTID             			= A.LOTID
			   AND TT.PROCESSSEGMENTID  	= A.PROCESSSEGMENTID
		-----------------------------
                                                
                                                	                                                												
		WHERE 1 = 1
		  AND A.SEGMENTTYPE = 'AOIInspection'
		  AND A.ENTERPRISEID = #{P_ENTERPRISEID}
		  AND A.PLANTID = #{P_PLANTID}		  
		<if test="P_PERIOD_PERIODFR != null and P_PERIOD_PERIODFR !='' and P_PERIOD_PERIODTO != null and P_PERIOD_PERIODTO !=''">
		  -- (21.08.10) 인계 시간 조건 추가 A.CREATEDTIME  --> TT.SENDTIME
		  AND TT.SENDTIME <![CDATA[>=]]> TO_TIMESTAMP(SUBSTR(#{P_PERIOD_PERIODFR},1,14), 'YYYYMMDDHH24MISS')
		  AND TT.SENDTIME <![CDATA[<]]>  TO_TIMESTAMP(TO_CHAR(TO_DATE(SUBSTR(#{P_PERIOD_PERIODTO},1,8), 'YYYYMMDD'), 'YYYY-MM-DD') || ' ' || SUBSTR(#{P_PERIOD_PERIODTO}, 9, 6), 'YYYY-MM-DD HH24:MI:SS') 
		</if>
		<if test="LOTID_LIST.length != 0">
                AND		A.LOTID IN
	           <foreach collection="LOTID_LIST" item="item" index="index" separator="," open="(" close=")">
	                    #{item}
	           </foreach>				
		</if>	
		<if test="PROCESSSEGMENTID_LIST.length != 0">
                AND		A.PROCESSSEGMENTID IN
	           <foreach collection="PROCESSSEGMENTID_LIST" item="item" index="index" separator="," open="(" close=")">
	                    #{item}
	           </foreach>				
		</if>			
		<if test="PRODUCTDEFIDVER_LIST.length != 0">
                AND		A.PRODUCTDEFID || A.PRODUCTDEFVERSION IN
	           <foreach collection="PRODUCTDEFIDVER_LIST" item="item" index="index" separator="," open="(" close=")">
	                    #{item}
	           </foreach>				
		</if>
		<if test="P_AOIPROCESS != null and P_AOIPROCESS !=''">
			-- AOI 공정
			AND	 EXISTS (SELECT 1 FROM ufn_selectStringToSplit(#{P_AOIPROCESS},',') WHERE value = A.PROCESSSEGMENTID) 
		</if>
		
		<if test="P_PRODUCTIONTYPE != null and P_PRODUCTIONTYPE !='' and !(P_PRODUCTIONTYPE eq '*'.toString()) ">
			-- (21.07.12) 생산구분 추가[1]
			AND 	E.PRODUCTIONTYPE 			= #{P_PRODUCTIONTYPE}
		</if>
		
		
		) A
		, 
           
		   (
		   SELECT
					A.SEGMENTTYPE    
                ,   A.PROCESSSEGMENTID
                ,   SUM(A.INSPECTIONQTY) AS INSPECTIONQTY
            FROM
           (
		   SELECT
					A.SEGMENTTYPE    
                ,   A.PROCESSSEGMENTID
                ,   A.LOTID
                ,	MAX(A.INSPECTIONQTY) AS INSPECTIONQTY	   
		FROM PCM_QCAOIBBTWORKCOMPLETE	A
			INNER JOIN LOTLIST 					L	ON	A.LOTID = L.LOTID
													AND	A.PRODUCTDEFID = L.PRODUCTDEFID
													AND	A.PRODUCTDEFVERSION = L.PRODUCTDEFVERSION				
            -- (21.06.17) 완료된 상태 체크   -> (21.06.18) 여러건 존재함 하나만 나오도록 수정
            INNER JOIN (SELECT RESOURCEID
                            ,  INSPECTIONDEFID  
                            , PROCESSSEGMENTID, PROCESSSEGMENTVERSION
                         FROM  QAM_INSPECTIONRESULT   
                         GROUP BY  RESOURCEID, INSPECTIONDEFID    
                                    , PROCESSSEGMENTID, PROCESSSEGMENTVERSION
                         ) Q_INSP
            ON Q_INSP.RESOURCEID                 		=  A.LOTID
            AND Q_INSP.INSPECTIONDEFID 					= 	'AOIInspection'
            AND Q_INSP.PROCESSSEGMENTID					= A.PROCESSSEGMENTID
            AND Q_INSP.PROCESSSEGMENTVERSION			= A.PROCESSSEGMENTVERSION
            -----------------------------------------------------------------   	
            LEFT OUTER JOIN (
					SELECT	GRP.CODEID								AS	GROUPCODE
						,	GRP.GROUPNAME							AS	GROUPNAME
						,	GRP.DESCRIPTION 							AS	COLOR
						,	SUB.CODEID									AS	SUBCODE
						,	SUB.SUBNAME								AS	SUBNAME
						,	'AOIInspection'								AS	SEGMENTTYPE
						,   '005'                                       	AS  CHK_G_CODE
                                    ,   (
                                        CASE WHEN SUB.CODEID = '1001'
                                             THEN '5001'
                                             ELSE '5002'
                                             END
                                    )   													AS CHK_S_CODE
					FROM	
					(
						SELECT 	C.LOOKUP_CODE   AS CODEID
							,	C.DESCRIPTION
							,	D.DICTIONARYNAME						AS	GROUPNAME
						FROM 	CMD_LOOKUP_VALUES									C
						LEFT OUTER JOIN		CMD_DICTIONARY	D			ON	C.DICTIONARYID = D.DICTIONARYID						           	   			   		    
						WHERE	C.LOOKUP_TYPE = 'DefectMapDefectGroup'
						AND		C.ENABLED_FLAG = 'Y'
						AND		D.LANGUAGETYPE = #{LANGUAGETYPE}        -- 다국어 코드
					) 					GRP
					LEFT OUTER JOIN		
					(
						SELECT	C.LOOKUP_CODE   AS CODEID
							,	D.DICTIONARYNAME						AS	SUBNAME
							,	C.PARENTCODEID
						FROM	CMD_LOOKUP_VALUES									C
						LEFT OUTER JOIN 	CMD_DICTIONARY	D			ON 	C.DICTIONARYID = D.DICTIONARYID
						WHERE	C.LOOKUP_TYPE = 'DefectMapDefectGroupSub'
						AND		C.ENABLED_FLAG = 'Y'
						AND		D.LANGUAGETYPE = #{LANGUAGETYPE}        -- 다국어 코드
					) 					SUB								ON	GRP.CODEID = SUB.PARENTCODEID
					WHERE 1 = 1
                              AND GRP.CODEID IN ('001','002')
                              AND SUB.CODEID IN ('1001','2001')
				)   T_AFT_ANALYSIS
            ON A.SEGMENTTYPE = T_AFT_ANALYSIS.SEGMENTTYPE 
            AND A.DEFECTCODE = T_AFT_ANALYSIS.CHK_S_CODE
-----------------------------------------------------------------     		
		INNER JOIN	BAS_PROCESSSEGMENTEXT	C	ON A.PROCESSSEGMENTID = C.PROCESSSEGMENTID 
										  AND A.ENTERPRISEID = C.ENTERPRISEID                                   
		LEFT OUTER JOIN (	
						  SELECT	
						  		    'AOIInspection'                             AS SEGMENTTYPE
		                        ,   GRP.CODEID									AS GROUPCODE
								,	GRP.GROUPNAME							AS GROUPNAME
								,	GRP.DESCRIPTION 							AS COLOR
								,	SUB.CODEID									AS SUBCODE
								,	SUB.SUBNAME								AS SUBNAME
							FROM	
							(
								SELECT 	C.LOOKUP_CODE   AS CODEID
									,	C.DESCRIPTION
									,	D.DICTIONARYNAME						AS GROUPNAME
								FROM 	CMD_LOOKUP_VALUES									C
								LEFT OUTER JOIN		CMD_DICTIONARY	D	ON	C.DICTIONARYID = D.DICTIONARYID						           	   			   		    
								WHERE	C.LOOKUP_TYPE = 'DefectMapDefectGroup'
								AND		C.ENABLED_FLAG = 'Y'
								AND		D.LANGUAGETYPE = #{LANGUAGETYPE} 
							) 					GRP
							LEFT OUTER JOIN		
							(
								SELECT	C.LOOKUP_CODE AS CODEID
									,	D.DICTIONARYNAME						AS SUBNAME
									,	C.PARENTCODEID
								FROM	CMD_LOOKUP_VALUES									C
								LEFT OUTER JOIN 	CMD_DICTIONARY	D	ON 	C.DICTIONARYID = D.DICTIONARYID
								WHERE	C.LOOKUP_TYPE = 'DefectMapDefectGroupSub'
								AND		C.ENABLED_FLAG = 'Y'
								AND		D.LANGUAGETYPE = #{LANGUAGETYPE} 
							) 					
							SUB		ON GRP.CODEID = SUB.PARENTCODEID              
						) AOI		ON A.DEFECTCODE = AOI.SUBCODE
								  AND A.SEGMENTTYPE = AOI.SEGMENTTYPE						
        LEFT JOIN CMD_DICTIONARY         	DIC	ON	DIC.DICTIONARYID = C.PROCESSSEGMENTNAME
                                                AND DIC.LANGUAGETYPE = #{LANGUAGETYPE}     
                                                
                                                
		---------------------------------[2]
		-- (21.07.12) 추가
        INNER JOIN BAS_PRODUCTDEFINITION E      ON 	A.PRODUCTDEFID = E.PRODUCTDEFID
											   AND  A.PRODUCTDEFVERSION  = E.PRODUCTDEFVERSION
		---------------------------------
		
		-----------------------------------(21.08.10) 인계 시간 조건 추가        
		LEFT JOIN T_SENDTIME TT 
				ON TT.LOTID             			= A.LOTID
			   AND TT.PROCESSSEGMENTID  	= A.PROCESSSEGMENTID
		-----------------------------


		WHERE 1 = 1
		  AND A.SEGMENTTYPE = 'AOIInspection'
		  AND A.ENTERPRISEID = #{P_ENTERPRISEID}
		  AND A.PLANTID = #{P_PLANTID}		  
		<if test="P_PERIOD_PERIODFR != null and P_PERIOD_PERIODFR !='' and P_PERIOD_PERIODTO != null and P_PERIOD_PERIODTO !=''">
		  
		  -- (21.08.10) 인계 시간 조건 추가 A.CREATEDTIME --> TT.SENDTIME
		  AND TT.SENDTIME <![CDATA[>=]]> TO_TIMESTAMP(SUBSTR(#{P_PERIOD_PERIODFR},1,14), 'YYYYMMDDHH24MISS')
		  AND TT.SENDTIME <![CDATA[<]]>  TO_TIMESTAMP(TO_CHAR(TO_DATE(SUBSTR(#{P_PERIOD_PERIODTO},1,8), 'YYYYMMDD'), 'YYYY-MM-DD') || ' ' || SUBSTR(#{P_PERIOD_PERIODTO}, 9, 6), 'YYYY-MM-DD HH24:MI:SS') 
		</if>
		<if test="LOTID_LIST.length != 0">
                AND		A.LOTID IN
	           <foreach collection="LOTID_LIST" item="item" index="index" separator="," open="(" close=")">
	                    #{item}
	           </foreach>				
		</if>	
		<if test="PROCESSSEGMENTID_LIST.length != 0">
                AND		A.PROCESSSEGMENTID IN
	           <foreach collection="PROCESSSEGMENTID_LIST" item="item" index="index" separator="," open="(" close=")">
	                    #{item}
	           </foreach>				
		</if>			
		<if test="PRODUCTDEFIDVER_LIST.length != 0">
                AND		A.PRODUCTDEFID || A.PRODUCTDEFVERSION IN
	           <foreach collection="PRODUCTDEFIDVER_LIST" item="item" index="index" separator="," open="(" close=")">
	                    #{item}
	           </foreach>				
		</if>
		<if test="P_AOIPROCESS != null and P_AOIPROCESS !=''">
			-- AOI 공정
			AND	 EXISTS (SELECT 1 FROM ufn_selectStringToSplit(#{P_AOIPROCESS},',') WHERE value = A.PROCESSSEGMENTID) 
		</if>
		
		<if test="P_PRODUCTIONTYPE != null and P_PRODUCTIONTYPE !='' and !(P_PRODUCTIONTYPE eq '*'.toString()) ">
			-- (21.07.12) 생산구분 추가[2]
			AND 	E.PRODUCTIONTYPE 			= #{P_PRODUCTIONTYPE}
		</if>
		
        GROUP BY 
		 			A.SEGMENTTYPE    
                ,   A.PROCESSSEGMENTID
                ,   A.LOTID
        ) A
        GROUP BY 
		 			A.SEGMENTTYPE    
                ,   A.PROCESSSEGMENTID 
	    ) B
		WHERE A.PROCESSSEGMENTID = B.PROCESSSEGMENTID
		    ) A
            GROUP BY 
					A.PROCESSSEGMENTID
				,   A.PROCESSSEGMENTNAME          													
		   )	  T  -- PROCESSSEGMENTNAME			
		  , (
				SELECT	
						A.PROCESSSEGMENTID
					,   A.PROCESSSEGMENTNAME			
					,   A.GROUPCODE						AS GROUPCODE
					,	A.GROUPNAME						AS GROUPNAME			
				   ,    SUM(NVL(A.DEFECTCOUNT,0))			AS BEFOREDEFECTCNT
					,   ROUND(DECODE(MAX(NVL(A.INSPECTIONQTY,0)), 0, 0, SUM(NVL(A.DEFECTCOUNT,0))/ MAX(NVL(A.INSPECTIONQTY,0))) * 100, 2) AS BEFOREDEFECTRATE     
               FROM
               (
			    SELECT
					A.PRODUCTDEFID
				,	A.PRODUCTDEFVERSION
				,	A.LOTID
				,	A.PROCESSSEGMENTID
				,	A.PROCESSSEGMENTNAME 
                ,	B.INSPECTIONQTY                
               ,    A.REPAIRTARGETQTY
               ,    A.REPAIRRESULTQTY 
                ,  A.GROUPCODE 
                ,  A.GROUPNAME
                ,	A.SUBCODE	 
                ,	A.SUBNAME
                ,  A.COLOR
                , A.DEFECTCOUNT
				FROM
			   (
               SELECT                
					A.PRODUCTDEFID
				,	A.PRODUCTDEFVERSION
				,	A.LOTID
				,	A.PROCESSSEGMENTID
				,	DIC.DICTIONARYNAME 		AS PROCESSSEGMENTNAME 
                ,	A.INSPECTIONQTY                
               ,    A.REPAIRTARGETQTY
               ,    A.REPAIRRESULTQTY 
                 ----------------------------------------------------------------(21.06.17)
                -- 블량 그룹 
                ,  (
                        CASE WHEN AOI.GROUPCODE = '005'  
                            THEN T_AFT_ANALYSIS.GROUPCODE
                            ELSE COALESCE(AOI.GROUPCODE, '999')
                            END
                    ) AS GROUPCODE
                -- 블량 그룹명 
                ,  (
                        CASE WHEN AOI.GROUPCODE = '005'  
                            THEN T_AFT_ANALYSIS.GROUPNAME
                            ELSE COALESCE(AOI.GROUPNAME, 'NONE')
                            END
                    ) AS GROUPNAME
                -- 불량 코드   
                ,	COALESCE(
                            CASE A.SEGMENTTYPE
                                WHEN 'AOIInspection' 
                                THEN (
                                       CASE WHEN AOI.GROUPCODE = '005'  
                                            THEN T_AFT_ANALYSIS.SUBCODE
                                            ELSE AOI.SUBCODE
                                            END 
                                    )
                                ELSE AOI.SUBCODE
                            END, '9999') 														AS	SUBCODE	 
                -- 불량 코드명
                ,	COALESCE(
                            CASE A.SEGMENTTYPE
                                WHEN 'AOIInspection' 
                                THEN (
                                       CASE WHEN AOI.GROUPCODE = '005'  
                                            THEN T_AFT_ANALYSIS.SUBNAME
                                            ELSE  AOI.SUBNAME
                                            END 
                                    )
                                ELSE AOI.SUBNAME
                            END, 'NONE')														AS	SUBNAME
                -- 불량 색상
                ,  COALESCE(
                            CASE A.SEGMENTTYPE
                                WHEN 'AOIInspection' 
                                THEN (
                                       CASE WHEN AOI.GROUPCODE = '005'  
                                            THEN T_AFT_ANALYSIS.COLOR
                                            ELSE AOI.COLOR
                                            END 
                                    )
                                ELSE AOI.COLOR
                            END, '#000000')														AS	COLOR
                    
                -- 불량 수량 
                , A.DEFECTCOUNT
               -----------------------------------------------------------------------------------------    
		FROM PCM_QCAOIBBTWORKCOMPLETE	A
			INNER JOIN LOTLIST 					L	ON	A.LOTID = L.LOTID
													AND	A.PRODUCTDEFID = L.PRODUCTDEFID
													AND	A.PRODUCTDEFVERSION = L.PRODUCTDEFVERSION				
            -- (21.06.17) 완료된 상태 체크   -> (21.06.18) 여러건 존재함 하나만 나오도록 수정
            INNER JOIN (SELECT RESOURCEID
                            ,  INSPECTIONDEFID  
                            , PROCESSSEGMENTID, PROCESSSEGMENTVERSION
                         FROM  QAM_INSPECTIONRESULT   
                         GROUP BY  RESOURCEID, INSPECTIONDEFID    
                                    , PROCESSSEGMENTID, PROCESSSEGMENTVERSION
                         ) Q_INSP
            ON Q_INSP.RESOURCEID                 		=  A.LOTID
            AND Q_INSP.INSPECTIONDEFID 					= 	'AOIInspection'
            AND Q_INSP.PROCESSSEGMENTID					= A.PROCESSSEGMENTID
            AND Q_INSP.PROCESSSEGMENTVERSION			= A.PROCESSSEGMENTVERSION
            -----------------------------------------------------------------   	
            LEFT OUTER JOIN (
					SELECT	GRP.CODEID								AS	GROUPCODE
						,	GRP.GROUPNAME							AS	GROUPNAME
						,	GRP.DESCRIPTION 							AS	COLOR
						,	SUB.CODEID									AS	SUBCODE
						,	SUB.SUBNAME								AS	SUBNAME
						,	'AOIInspection'								AS	SEGMENTTYPE
						,   '005'                                       	AS  CHK_G_CODE
                                    ,   (
                                        CASE WHEN SUB.CODEID = '1001'
                                             THEN '5001'
                                             ELSE '5002'
                                             END
                                    )   													AS CHK_S_CODE
					FROM	
					(
						SELECT 	C.LOOKUP_CODE   AS CODEID
							,	C.DESCRIPTION
							,	D.DICTIONARYNAME						AS	GROUPNAME
						FROM 	CMD_LOOKUP_VALUES									C
						LEFT OUTER JOIN		CMD_DICTIONARY	D			ON	C.DICTIONARYID = D.DICTIONARYID						           	   			   		    
						WHERE	C.LOOKUP_TYPE = 'DefectMapDefectGroup'
						AND		C.ENABLED_FLAG = 'Y'
						AND		D.LANGUAGETYPE = #{LANGUAGETYPE}        -- 다국어 코드
					) 					GRP
					LEFT OUTER JOIN		
					(
						SELECT	C.LOOKUP_CODE   AS CODEID
							,	D.DICTIONARYNAME						AS	SUBNAME
							,	C.PARENTCODEID
						FROM	CMD_LOOKUP_VALUES									C
						LEFT OUTER JOIN 	CMD_DICTIONARY	D			ON 	C.DICTIONARYID = D.DICTIONARYID
						WHERE	C.LOOKUP_TYPE = 'DefectMapDefectGroupSub'
						AND		C.ENABLED_FLAG = 'Y'
						AND		D.LANGUAGETYPE = #{LANGUAGETYPE}        -- 다국어 코드
					) 					SUB								ON	GRP.CODEID = SUB.PARENTCODEID
					WHERE 1 = 1
                              AND GRP.CODEID IN ('001','002')
                              AND SUB.CODEID IN ('1001','2001')
				)   T_AFT_ANALYSIS
            ON A.SEGMENTTYPE = T_AFT_ANALYSIS.SEGMENTTYPE 
            AND A.DEFECTCODE = T_AFT_ANALYSIS.CHK_S_CODE
-----------------------------------------------------------------     		
		INNER JOIN	BAS_PROCESSSEGMENTEXT	C	ON A.PROCESSSEGMENTID = C.PROCESSSEGMENTID 
										  AND A.ENTERPRISEID = C.ENTERPRISEID                                   
		LEFT OUTER JOIN (	
						  SELECT	
						  		    'AOIInspection'                             AS SEGMENTTYPE
		                        ,   GRP.CODEID									AS GROUPCODE
								,	GRP.GROUPNAME							AS GROUPNAME
								,	GRP.DESCRIPTION 							AS COLOR
								,	SUB.CODEID									AS SUBCODE
								,	SUB.SUBNAME								AS SUBNAME
							FROM	
							(
								SELECT 	C.LOOKUP_CODE   AS CODEID
									,	C.DESCRIPTION
									,	D.DICTIONARYNAME						AS GROUPNAME
								FROM 	CMD_LOOKUP_VALUES									C
								LEFT OUTER JOIN		CMD_DICTIONARY	D	ON	C.DICTIONARYID = D.DICTIONARYID						           	   			   		    
								WHERE	C.LOOKUP_TYPE = 'DefectMapDefectGroup'
								AND		C.ENABLED_FLAG = 'Y'
								AND		D.LANGUAGETYPE = #{LANGUAGETYPE} 
							) 					GRP
							LEFT OUTER JOIN		
							(
								SELECT	C.LOOKUP_CODE AS CODEID
									,	D.DICTIONARYNAME						AS SUBNAME
									,	C.PARENTCODEID
								FROM	CMD_LOOKUP_VALUES									C
								LEFT OUTER JOIN 	CMD_DICTIONARY	D	ON 	C.DICTIONARYID = D.DICTIONARYID
								WHERE	C.LOOKUP_TYPE = 'DefectMapDefectGroupSub'
								AND		C.ENABLED_FLAG = 'Y'
								AND		D.LANGUAGETYPE = #{LANGUAGETYPE} 
							) 					
							SUB		ON GRP.CODEID = SUB.PARENTCODEID              
						) AOI		ON A.DEFECTCODE = AOI.SUBCODE
								  AND A.SEGMENTTYPE = AOI.SEGMENTTYPE						
        LEFT JOIN CMD_DICTIONARY         	DIC	ON	DIC.DICTIONARYID = C.PROCESSSEGMENTNAME
                                                AND DIC.LANGUAGETYPE = #{LANGUAGETYPE}   
                                                
                                                
		---------------------------------[3]
		-- (21.07.12) 추가
        INNER JOIN BAS_PRODUCTDEFINITION E      ON 	A.PRODUCTDEFID = E.PRODUCTDEFID
											   AND  A.PRODUCTDEFVERSION  = E.PRODUCTDEFVERSION
		---------------------------------
		
		-----------------------------------(21.08.10) 인계 시간 조건 추가        
		LEFT JOIN T_SENDTIME TT 
				ON TT.LOTID             			= A.LOTID
			   AND TT.PROCESSSEGMENTID  	= A.PROCESSSEGMENTID
		-----------------------------
		
		                                                
		WHERE 1 = 1
		  AND A.SEGMENTTYPE = 'AOIInspection'
		  AND A.ENTERPRISEID = #{P_ENTERPRISEID}
		  AND A.PLANTID = #{P_PLANTID}		  
		<if test="P_PERIOD_PERIODFR != null and P_PERIOD_PERIODFR !='' and P_PERIOD_PERIODTO != null and P_PERIOD_PERIODTO !=''">
		  -- (21.08.10) 인계 시간 조건 추가  A.CREATEDTIME  --> TT.SENDTIME
		  AND TT.SENDTIME <![CDATA[>=]]> TO_TIMESTAMP(SUBSTR(#{P_PERIOD_PERIODFR},1,14), 'YYYYMMDDHH24MISS')
		  AND TT.SENDTIME <![CDATA[<]]>  TO_TIMESTAMP(TO_CHAR(TO_DATE(SUBSTR(#{P_PERIOD_PERIODTO},1,8), 'YYYYMMDD'), 'YYYY-MM-DD') || ' ' || SUBSTR(#{P_PERIOD_PERIODTO}, 9, 6), 'YYYY-MM-DD HH24:MI:SS') 
		</if>
		<if test="LOTID_LIST.length != 0">
                AND		A.LOTID IN
	           <foreach collection="LOTID_LIST" item="item" index="index" separator="," open="(" close=")">
	                    #{item}
	           </foreach>				
		</if>	
		<if test="PROCESSSEGMENTID_LIST.length != 0">
                AND		A.PROCESSSEGMENTID IN
	           <foreach collection="PROCESSSEGMENTID_LIST" item="item" index="index" separator="," open="(" close=")">
	                    #{item}
	           </foreach>				
		</if>			
		<if test="PRODUCTDEFIDVER_LIST.length != 0">
                AND		A.PRODUCTDEFID || A.PRODUCTDEFVERSION IN
	           <foreach collection="PRODUCTDEFIDVER_LIST" item="item" index="index" separator="," open="(" close=")">
	                    #{item}
	           </foreach>				
		</if>
		<if test="P_AOIPROCESS != null and P_AOIPROCESS !=''">
			-- AOI 공정
			AND	 EXISTS (SELECT 1 FROM ufn_selectStringToSplit(#{P_AOIPROCESS},',') WHERE value = A.PROCESSSEGMENTID) 
		</if>
		
		<if test="P_PRODUCTIONTYPE != null and P_PRODUCTIONTYPE !='' and !(P_PRODUCTIONTYPE eq '*'.toString()) ">
			-- (21.07.12) 생산구분 추가[3]
			AND 	E.PRODUCTIONTYPE 			= #{P_PRODUCTIONTYPE}
		</if>
		
		
		) A
		, 
           
		   (
		   SELECT
					A.SEGMENTTYPE    
                ,   A.PROCESSSEGMENTID
                ,   SUM(A.INSPECTIONQTY) AS INSPECTIONQTY
            FROM
           (
		   SELECT
					A.SEGMENTTYPE    
                ,   A.PROCESSSEGMENTID
                ,   A.LOTID
                ,	MAX(A.INSPECTIONQTY) AS INSPECTIONQTY	   
		FROM PCM_QCAOIBBTWORKCOMPLETE	A
			INNER JOIN LOTLIST 					L	ON	A.LOTID = L.LOTID
													AND	A.PRODUCTDEFID = L.PRODUCTDEFID
													AND	A.PRODUCTDEFVERSION = L.PRODUCTDEFVERSION				
            -- (21.06.17) 완료된 상태 체크   -> (21.06.18) 여러건 존재함 하나만 나오도록 수정
            INNER JOIN (SELECT RESOURCEID
                            ,  INSPECTIONDEFID  
                            , PROCESSSEGMENTID, PROCESSSEGMENTVERSION
                         FROM  QAM_INSPECTIONRESULT   
                         GROUP BY  RESOURCEID, INSPECTIONDEFID    
                                    , PROCESSSEGMENTID, PROCESSSEGMENTVERSION
                         ) Q_INSP
            ON Q_INSP.RESOURCEID                 		=  A.LOTID
            AND Q_INSP.INSPECTIONDEFID 					= 	'AOIInspection'
            AND Q_INSP.PROCESSSEGMENTID					= A.PROCESSSEGMENTID
            AND Q_INSP.PROCESSSEGMENTVERSION			= A.PROCESSSEGMENTVERSION
            -----------------------------------------------------------------   	
            LEFT OUTER JOIN (
					SELECT	GRP.CODEID								AS	GROUPCODE
						,	GRP.GROUPNAME							AS	GROUPNAME
						,	GRP.DESCRIPTION 							AS	COLOR
						,	SUB.CODEID									AS	SUBCODE
						,	SUB.SUBNAME								AS	SUBNAME
						,	'AOIInspection'								AS	SEGMENTTYPE
						,   '005'                                       	AS  CHK_G_CODE
                                    ,   (
                                        CASE WHEN SUB.CODEID = '1001'
                                             THEN '5001'
                                             ELSE '5002'
                                             END
                                    )   													AS CHK_S_CODE
					FROM	
					(
						SELECT 	C.LOOKUP_CODE   AS CODEID
							,	C.DESCRIPTION
							,	D.DICTIONARYNAME						AS	GROUPNAME
						FROM 	CMD_LOOKUP_VALUES									C
						LEFT OUTER JOIN		CMD_DICTIONARY	D			ON	C.DICTIONARYID = D.DICTIONARYID						           	   			   		    
						WHERE	C.LOOKUP_TYPE = 'DefectMapDefectGroup'
						AND		C.ENABLED_FLAG = 'Y'
						AND		D.LANGUAGETYPE = #{LANGUAGETYPE}        -- 다국어 코드
					) 					GRP
					LEFT OUTER JOIN		
					(
						SELECT	C.LOOKUP_CODE   AS CODEID
							,	D.DICTIONARYNAME						AS	SUBNAME
							,	C.PARENTCODEID
						FROM	CMD_LOOKUP_VALUES									C
						LEFT OUTER JOIN 	CMD_DICTIONARY	D			ON 	C.DICTIONARYID = D.DICTIONARYID
						WHERE	C.LOOKUP_TYPE = 'DefectMapDefectGroupSub'
						AND		C.ENABLED_FLAG = 'Y'
						AND		D.LANGUAGETYPE = #{LANGUAGETYPE}        -- 다국어 코드
					) 					SUB								ON	GRP.CODEID = SUB.PARENTCODEID
					WHERE 1 = 1
                              AND GRP.CODEID IN ('001','002')
                              AND SUB.CODEID IN ('1001','2001')
				)   T_AFT_ANALYSIS
            ON A.SEGMENTTYPE = T_AFT_ANALYSIS.SEGMENTTYPE 
            AND A.DEFECTCODE = T_AFT_ANALYSIS.CHK_S_CODE
-----------------------------------------------------------------     		
		INNER JOIN	BAS_PROCESSSEGMENTEXT	C	ON A.PROCESSSEGMENTID = C.PROCESSSEGMENTID 
										  AND A.ENTERPRISEID = C.ENTERPRISEID                                   
		LEFT OUTER JOIN (	
						  SELECT	
						  		    'AOIInspection'                             AS SEGMENTTYPE
		                        ,   GRP.CODEID									AS GROUPCODE
								,	GRP.GROUPNAME							AS GROUPNAME
								,	GRP.DESCRIPTION 							AS COLOR
								,	SUB.CODEID									AS SUBCODE
								,	SUB.SUBNAME								AS SUBNAME
							FROM	
							(
								SELECT 	C.LOOKUP_CODE   AS CODEID
									,	C.DESCRIPTION
									,	D.DICTIONARYNAME						AS GROUPNAME
								FROM 	CMD_LOOKUP_VALUES									C
								LEFT OUTER JOIN		CMD_DICTIONARY	D	ON	C.DICTIONARYID = D.DICTIONARYID						           	   			   		    
								WHERE	C.LOOKUP_TYPE = 'DefectMapDefectGroup'
								AND		C.ENABLED_FLAG = 'Y'
								AND		D.LANGUAGETYPE = #{LANGUAGETYPE} 
							) 					GRP
							LEFT OUTER JOIN		
							(
								SELECT	C.LOOKUP_CODE AS CODEID
									,	D.DICTIONARYNAME						AS SUBNAME
									,	C.PARENTCODEID
								FROM	CMD_LOOKUP_VALUES									C
								LEFT OUTER JOIN 	CMD_DICTIONARY	D	ON 	C.DICTIONARYID = D.DICTIONARYID
								WHERE	C.LOOKUP_TYPE = 'DefectMapDefectGroupSub'
								AND		C.ENABLED_FLAG = 'Y'
								AND		D.LANGUAGETYPE = #{LANGUAGETYPE} 
							) 					
							SUB		ON GRP.CODEID = SUB.PARENTCODEID              
						) AOI		ON A.DEFECTCODE = AOI.SUBCODE
								  AND A.SEGMENTTYPE = AOI.SEGMENTTYPE						
        LEFT JOIN CMD_DICTIONARY         	DIC	ON	DIC.DICTIONARYID = C.PROCESSSEGMENTNAME
                                                AND DIC.LANGUAGETYPE = #{LANGUAGETYPE}      
                                                
        
        ---------------------------------[4]
		-- (21.07.12) 추가
        INNER JOIN BAS_PRODUCTDEFINITION E      ON 	A.PRODUCTDEFID = E.PRODUCTDEFID
											   AND  A.PRODUCTDEFVERSION  = E.PRODUCTDEFVERSION
		---------------------------------    
		
		-----------------------------------(21.08.10) 인계 시간 조건 추가        
		LEFT JOIN T_SENDTIME TT 
				ON TT.LOTID             			= A.LOTID
			   AND TT.PROCESSSEGMENTID  	= A.PROCESSSEGMENTID
		-----------------------------                                  
		
		
		WHERE 1 = 1
		  AND A.SEGMENTTYPE = 'AOIInspection'
		  AND A.ENTERPRISEID = #{P_ENTERPRISEID}
		  AND A.PLANTID = #{P_PLANTID}		  
		<if test="P_PERIOD_PERIODFR != null and P_PERIOD_PERIODFR !='' and P_PERIOD_PERIODTO != null and P_PERIOD_PERIODTO !=''">
		  -- (21.08.10) 인계 시간 조건 추가 A.CREATEDTIME --> TT.SENDTIME
		  AND TT.SENDTIME <![CDATA[>=]]> TO_TIMESTAMP(SUBSTR(#{P_PERIOD_PERIODFR},1,14), 'YYYYMMDDHH24MISS')
		  AND TT.SENDTIME <![CDATA[<]]>  TO_TIMESTAMP(TO_CHAR(TO_DATE(SUBSTR(#{P_PERIOD_PERIODTO},1,8), 'YYYYMMDD'), 'YYYY-MM-DD') || ' ' || SUBSTR(#{P_PERIOD_PERIODTO}, 9, 6), 'YYYY-MM-DD HH24:MI:SS') 
		</if>
		<if test="LOTID_LIST.length != 0">
                AND		A.LOTID IN
	           <foreach collection="LOTID_LIST" item="item" index="index" separator="," open="(" close=")">
	                    #{item}
	           </foreach>				
		</if>	
		<if test="PROCESSSEGMENTID_LIST.length != 0">
                AND		A.PROCESSSEGMENTID IN
	           <foreach collection="PROCESSSEGMENTID_LIST" item="item" index="index" separator="," open="(" close=")">
	                    #{item}
	           </foreach>				
		</if>			
		<if test="PRODUCTDEFIDVER_LIST.length != 0">
                AND		A.PRODUCTDEFID || A.PRODUCTDEFVERSION IN
	           <foreach collection="PRODUCTDEFIDVER_LIST" item="item" index="index" separator="," open="(" close=")">
	                    #{item}
	           </foreach>				
		</if>
		<if test="P_AOIPROCESS != null and P_AOIPROCESS !=''">
			-- AOI 공정
			AND	 EXISTS (SELECT 1 FROM ufn_selectStringToSplit(#{P_AOIPROCESS},',') WHERE value = A.PROCESSSEGMENTID) 
		</if>
		
		<if test="P_PRODUCTIONTYPE != null and P_PRODUCTIONTYPE !='' and !(P_PRODUCTIONTYPE eq '*'.toString()) ">
			-- (21.07.12) 생산구분 추가[4]
			AND 	E.PRODUCTIONTYPE 			= #{P_PRODUCTIONTYPE}
		</if>
		
		
        GROUP BY 
		 			A.SEGMENTTYPE    
                ,   A.PROCESSSEGMENTID
                ,   A.LOTID
        ) A
        GROUP BY 
		 			A.SEGMENTTYPE    
                ,   A.PROCESSSEGMENTID 
	    ) B
		WHERE A.PROCESSSEGMENTID = B.PROCESSSEGMENTID
			) A
            GROUP BY 
					A.PROCESSSEGMENTID
				,   A.PROCESSSEGMENTNAME	            
				,	A.GROUPCODE					
				,	A.GROUPNAME															
		   )	  G -- GROUPCODE
         , (
				SELECT	
						A.PROCESSSEGMENTID
					,   A.PROCESSSEGMENTNAME				
					,	A.GROUPCODE						AS GROUPCODE
					,	A.GROUPNAME						AS GROUPNAME
					,	A.SUBCODE							AS SUBCODE	
					,	A.SUBNAME							AS SUBNAME				
				   ,    SUM(NVL(A.DEFECTCOUNT,0)) AS BEFOREDEFECTCNT
					,   ROUND(DECODE(MAX(NVL(A.INSPECTIONQTY,0)), 0, 0, SUM(NVL(A.DEFECTCOUNT,0))/ MAX(NVL(A.INSPECTIONQTY,0))) * 100, 2)  AS BEFOREDEFECTRATE      
               FROM
               (
			    SELECT
					A.PRODUCTDEFID
				,	A.PRODUCTDEFVERSION
				,	A.LOTID
				,	A.PROCESSSEGMENTID
				,	A.PROCESSSEGMENTNAME 
                ,	B.INSPECTIONQTY                
               ,    A.REPAIRTARGETQTY
               ,    A.REPAIRRESULTQTY 
                ,  A.GROUPCODE 
                ,  A.GROUPNAME
                ,	A.SUBCODE	 
                ,	A.SUBNAME
                ,  A.COLOR
                , A.DEFECTCOUNT
				FROM
			   (
               SELECT                
					A.PRODUCTDEFID
				,	A.PRODUCTDEFVERSION
				,	A.LOTID
				,	A.PROCESSSEGMENTID
				,	DIC.DICTIONARYNAME 		AS PROCESSSEGMENTNAME 
                ,	A.INSPECTIONQTY                
               ,    A.REPAIRTARGETQTY
               ,    A.REPAIRRESULTQTY 
                 ----------------------------------------------------------------(21.06.17)
                -- 블량 그룹 
                ,  (
                        CASE WHEN AOI.GROUPCODE = '005'  
                            THEN T_AFT_ANALYSIS.GROUPCODE
                            ELSE COALESCE(AOI.GROUPCODE, '999')
                            END
                    ) AS GROUPCODE
                -- 블량 그룹명 
                ,  (
                        CASE WHEN AOI.GROUPCODE = '005'  
                            THEN T_AFT_ANALYSIS.GROUPNAME
                            ELSE COALESCE(AOI.GROUPNAME, 'NONE')
                            END
                    ) AS GROUPNAME
                -- 불량 코드   
                ,	COALESCE(
                            CASE A.SEGMENTTYPE
                                WHEN 'AOIInspection' 
                                THEN (
                                       CASE WHEN AOI.GROUPCODE = '005'  
                                            THEN T_AFT_ANALYSIS.SUBCODE
                                            ELSE AOI.SUBCODE
                                            END 
                                    )
                                ELSE AOI.SUBCODE
                            END, '9999') 														AS	SUBCODE	 
                -- 불량 코드명
                ,	COALESCE(
                            CASE A.SEGMENTTYPE
                                WHEN 'AOIInspection' 
                                THEN (
                                       CASE WHEN AOI.GROUPCODE = '005'  
                                            THEN T_AFT_ANALYSIS.SUBNAME
                                            ELSE  AOI.SUBNAME
                                            END 
                                    )
                                ELSE AOI.SUBNAME
                            END, 'NONE')														AS	SUBNAME
                -- 불량 색상
                ,  COALESCE(
                            CASE A.SEGMENTTYPE
                                WHEN 'AOIInspection' 
                                THEN (
                                       CASE WHEN AOI.GROUPCODE = '005'  
                                            THEN T_AFT_ANALYSIS.COLOR
                                            ELSE AOI.COLOR
                                            END 
                                    )
                                ELSE AOI.COLOR
                            END, '#000000')														AS	COLOR
                    
                -- 불량 수량 
                , A.DEFECTCOUNT
               -----------------------------------------------------------------------------------------    
		FROM PCM_QCAOIBBTWORKCOMPLETE	A
			INNER JOIN LOTLIST 					L	ON	A.LOTID = L.LOTID
													AND	A.PRODUCTDEFID = L.PRODUCTDEFID
													AND	A.PRODUCTDEFVERSION = L.PRODUCTDEFVERSION				
            -- (21.06.17) 완료된 상태 체크   -> (21.06.18) 여러건 존재함 하나만 나오도록 수정
            INNER JOIN (SELECT RESOURCEID
                            ,  INSPECTIONDEFID  
                            , PROCESSSEGMENTID, PROCESSSEGMENTVERSION
                         FROM  QAM_INSPECTIONRESULT   
                         GROUP BY  RESOURCEID, INSPECTIONDEFID    
                                    , PROCESSSEGMENTID, PROCESSSEGMENTVERSION
                         ) Q_INSP
            ON Q_INSP.RESOURCEID                 		=  A.LOTID
            AND Q_INSP.INSPECTIONDEFID 					= 	'AOIInspection'
            AND Q_INSP.PROCESSSEGMENTID					= A.PROCESSSEGMENTID
            AND Q_INSP.PROCESSSEGMENTVERSION			= A.PROCESSSEGMENTVERSION
            -----------------------------------------------------------------   	
            LEFT OUTER JOIN (
					SELECT	GRP.CODEID								AS	GROUPCODE
						,	GRP.GROUPNAME							AS	GROUPNAME
						,	GRP.DESCRIPTION 							AS	COLOR
						,	SUB.CODEID									AS	SUBCODE
						,	SUB.SUBNAME								AS	SUBNAME
						,	'AOIInspection'								AS	SEGMENTTYPE
						,   '005'                                       	AS  CHK_G_CODE
                                    ,   (
                                        CASE WHEN SUB.CODEID = '1001'
                                             THEN '5001'
                                             ELSE '5002'
                                             END
                                    )   													AS CHK_S_CODE
					FROM	
					(
						SELECT 	C.LOOKUP_CODE   AS CODEID
							,	C.DESCRIPTION
							,	D.DICTIONARYNAME						AS	GROUPNAME
						FROM 	CMD_LOOKUP_VALUES									C
						LEFT OUTER JOIN		CMD_DICTIONARY	D			ON	C.DICTIONARYID = D.DICTIONARYID						           	   			   		    
						WHERE	C.LOOKUP_TYPE = 'DefectMapDefectGroup'
						AND		C.ENABLED_FLAG = 'Y'
						AND		D.LANGUAGETYPE = #{LANGUAGETYPE}        -- 다국어 코드
					) 					GRP
					LEFT OUTER JOIN		
					(
						SELECT	C.LOOKUP_CODE   AS CODEID
							,	D.DICTIONARYNAME						AS	SUBNAME
							,	C.PARENTCODEID
						FROM	CMD_LOOKUP_VALUES									C
						LEFT OUTER JOIN 	CMD_DICTIONARY	D			ON 	C.DICTIONARYID = D.DICTIONARYID
						WHERE	C.LOOKUP_TYPE = 'DefectMapDefectGroupSub'
						AND		C.ENABLED_FLAG = 'Y'
						AND		D.LANGUAGETYPE = #{LANGUAGETYPE}        -- 다국어 코드
					) 					SUB								ON	GRP.CODEID = SUB.PARENTCODEID
					WHERE 1 = 1
                              AND GRP.CODEID IN ('001','002')
                              AND SUB.CODEID IN ('1001','2001')
				)   T_AFT_ANALYSIS
            ON A.SEGMENTTYPE = T_AFT_ANALYSIS.SEGMENTTYPE 
            AND A.DEFECTCODE = T_AFT_ANALYSIS.CHK_S_CODE
-----------------------------------------------------------------     		
		INNER JOIN	BAS_PROCESSSEGMENTEXT	C	ON A.PROCESSSEGMENTID = C.PROCESSSEGMENTID 
										  AND A.ENTERPRISEID = C.ENTERPRISEID                                   
		LEFT OUTER JOIN (	
						  SELECT	
						  		    'AOIInspection'                             AS SEGMENTTYPE
		                        ,   GRP.CODEID									AS GROUPCODE
								,	GRP.GROUPNAME							AS GROUPNAME
								,	GRP.DESCRIPTION 							AS COLOR
								,	SUB.CODEID									AS SUBCODE
								,	SUB.SUBNAME								AS SUBNAME
							FROM	
							(
								SELECT 	C.LOOKUP_CODE   AS CODEID
									,	C.DESCRIPTION
									,	D.DICTIONARYNAME						AS GROUPNAME
								FROM 	CMD_LOOKUP_VALUES									C
								LEFT OUTER JOIN		CMD_DICTIONARY	D	ON	C.DICTIONARYID = D.DICTIONARYID						           	   			   		    
								WHERE	C.LOOKUP_TYPE = 'DefectMapDefectGroup'
								AND		C.ENABLED_FLAG = 'Y'
								AND		D.LANGUAGETYPE = #{LANGUAGETYPE} 
							) 					GRP
							LEFT OUTER JOIN		
							(
								SELECT	C.LOOKUP_CODE AS CODEID
									,	D.DICTIONARYNAME						AS SUBNAME
									,	C.PARENTCODEID
								FROM	CMD_LOOKUP_VALUES									C
								LEFT OUTER JOIN 	CMD_DICTIONARY	D	ON 	C.DICTIONARYID = D.DICTIONARYID
								WHERE	C.LOOKUP_TYPE = 'DefectMapDefectGroupSub'
								AND		C.ENABLED_FLAG = 'Y'
								AND		D.LANGUAGETYPE = #{LANGUAGETYPE} 
							) 					
							SUB		ON GRP.CODEID = SUB.PARENTCODEID              
						) AOI		ON A.DEFECTCODE = AOI.SUBCODE
								  AND A.SEGMENTTYPE = AOI.SEGMENTTYPE						
        LEFT JOIN CMD_DICTIONARY         	DIC	ON	DIC.DICTIONARYID = C.PROCESSSEGMENTNAME
                                                AND DIC.LANGUAGETYPE = #{LANGUAGETYPE}    
                                                
                                                
		---------------------------------[5]
		-- (21.07.12) 추가
        INNER JOIN BAS_PRODUCTDEFINITION E      ON 	A.PRODUCTDEFID = E.PRODUCTDEFID
											   AND  A.PRODUCTDEFVERSION  = E.PRODUCTDEFVERSION
		---------------------------------
		-----------------------------------(21.08.10) 인계 시간 조건 추가        
		LEFT JOIN T_SENDTIME TT 
				ON TT.LOTID             			= A.LOTID
			   AND TT.PROCESSSEGMENTID  	= A.PROCESSSEGMENTID
		-----------------------------
		
		WHERE 1 = 1
		  AND A.SEGMENTTYPE = 'AOIInspection'
		  AND A.ENTERPRISEID = #{P_ENTERPRISEID}
		  AND A.PLANTID = #{P_PLANTID}		  
		<if test="P_PERIOD_PERIODFR != null and P_PERIOD_PERIODFR !='' and P_PERIOD_PERIODTO != null and P_PERIOD_PERIODTO !=''">
		  -- (21.08.10) 인계 시간 조건 추가  A.CREATEDTIME --> TT.SENDTIME
		  AND TT.SENDTIME <![CDATA[>=]]> TO_TIMESTAMP(SUBSTR(#{P_PERIOD_PERIODFR},1,14), 'YYYYMMDDHH24MISS')
		  AND TT.SENDTIME <![CDATA[<]]>  TO_TIMESTAMP(TO_CHAR(TO_DATE(SUBSTR(#{P_PERIOD_PERIODTO},1,8), 'YYYYMMDD'), 'YYYY-MM-DD') || ' ' || SUBSTR(#{P_PERIOD_PERIODTO}, 9, 6), 'YYYY-MM-DD HH24:MI:SS') 
		</if>
		<if test="LOTID_LIST.length != 0">
                AND		A.LOTID IN
	           <foreach collection="LOTID_LIST" item="item" index="index" separator="," open="(" close=")">
	                    #{item}
	           </foreach>				
		</if>	
		<if test="PROCESSSEGMENTID_LIST.length != 0">
                AND		A.PROCESSSEGMENTID IN
	           <foreach collection="PROCESSSEGMENTID_LIST" item="item" index="index" separator="," open="(" close=")">
	                    #{item}
	           </foreach>				
		</if>			
		<if test="PRODUCTDEFIDVER_LIST.length != 0">
                AND		A.PRODUCTDEFID || A.PRODUCTDEFVERSION IN
	           <foreach collection="PRODUCTDEFIDVER_LIST" item="item" index="index" separator="," open="(" close=")">
	                    #{item}
	           </foreach>				
		</if>
		<if test="P_AOIPROCESS != null and P_AOIPROCESS !=''">
			-- AOI 공정
			AND	 EXISTS (SELECT 1 FROM ufn_selectStringToSplit(#{P_AOIPROCESS},',') WHERE value = A.PROCESSSEGMENTID) 
		</if>
		
		<if test="P_PRODUCTIONTYPE != null and P_PRODUCTIONTYPE !='' and !(P_PRODUCTIONTYPE eq '*'.toString()) ">
			-- (21.07.12) 생산구분 추가[5]
			AND 	E.PRODUCTIONTYPE 			= #{P_PRODUCTIONTYPE}
		</if>
		
		) A
		, 
           
		   (
		   SELECT
					A.SEGMENTTYPE    
                ,   A.PROCESSSEGMENTID
                ,   SUM(A.INSPECTIONQTY) AS INSPECTIONQTY
            FROM
           (
		   SELECT
					A.SEGMENTTYPE    
                ,   A.PROCESSSEGMENTID
                ,   A.LOTID
                ,	MAX(A.INSPECTIONQTY) AS INSPECTIONQTY	   
		FROM PCM_QCAOIBBTWORKCOMPLETE	A
			INNER JOIN LOTLIST 					L	ON	A.LOTID = L.LOTID
													AND	A.PRODUCTDEFID = L.PRODUCTDEFID
													AND	A.PRODUCTDEFVERSION = L.PRODUCTDEFVERSION				
            -- (21.06.17) 완료된 상태 체크   -> (21.06.18) 여러건 존재함 하나만 나오도록 수정
            INNER JOIN (SELECT RESOURCEID
                            ,  INSPECTIONDEFID  
                            , PROCESSSEGMENTID, PROCESSSEGMENTVERSION
                         FROM  QAM_INSPECTIONRESULT   
                         GROUP BY  RESOURCEID, INSPECTIONDEFID    
                                    , PROCESSSEGMENTID, PROCESSSEGMENTVERSION
                         ) Q_INSP
            ON Q_INSP.RESOURCEID                 		=  A.LOTID
            AND Q_INSP.INSPECTIONDEFID 					= 	'AOIInspection'
            AND Q_INSP.PROCESSSEGMENTID					= A.PROCESSSEGMENTID
            AND Q_INSP.PROCESSSEGMENTVERSION			= A.PROCESSSEGMENTVERSION
            -----------------------------------------------------------------   	
            LEFT OUTER JOIN (
					SELECT	GRP.CODEID								AS	GROUPCODE
						,	GRP.GROUPNAME							AS	GROUPNAME
						,	GRP.DESCRIPTION 							AS	COLOR
						,	SUB.CODEID									AS	SUBCODE
						,	SUB.SUBNAME								AS	SUBNAME
						,	'AOIInspection'								AS	SEGMENTTYPE
						,   '005'                                       	AS  CHK_G_CODE
                                    ,   (
                                        CASE WHEN SUB.CODEID = '1001'
                                             THEN '5001'
                                             ELSE '5002'
                                             END
                                    )   													AS CHK_S_CODE
					FROM	
					(
						SELECT 	C.LOOKUP_CODE   AS CODEID
							,	C.DESCRIPTION
							,	D.DICTIONARYNAME						AS	GROUPNAME
						FROM 	CMD_LOOKUP_VALUES									C
						LEFT OUTER JOIN		CMD_DICTIONARY	D			ON	C.DICTIONARYID = D.DICTIONARYID						           	   			   		    
						WHERE	C.LOOKUP_TYPE = 'DefectMapDefectGroup'
						AND		C.ENABLED_FLAG = 'Y'
						AND		D.LANGUAGETYPE = #{LANGUAGETYPE}        -- 다국어 코드
					) 					GRP
					LEFT OUTER JOIN		
					(
						SELECT	C.LOOKUP_CODE   AS CODEID
							,	D.DICTIONARYNAME						AS	SUBNAME
							,	C.PARENTCODEID
						FROM	CMD_LOOKUP_VALUES									C
						LEFT OUTER JOIN 	CMD_DICTIONARY	D			ON 	C.DICTIONARYID = D.DICTIONARYID
						WHERE	C.LOOKUP_TYPE = 'DefectMapDefectGroupSub'
						AND		C.ENABLED_FLAG = 'Y'
						AND		D.LANGUAGETYPE = #{LANGUAGETYPE}        -- 다국어 코드
					) 					SUB								ON	GRP.CODEID = SUB.PARENTCODEID
					WHERE 1 = 1
                              AND GRP.CODEID IN ('001','002')
                              AND SUB.CODEID IN ('1001','2001')
				)   T_AFT_ANALYSIS
            ON A.SEGMENTTYPE = T_AFT_ANALYSIS.SEGMENTTYPE 
            AND A.DEFECTCODE = T_AFT_ANALYSIS.CHK_S_CODE
-----------------------------------------------------------------     		
		INNER JOIN	BAS_PROCESSSEGMENTEXT	C	ON A.PROCESSSEGMENTID = C.PROCESSSEGMENTID 
										  AND A.ENTERPRISEID = C.ENTERPRISEID                                   
		LEFT OUTER JOIN (	
						  SELECT	
						  		    'AOIInspection'                             AS SEGMENTTYPE
		                        ,   GRP.CODEID									AS GROUPCODE
								,	GRP.GROUPNAME							AS GROUPNAME
								,	GRP.DESCRIPTION 							AS COLOR
								,	SUB.CODEID									AS SUBCODE
								,	SUB.SUBNAME								AS SUBNAME
							FROM	
							(
								SELECT 	C.LOOKUP_CODE   AS CODEID
									,	C.DESCRIPTION
									,	D.DICTIONARYNAME						AS GROUPNAME
								FROM 	CMD_LOOKUP_VALUES									C
								LEFT OUTER JOIN		CMD_DICTIONARY	D	ON	C.DICTIONARYID = D.DICTIONARYID						           	   			   		    
								WHERE	C.LOOKUP_TYPE = 'DefectMapDefectGroup'
								AND		C.ENABLED_FLAG = 'Y'
								AND		D.LANGUAGETYPE = #{LANGUAGETYPE} 
							) 					GRP
							LEFT OUTER JOIN		
							(
								SELECT	C.LOOKUP_CODE AS CODEID
									,	D.DICTIONARYNAME						AS SUBNAME
									,	C.PARENTCODEID
								FROM	CMD_LOOKUP_VALUES									C
								LEFT OUTER JOIN 	CMD_DICTIONARY	D	ON 	C.DICTIONARYID = D.DICTIONARYID
								WHERE	C.LOOKUP_TYPE = 'DefectMapDefectGroupSub'
								AND		C.ENABLED_FLAG = 'Y'
								AND		D.LANGUAGETYPE = #{LANGUAGETYPE} 
							) 					
							SUB		ON GRP.CODEID = SUB.PARENTCODEID              
						) AOI		ON A.DEFECTCODE = AOI.SUBCODE
								  AND A.SEGMENTTYPE = AOI.SEGMENTTYPE						
        LEFT JOIN CMD_DICTIONARY         	DIC	ON	DIC.DICTIONARYID = C.PROCESSSEGMENTNAME
                                                AND DIC.LANGUAGETYPE = #{LANGUAGETYPE}  
                                                
        
        ---------------------------------[6]
		-- (21.07.12) 추가
        INNER JOIN BAS_PRODUCTDEFINITION E      ON 	A.PRODUCTDEFID = E.PRODUCTDEFID
											   AND  A.PRODUCTDEFVERSION  = E.PRODUCTDEFVERSION
		---------------------------------  
		-----------------------------------(21.08.10) 인계 시간 조건 추가        
		LEFT JOIN T_SENDTIME TT 
				ON TT.LOTID             			= A.LOTID
			   AND TT.PROCESSSEGMENTID  	= A.PROCESSSEGMENTID
		-----------------------------                                      
		
		WHERE 1 = 1
		  AND A.SEGMENTTYPE = 'AOIInspection'
		  AND A.ENTERPRISEID = #{P_ENTERPRISEID}
		  AND A.PLANTID = #{P_PLANTID}		  
		<if test="P_PERIOD_PERIODFR != null and P_PERIOD_PERIODFR !='' and P_PERIOD_PERIODTO != null and P_PERIOD_PERIODTO !=''">
		  -- (21.08.10) 인계 시간 조건 추가  A.CREATEDTIME --> TT.SENDTIME
		  AND TT.SENDTIME <![CDATA[>=]]> TO_TIMESTAMP(SUBSTR(#{P_PERIOD_PERIODFR},1,14), 'YYYYMMDDHH24MISS')
		  AND TT.SENDTIME <![CDATA[<]]>  TO_TIMESTAMP(TO_CHAR(TO_DATE(SUBSTR(#{P_PERIOD_PERIODTO},1,8), 'YYYYMMDD'), 'YYYY-MM-DD') || ' ' || SUBSTR(#{P_PERIOD_PERIODTO}, 9, 6), 'YYYY-MM-DD HH24:MI:SS') 
		</if>
		<if test="LOTID_LIST.length != 0">
                AND		A.LOTID IN
	           <foreach collection="LOTID_LIST" item="item" index="index" separator="," open="(" close=")">
	                    #{item}
	           </foreach>				
		</if>	
		<if test="PROCESSSEGMENTID_LIST.length != 0">
                AND		A.PROCESSSEGMENTID IN
	           <foreach collection="PROCESSSEGMENTID_LIST" item="item" index="index" separator="," open="(" close=")">
	                    #{item}
	           </foreach>				
		</if>			
		<if test="PRODUCTDEFIDVER_LIST.length != 0">
                AND		A.PRODUCTDEFID || A.PRODUCTDEFVERSION IN
	           <foreach collection="PRODUCTDEFIDVER_LIST" item="item" index="index" separator="," open="(" close=")">
	                    #{item}
	           </foreach>				
		</if>
		<if test="P_AOIPROCESS != null and P_AOIPROCESS !=''">
			-- AOI 공정
			AND	 EXISTS (SELECT 1 FROM ufn_selectStringToSplit(#{P_AOIPROCESS},',') WHERE value = A.PROCESSSEGMENTID) 
		</if>
		
		<if test="P_PRODUCTIONTYPE != null and P_PRODUCTIONTYPE !='' and !(P_PRODUCTIONTYPE eq '*'.toString()) ">
			-- (21.07.12) 생산구분 추가[6]
			AND 	E.PRODUCTIONTYPE 			= #{P_PRODUCTIONTYPE}
		</if>
		
        GROUP BY 
		 			A.SEGMENTTYPE    
                ,   A.PROCESSSEGMENTID
                ,   A.LOTID
        ) A
        GROUP BY 
		 			A.SEGMENTTYPE    
                ,   A.PROCESSSEGMENTID 
	    ) B
		WHERE A.PROCESSSEGMENTID = B.PROCESSSEGMENTID
			) A
            GROUP BY 
					A.PROCESSSEGMENTID
				,   A.PROCESSSEGMENTNAME		         
				,	A.GROUPCODE					
				,	A.GROUPNAME		
				,	A.SUBCODE 									
				,	A.SUBNAME											
		   )	  S -- SUBCODE		
		 WHERE 1 = 1
		    AND T.PROCESSSEGMENTID = G.PROCESSSEGMENTID
		    AND G.PROCESSSEGMENTID = S.PROCESSSEGMENTID
		    AND G.GROUPCODE           = S.GROUPCODE
		    AND G.BEFOREDEFECTRATE <![CDATA[>]]> 0
		<if test="P_PROCESSSEGMENTID != null and P_PROCESSSEGMENTID !=''">
		    AND T.PROCESSSEGMENTID = #{P_PROCESSSEGMENTID}
		</if>			    
		ORDER BY 
			   G.PROCESSSEGMENTID
			  , G.PROCESSSEGMENTNAME				
			  , G.GROUPCODE
			  , S.SUBCODE				
    </select>
    
 <!-- AOI 분석 전/후 비교 조회 -->
    <select id="getDefectRateByRepairNullAfterDetail" parameterType="map" resultType="hashmap">
			-- getDefectRateByRepairNullAfterDetail  품목코드 미입력시
			WITH	LOTLIST	AS 
			(
					SELECT	C.LOTSTARTDATE
						,	C.LOTID
						,	C.PRODUCTDEFID
						,	C.PRODUCTDEFVERSION
						,	C.PROCESSSEGMENTID
					FROM	PCM_LOT C
					WHERE	
                            --EXISTS
                        	C.LOTID IN		-- (21.06.17) 속도개선 lot 처럼 변경함 
							(	SELECT	A.LOTID		--1 (21.06.17) 속도개선 lot 처럼 변경함
								FROM	PCM_LOTWORKRESULT				A
										INNER JOIN	BAS_PROCESSSEGMENT	B	ON A.PROCESSSEGMENTID = B.PROCESSSEGMENTID 
								WHERE	1=1
					            -- (21.06.17) 속도개선 lot 처럼 변경함
				            	--AND		C.LOTID = A.LOTID
								AND		(
						          			-- (21.08.10) WORKENDTIME -> SENDTIME 변경
						          			(		B.PROCESSSEGMENTCLASSID = '7012'	
						          				AND	A.SENDTIME			-- (21.06.03  endtime로 다 변경)		A.WORKSTARTTIME 
						          				BETWEEN	TO_TIMESTAMP(#{P_PERIOD_PERIODFR}, 'YYYY-MM-DD HH24:MI:SS')	
									                					AND	TO_TIMESTAMP(#{P_PERIOD_PERIODTO}, 'YYYY-MM-DD HH24:MI:SS') 
					  						)
										)
							)
					<if test="P_LOTID != null and P_LOTID !='' and !(P_LOTID eq '*'.toString()) ">
						AND		C.LOTID = #{P_LOTID}
					</if>
					<if test="P_PRODUCTDEFID != null and P_PRODUCTDEFID !=''"> 
					  AND		C.PRODUCTDEFID = #{P_PRODUCTDEFID}
					</if>					
					<if test="P_PRODUCTDEFVERSION != null and P_PRODUCTDEFVERSION !='' and !(P_PRODUCTDEFVERSION eq '*'.toString()) ">
						AND		EXISTS
						(
							SELECT	1
							FROM	(SELECT DATA AS VALUE 
									  FROM TABLE(CAST(FN_TO_ROWS(#{P_PRODUCTDEFVERSION}) AS TP_SIMPLE_TABLE)) 
									) LMP
							WHERE	C.PRODUCTDEFVERSION = LMP.VALUE
						)
					</if>	
			)		
			
			-----------------------------(21.08.10) 인계 시간 조회
			, T_SENDTIME AS (
					SELECT	A.LOTID		
					, 			A.PROCESSSEGMENTID
					, 			MAX(A.SENDTIME) 		AS 	SENDTIME		       -- 인계 시간
					, 			B.PROCESSSEGMENTCLASSID
				FROM			PCM_LOTWORKRESULT				A
				INNER JOIN	BAS_PROCESSSEGMENT				B	
				ON  			A.PROCESSSEGMENTID = B.PROCESSSEGMENTID 
				AND 			B.PROCESSSEGMENTCLASSID IN ('7012','7014','7022')
				WHERE		1=1
				AND 			LOTID IN (
					SELECT LOTID
					  FROM LOTLIST
				)
				GROUP BY    A.LOTID		
					,       A.PROCESSSEGMENTID
					,       B.PROCESSSEGMENTCLASSID
			)
		-----------------------------
				
		SELECT
				  '0'    AS  CHK	
				, G.GROUPCODE
				, G.GROUPNAME
				, G.AFTERDEFECTCNT			AS GROUPCNT
				, G.AFTERDEFECTRATE		AS GROUPRATE				
				, S.SUBCODE
				, S.SUBNAME
				, S.AFTERDEFECTCNT		  AS SUBCNT
				, S.AFTERDEFECTRATE	  AS SUBRATE		        		
		FROM
		(
		SELECT	
				A.GROUPCODE						AS GROUPCODE
			,	A.GROUPNAME						AS GROUPNAME			
			,   SUM(NVL(A.DEFECTCOUNT,0)) - SUM(NVL(A.REPAIRRESULTQTY, 0)) AS AFTERDEFECTCNT
			,   ROUND(DECODE(MAX(NVL(A.INSPECTIONQTY,0)), 0, 0,  (SUM(NVL(A.DEFECTCOUNT,0)) - SUM(NVL(A.REPAIRRESULTQTY, 0)))/ MAX(NVL(A.INSPECTIONQTY,0))) * 100, 2)  AS AFTERDEFECTRATE      

               FROM
               (
				
			   SELECT
					A.PRODUCTDEFID
				,	A.PRODUCTDEFVERSION
				,	A.LOTID
				,	A.PROCESSSEGMENTID 
                ,	B.INSPECTIONQTY                
                ,    A.REPAIRTARGETQTY
                ,    A.REPAIRRESULTQTY 
                ,  A.GROUPCODE
                ,  A.GROUPNAME  
                ,	A.SUBCODE	 
                ,	A.SUBNAME
                ,  A.COLOR
                , A.DEFECTCOUNT
			   FROM
			   (
               SELECT            
					A.PRODUCTDEFID
				,	A.PRODUCTDEFVERSION
				,	A.LOTID
				,	A.PROCESSSEGMENTID 
                ,	A.INSPECTIONQTY                
               ,    A.REPAIRTARGETQTY
               ,    A.REPAIRRESULTQTY 
                ----------------------------------------------------------------(21.06.17)
                -- 블량 그룹 
                ,  (
                        CASE WHEN AOI.GROUPCODE = '005'  
                            THEN T_AFT_ANALYSIS.GROUPCODE
                            ELSE COALESCE(AOI.GROUPCODE, '999')
                            END
                    ) AS GROUPCODE
                -- 블량 그룹명 
                ,  (
                        CASE WHEN AOI.GROUPCODE = '005'  
                            THEN T_AFT_ANALYSIS.GROUPNAME
                            ELSE COALESCE(AOI.GROUPNAME, 'NONE')
                            END
                    ) AS GROUPNAME
                -- 불량 코드   
                ,	COALESCE(
                            CASE A.SEGMENTTYPE
                                WHEN 'AOIInspection' 
                                THEN (
                                       CASE WHEN AOI.GROUPCODE = '005'  
                                            THEN T_AFT_ANALYSIS.SUBCODE
                                            ELSE AOI.SUBCODE
                                            END 
                                    )
                                ELSE AOI.SUBCODE
                            END, '9999') 														AS	SUBCODE	 
                -- 불량 코드명
                ,	COALESCE(
                            CASE A.SEGMENTTYPE
                                WHEN 'AOIInspection' 
                                THEN (
                                       CASE WHEN AOI.GROUPCODE = '005'  
                                            THEN T_AFT_ANALYSIS.SUBNAME
                                            ELSE  AOI.SUBNAME
                                            END 
                                    )
                                ELSE AOI.SUBNAME
                            END, 'NONE')														AS	SUBNAME
                -- 불량 색상
                ,  COALESCE(
                            CASE A.SEGMENTTYPE
                                WHEN 'AOIInspection' 
                                THEN (
                                       CASE WHEN AOI.GROUPCODE = '005'  
                                            THEN T_AFT_ANALYSIS.COLOR
                                            ELSE AOI.COLOR
                                            END 
                                    )
                                ELSE AOI.COLOR
                            END, '#000000')														AS	COLOR
                    
                -- 불량 수량 
                , A.DEFECTCOUNT
               -----------------------------------------------------------------------------------------     
		FROM PCM_QCAOIBBTWORKCOMPLETE	A    
			INNER JOIN LOTLIST 					L	ON	A.LOTID = L.LOTID
													AND	A.PRODUCTDEFID = L.PRODUCTDEFID
													AND	A.PRODUCTDEFVERSION = L.PRODUCTDEFVERSION				
            -- (21.06.17) 완료된 상태 체크   -> (21.06.18) 여러건 존재함 하나만 나오도록 수정
            INNER JOIN (SELECT RESOURCEID
                            ,  INSPECTIONDEFID  
                            , PROCESSSEGMENTID, PROCESSSEGMENTVERSION
                         FROM  QAM_INSPECTIONRESULT   
                         GROUP BY  RESOURCEID, INSPECTIONDEFID    
                                    , PROCESSSEGMENTID, PROCESSSEGMENTVERSION
                         ) Q_INSP
            ON Q_INSP.RESOURCEID                 		=  A.LOTID
            AND Q_INSP.INSPECTIONDEFID 					= 	'AOIInspection'
            AND Q_INSP.PROCESSSEGMENTID					= A.PROCESSSEGMENTID
            AND Q_INSP.PROCESSSEGMENTVERSION			= A.PROCESSSEGMENTVERSION
            -----------------------------------------------------------------   	
            LEFT OUTER JOIN (
					SELECT	GRP.CODEID								AS	GROUPCODE
						,	GRP.GROUPNAME							AS	GROUPNAME
						,	GRP.DESCRIPTION 							AS	COLOR
						,	SUB.CODEID									AS	SUBCODE
						,	SUB.SUBNAME								AS	SUBNAME
						,	'AOIInspection'								AS	SEGMENTTYPE
						,   '005'                                       	AS  CHK_G_CODE
                                    ,   (
                                        CASE WHEN SUB.CODEID = '1001'
                                             THEN '5001'
                                             ELSE '5002'
                                             END
                                    )   													AS CHK_S_CODE
					FROM	
					(
						SELECT 	C.LOOKUP_CODE   AS CODEID
							,	C.DESCRIPTION
							,	D.DICTIONARYNAME						AS	GROUPNAME
						FROM 	CMD_LOOKUP_VALUES									C
						LEFT OUTER JOIN		CMD_DICTIONARY	D			ON	C.DICTIONARYID = D.DICTIONARYID						           	   			   		    
						WHERE	C.LOOKUP_TYPE = 'DefectMapDefectGroup'
						AND		C.ENABLED_FLAG = 'Y'
						AND		D.LANGUAGETYPE = #{LANGUAGETYPE}        -- 다국어 코드
					) 					GRP
					LEFT OUTER JOIN		
					(
						SELECT	C.LOOKUP_CODE   AS CODEID
							,	D.DICTIONARYNAME						AS	SUBNAME
							,	C.PARENTCODEID
						FROM	CMD_LOOKUP_VALUES									C
						LEFT OUTER JOIN 	CMD_DICTIONARY	D			ON 	C.DICTIONARYID = D.DICTIONARYID
						WHERE	C.LOOKUP_TYPE = 'DefectMapDefectGroupSub'
						AND		C.ENABLED_FLAG = 'Y'
						AND		D.LANGUAGETYPE = #{LANGUAGETYPE}        -- 다국어 코드
					) 					SUB								ON	GRP.CODEID = SUB.PARENTCODEID
					WHERE 1 = 1
                              AND GRP.CODEID IN ('001','002')
                              AND SUB.CODEID IN ('1001','2001')
				)   T_AFT_ANALYSIS
            ON A.SEGMENTTYPE = T_AFT_ANALYSIS.SEGMENTTYPE 
            AND A.DEFECTCODE = T_AFT_ANALYSIS.CHK_S_CODE
-----------------------------------------------------------------   
		LEFT OUTER JOIN (	
							SELECT
									'AOIInspection'                               	AS SEGMENTTYPE	
							    ,   GRP.CODEID										AS GROUPCODE
								,	GRP.GROUPNAME								AS GROUPNAME
								,	GRP.DESCRIPTION 								AS COLOR
								,	SUB.CODEID										AS SUBCODE
								,	SUB.SUBNAME									AS SUBNAME
							FROM	
							(
								SELECT 	C.LOOKUP_CODE   AS CODEID
									,	C.DESCRIPTION
									,	D.DICTIONARYNAME						AS GROUPNAME
								FROM 	CMD_LOOKUP_VALUES									C
								LEFT OUTER JOIN		CMD_DICTIONARY	D	ON	C.DICTIONARYID = D.DICTIONARYID						           	   			   		    
								WHERE	C.LOOKUP_TYPE = 'DefectMapDefectGroup'
								AND		C.ENABLED_FLAG = 'Y'
								AND		D.LANGUAGETYPE = #{LANGUAGETYPE} 
							) 					GRP
							LEFT OUTER JOIN		
							(
								SELECT	C.LOOKUP_CODE AS CODEID
									,	D.DICTIONARYNAME						AS SUBNAME
									,	C.PARENTCODEID
								FROM	CMD_LOOKUP_VALUES									C
								LEFT OUTER JOIN 	CMD_DICTIONARY	D	ON 	C.DICTIONARYID = D.DICTIONARYID
								WHERE	C.LOOKUP_TYPE = 'DefectMapDefectGroupSub'
								AND		C.ENABLED_FLAG = 'Y'
								AND		D.LANGUAGETYPE = #{LANGUAGETYPE} 
							) 					
							SUB		ON GRP.CODEID = SUB.PARENTCODEID              
						) AOI		ON A.DEFECTCODE = AOI.SUBCODE  	
                                  AND A.SEGMENTTYPE = AOI.SEGMENTTYPE	
                                  
		---------------------------------[1]
		-- (21.07.12) 추가
        INNER JOIN BAS_PRODUCTDEFINITION E      ON 	A.PRODUCTDEFID = E.PRODUCTDEFID
											   AND  A.PRODUCTDEFVERSION  = E.PRODUCTDEFVERSION
		---------------------------------
		-----------------------------------(21.08.10) 인계 시간 조건 추가        
		LEFT JOIN T_SENDTIME TT 
				ON TT.LOTID             			= A.LOTID
			   AND TT.PROCESSSEGMENTID  	= A.PROCESSSEGMENTID
		-----------------------------
		
                                  
		WHERE 1 = 1
		  AND A.SEGMENTTYPE = 'AOIInspection'
		  AND A.ENTERPRISEID = #{P_ENTERPRISEID}
		  AND A.PLANTID = #{P_PLANTID}		  
		<if test="P_PERIOD_PERIODFR != null and P_PERIOD_PERIODFR !='' and P_PERIOD_PERIODTO != null and P_PERIOD_PERIODTO !=''">
		  -- (21.08.10) 인계 시간 조건 추가 A.CREATEDTIME -> TT.SENDTIME	
		  AND TT.SENDTIME <![CDATA[>=]]> TO_TIMESTAMP(SUBSTR(#{P_PERIOD_PERIODFR},1,14), 'YYYYMMDDHH24MISS')
		  AND TT.SENDTIME <![CDATA[<]]>  TO_TIMESTAMP(TO_CHAR(TO_DATE(SUBSTR(#{P_PERIOD_PERIODTO},1,8), 'YYYYMMDD'), 'YYYY-MM-DD') || ' ' || SUBSTR(#{P_PERIOD_PERIODTO}, 9, 6), 'YYYY-MM-DD HH24:MI:SS') 
		</if>
		<if test="LOTID_LIST.length != 0">
                AND		A.LOTID IN
	           <foreach collection="LOTID_LIST" item="item" index="index" separator="," open="(" close=")">
	                    #{item}
	           </foreach>				
		</if>	
		<if test="PROCESSSEGMENTID_LIST.length != 0">
                AND		A.PROCESSSEGMENTID IN
	           <foreach collection="PROCESSSEGMENTID_LIST" item="item" index="index" separator="," open="(" close=")">
	                    #{item}
	           </foreach>				
		</if>		
		<if test="PRODUCTDEFIDVER_LIST.length != 0">
                AND		A.PRODUCTDEFID || A.PRODUCTDEFVERSION IN
	           <foreach collection="PRODUCTDEFIDVER_LIST" item="item" index="index" separator="," open="(" close=")">
	                    #{item}
	           </foreach>				
		</if>
		<if test="P_AOIPROCESS != null and P_AOIPROCESS !=''">
			-- AOI 공정
			AND	 EXISTS (SELECT 1 FROM ufn_selectStringToSplit(#{P_AOIPROCESS},',') WHERE value = A.PROCESSSEGMENTID) 
		</if>
		
		<if test="P_PRODUCTIONTYPE != null and P_PRODUCTIONTYPE !='' and !(P_PRODUCTIONTYPE eq '*'.toString()) ">
			-- (21.07.12) 생산구분 추가[1]
			AND 	E.PRODUCTIONTYPE 			= #{P_PRODUCTIONTYPE}
		</if>
		
		) A
		, 
           
		   (
		   SELECT
					A.SEGMENTTYPE    
                ,   A.PROCESSSEGMENTID
                ,   SUM(A.INSPECTIONQTY) AS INSPECTIONQTY
            FROM
           (
		   SELECT
					A.SEGMENTTYPE    
                ,   A.PROCESSSEGMENTID
                ,   A.LOTID
                ,	MAX(A.INSPECTIONQTY) AS INSPECTIONQTY   
		FROM PCM_QCAOIBBTWORKCOMPLETE	A    
			INNER JOIN LOTLIST 					L	ON	A.LOTID = L.LOTID
													AND	A.PRODUCTDEFID = L.PRODUCTDEFID
													AND	A.PRODUCTDEFVERSION = L.PRODUCTDEFVERSION				
            -- (21.06.17) 완료된 상태 체크   -> (21.06.18) 여러건 존재함 하나만 나오도록 수정
            INNER JOIN (SELECT RESOURCEID
                            ,  INSPECTIONDEFID  
                            , PROCESSSEGMENTID, PROCESSSEGMENTVERSION
                         FROM  QAM_INSPECTIONRESULT   
                         GROUP BY  RESOURCEID, INSPECTIONDEFID    
                                    , PROCESSSEGMENTID, PROCESSSEGMENTVERSION
                         ) Q_INSP
            ON Q_INSP.RESOURCEID                 		=  A.LOTID
            AND Q_INSP.INSPECTIONDEFID 					= 	'AOIInspection'
            AND Q_INSP.PROCESSSEGMENTID					= A.PROCESSSEGMENTID
            AND Q_INSP.PROCESSSEGMENTVERSION			= A.PROCESSSEGMENTVERSION
            -----------------------------------------------------------------   	
            LEFT OUTER JOIN (
					SELECT	GRP.CODEID								AS	GROUPCODE
						,	GRP.GROUPNAME							AS	GROUPNAME
						,	GRP.DESCRIPTION 							AS	COLOR
						,	SUB.CODEID									AS	SUBCODE
						,	SUB.SUBNAME								AS	SUBNAME
						,	'AOIInspection'								AS	SEGMENTTYPE
						,   '005'                                       	AS  CHK_G_CODE
                                    ,   (
                                        CASE WHEN SUB.CODEID = '1001'
                                             THEN '5001'
                                             ELSE '5002'
                                             END
                                    )   													AS CHK_S_CODE
					FROM	
					(
						SELECT 	C.LOOKUP_CODE   AS CODEID
							,	C.DESCRIPTION
							,	D.DICTIONARYNAME						AS	GROUPNAME
						FROM 	CMD_LOOKUP_VALUES									C
						LEFT OUTER JOIN		CMD_DICTIONARY	D			ON	C.DICTIONARYID = D.DICTIONARYID						           	   			   		    
						WHERE	C.LOOKUP_TYPE = 'DefectMapDefectGroup'
						AND		C.ENABLED_FLAG = 'Y'
						AND		D.LANGUAGETYPE = #{LANGUAGETYPE}        -- 다국어 코드
					) 					GRP
					LEFT OUTER JOIN		
					(
						SELECT	C.LOOKUP_CODE   AS CODEID
							,	D.DICTIONARYNAME						AS	SUBNAME
							,	C.PARENTCODEID
						FROM	CMD_LOOKUP_VALUES									C
						LEFT OUTER JOIN 	CMD_DICTIONARY	D			ON 	C.DICTIONARYID = D.DICTIONARYID
						WHERE	C.LOOKUP_TYPE = 'DefectMapDefectGroupSub'
						AND		C.ENABLED_FLAG = 'Y'
						AND		D.LANGUAGETYPE = #{LANGUAGETYPE}        -- 다국어 코드
					) 					SUB								ON	GRP.CODEID = SUB.PARENTCODEID
					WHERE 1 = 1
                              AND GRP.CODEID IN ('001','002')
                              AND SUB.CODEID IN ('1001','2001')
				)   T_AFT_ANALYSIS
            ON A.SEGMENTTYPE = T_AFT_ANALYSIS.SEGMENTTYPE 
            AND A.DEFECTCODE = T_AFT_ANALYSIS.CHK_S_CODE
-----------------------------------------------------------------   
		LEFT OUTER JOIN (	
							SELECT
									'AOIInspection'                               	AS SEGMENTTYPE	
							    ,   GRP.CODEID										AS GROUPCODE
								,	GRP.GROUPNAME								AS GROUPNAME
								,	GRP.DESCRIPTION 								AS COLOR
								,	SUB.CODEID										AS SUBCODE
								,	SUB.SUBNAME									AS SUBNAME
							FROM	
							(
								SELECT 	C.LOOKUP_CODE   AS CODEID
									,	C.DESCRIPTION
									,	D.DICTIONARYNAME						AS GROUPNAME
								FROM 	CMD_LOOKUP_VALUES									C
								LEFT OUTER JOIN		CMD_DICTIONARY	D	ON	C.DICTIONARYID = D.DICTIONARYID						           	   			   		    
								WHERE	C.LOOKUP_TYPE = 'DefectMapDefectGroup'
								AND		C.ENABLED_FLAG = 'Y'
								AND		D.LANGUAGETYPE = #{LANGUAGETYPE} 
							) 					GRP
							LEFT OUTER JOIN		
							(
								SELECT	C.LOOKUP_CODE AS CODEID
									,	D.DICTIONARYNAME						AS SUBNAME
									,	C.PARENTCODEID
								FROM	CMD_LOOKUP_VALUES									C
								LEFT OUTER JOIN 	CMD_DICTIONARY	D	ON 	C.DICTIONARYID = D.DICTIONARYID
								WHERE	C.LOOKUP_TYPE = 'DefectMapDefectGroupSub'
								AND		C.ENABLED_FLAG = 'Y'
								AND		D.LANGUAGETYPE = #{LANGUAGETYPE} 
							) 					
							SUB		ON GRP.CODEID = SUB.PARENTCODEID              
						) AOI		ON A.DEFECTCODE = AOI.SUBCODE  	
                                  AND A.SEGMENTTYPE = AOI.SEGMENTTYPE	
		
		---------------------------------[2]
		-- (21.07.12) 추가
        INNER JOIN BAS_PRODUCTDEFINITION E      ON 	A.PRODUCTDEFID = E.PRODUCTDEFID
											   AND  A.PRODUCTDEFVERSION  = E.PRODUCTDEFVERSION
		---------------------------------
		-----------------------------------(21.08.10) 인계 시간 조건 추가        
		LEFT JOIN T_SENDTIME TT 
				ON TT.LOTID             			= A.LOTID
			   AND TT.PROCESSSEGMENTID  	= A.PROCESSSEGMENTID
		-----------------------------
                                  
		WHERE 1 = 1
		  AND A.SEGMENTTYPE = 'AOIInspection'
		  AND A.ENTERPRISEID = #{P_ENTERPRISEID}
		  AND A.PLANTID = #{P_PLANTID}		  
		<if test="P_PERIOD_PERIODFR != null and P_PERIOD_PERIODFR !='' and P_PERIOD_PERIODTO != null and P_PERIOD_PERIODTO !=''">
		  -- (21.08.10) 인계 시간 조건 추가 A.CREATEDTIME -> TT.SENDTIME	
		  AND TT.SENDTIME	 <![CDATA[>=]]> TO_TIMESTAMP(SUBSTR(#{P_PERIOD_PERIODFR},1,14), 'YYYYMMDDHH24MISS')
		  AND TT.SENDTIME	 <![CDATA[<]]>  TO_TIMESTAMP(TO_CHAR(TO_DATE(SUBSTR(#{P_PERIOD_PERIODTO},1,8), 'YYYYMMDD'), 'YYYY-MM-DD') || ' ' || SUBSTR(#{P_PERIOD_PERIODTO}, 9, 6), 'YYYY-MM-DD HH24:MI:SS') 
		</if>
		<if test="LOTID_LIST.length != 0">
                AND		A.LOTID IN
	           <foreach collection="LOTID_LIST" item="item" index="index" separator="," open="(" close=")">
	                    #{item}
	           </foreach>				
		</if>	
		<if test="PROCESSSEGMENTID_LIST.length != 0">
                AND		A.PROCESSSEGMENTID IN
	           <foreach collection="PROCESSSEGMENTID_LIST" item="item" index="index" separator="," open="(" close=")">
	                    #{item}
	           </foreach>				
		</if>		
		<if test="PRODUCTDEFIDVER_LIST.length != 0">
                AND		A.PRODUCTDEFID || A.PRODUCTDEFVERSION IN
	           <foreach collection="PRODUCTDEFIDVER_LIST" item="item" index="index" separator="," open="(" close=")">
	                    #{item}
	           </foreach>				
		</if>
		<if test="P_AOIPROCESS != null and P_AOIPROCESS !=''">
			-- AOI 공정
			AND	 EXISTS (SELECT 1 FROM ufn_selectStringToSplit(#{P_AOIPROCESS},',') WHERE value = A.PROCESSSEGMENTID) 
		</if>
		
		<if test="P_PRODUCTIONTYPE != null and P_PRODUCTIONTYPE !='' and !(P_PRODUCTIONTYPE eq '*'.toString()) ">
			-- (21.07.12) 생산구분 추가[2]
			AND 	E.PRODUCTIONTYPE 			= #{P_PRODUCTIONTYPE}
		</if>
		
        GROUP BY 
		 			A.SEGMENTTYPE    
                ,   A.PROCESSSEGMENTID
                ,   A.LOTID
        ) A
        GROUP BY 
		 			A.SEGMENTTYPE    
                ,   A.PROCESSSEGMENTID 
	    ) B
		WHERE A.PROCESSSEGMENTID = B.PROCESSSEGMENTID

		)  A
		GROUP BY 
				A.GROUPCODE				
			,	A.GROUPNAME															
	   )	  G -- GROUPCODE		
		  , (
		  	SELECT
					A.GROUPCODE						    AS GROUPCODE
				,	A.GROUPNAME							AS GROUPNAME
				,	A.SUBCODE								AS SUBCODE	
				,	A.SUBNAME								AS SUBNAME				
               ,    SUM(NVL(A.DEFECTCOUNT,0)) - SUM(NVL(A.REPAIRRESULTQTY, 0)) AS AFTERDEFECTCNT
               ,    ROUND(DECODE(MAX(NVL(A.INSPECTIONQTY,0)), 0, 0,  (SUM(NVL(A.DEFECTCOUNT,0)) - SUM(NVL(A.REPAIRRESULTQTY, 0)))/ MAX(NVL(A.INSPECTIONQTY,0))) * 100, 2)  AS AFTERDEFECTRATE     
               FROM
               (
			   SELECT
					A.PRODUCTDEFID
				,	A.PRODUCTDEFVERSION
				,	A.LOTID
				,	A.PROCESSSEGMENTID 
                ,	B.INSPECTIONQTY                
                ,    A.REPAIRTARGETQTY
                ,    A.REPAIRRESULTQTY 
                ,  A.GROUPCODE
                ,  A.GROUPNAME  
                ,	A.SUBCODE	 
                ,	A.SUBNAME
                ,  A.COLOR
                , A.DEFECTCOUNT
			   FROM
			   (
               SELECT            
					A.PRODUCTDEFID
				,	A.PRODUCTDEFVERSION
				,	A.LOTID
				,	A.PROCESSSEGMENTID 
                ,	A.INSPECTIONQTY                
               ,    A.REPAIRTARGETQTY
               ,    A.REPAIRRESULTQTY 
                ----------------------------------------------------------------(21.06.17)
                -- 블량 그룹 
                ,  (
                        CASE WHEN AOI.GROUPCODE = '005'  
                            THEN T_AFT_ANALYSIS.GROUPCODE
                            ELSE COALESCE(AOI.GROUPCODE, '999')
                            END
                    ) AS GROUPCODE
                -- 블량 그룹명 
                ,  (
                        CASE WHEN AOI.GROUPCODE = '005'  
                            THEN T_AFT_ANALYSIS.GROUPNAME
                            ELSE COALESCE(AOI.GROUPNAME, 'NONE')
                            END
                    ) AS GROUPNAME
                -- 불량 코드   
                ,	COALESCE(
                            CASE A.SEGMENTTYPE
                                WHEN 'AOIInspection' 
                                THEN (
                                       CASE WHEN AOI.GROUPCODE = '005'  
                                            THEN T_AFT_ANALYSIS.SUBCODE
                                            ELSE AOI.SUBCODE
                                            END 
                                    )
                                ELSE AOI.SUBCODE
                            END, '9999') 														AS	SUBCODE	 
                -- 불량 코드명
                ,	COALESCE(
                            CASE A.SEGMENTTYPE
                                WHEN 'AOIInspection' 
                                THEN (
                                       CASE WHEN AOI.GROUPCODE = '005'  
                                            THEN T_AFT_ANALYSIS.SUBNAME
                                            ELSE  AOI.SUBNAME
                                            END 
                                    )
                                ELSE AOI.SUBNAME
                            END, 'NONE')														AS	SUBNAME
                -- 불량 색상
                ,  COALESCE(
                            CASE A.SEGMENTTYPE
                                WHEN 'AOIInspection' 
                                THEN (
                                       CASE WHEN AOI.GROUPCODE = '005'  
                                            THEN T_AFT_ANALYSIS.COLOR
                                            ELSE AOI.COLOR
                                            END 
                                    )
                                ELSE AOI.COLOR
                            END, '#000000')														AS	COLOR
                    
                -- 불량 수량 
                , A.DEFECTCOUNT
               -----------------------------------------------------------------------------------------     
		FROM PCM_QCAOIBBTWORKCOMPLETE	A    
			INNER JOIN LOTLIST 					L	ON	A.LOTID = L.LOTID
													AND	A.PRODUCTDEFID = L.PRODUCTDEFID
													AND	A.PRODUCTDEFVERSION = L.PRODUCTDEFVERSION				
            -- (21.06.17) 완료된 상태 체크   -> (21.06.18) 여러건 존재함 하나만 나오도록 수정
            INNER JOIN (SELECT RESOURCEID
                            ,  INSPECTIONDEFID  
                            , PROCESSSEGMENTID, PROCESSSEGMENTVERSION
                         FROM  QAM_INSPECTIONRESULT   
                         GROUP BY  RESOURCEID, INSPECTIONDEFID    
                                    , PROCESSSEGMENTID, PROCESSSEGMENTVERSION
                         ) Q_INSP
            ON Q_INSP.RESOURCEID                 		=  A.LOTID
            AND Q_INSP.INSPECTIONDEFID 					= 	'AOIInspection'
            AND Q_INSP.PROCESSSEGMENTID					= A.PROCESSSEGMENTID
            AND Q_INSP.PROCESSSEGMENTVERSION			= A.PROCESSSEGMENTVERSION
            -----------------------------------------------------------------   	
            LEFT OUTER JOIN (
					SELECT	GRP.CODEID								AS	GROUPCODE
						,	GRP.GROUPNAME							AS	GROUPNAME
						,	GRP.DESCRIPTION 							AS	COLOR
						,	SUB.CODEID									AS	SUBCODE
						,	SUB.SUBNAME								AS	SUBNAME
						,	'AOIInspection'								AS	SEGMENTTYPE
						,   '005'                                       	AS  CHK_G_CODE
                                    ,   (
                                        CASE WHEN SUB.CODEID = '1001'
                                             THEN '5001'
                                             ELSE '5002'
                                             END
                                    )   													AS CHK_S_CODE
					FROM	
					(
						SELECT 	C.LOOKUP_CODE   AS CODEID
							,	C.DESCRIPTION
							,	D.DICTIONARYNAME						AS	GROUPNAME
						FROM 	CMD_LOOKUP_VALUES									C
						LEFT OUTER JOIN		CMD_DICTIONARY	D			ON	C.DICTIONARYID = D.DICTIONARYID						           	   			   		    
						WHERE	C.LOOKUP_TYPE = 'DefectMapDefectGroup'
						AND		C.ENABLED_FLAG = 'Y'
						AND		D.LANGUAGETYPE = #{LANGUAGETYPE}        -- 다국어 코드
					) 					GRP
					LEFT OUTER JOIN		
					(
						SELECT	C.LOOKUP_CODE   AS CODEID
							,	D.DICTIONARYNAME						AS	SUBNAME
							,	C.PARENTCODEID
						FROM	CMD_LOOKUP_VALUES									C
						LEFT OUTER JOIN 	CMD_DICTIONARY	D			ON 	C.DICTIONARYID = D.DICTIONARYID
						WHERE	C.LOOKUP_TYPE = 'DefectMapDefectGroupSub'
						AND		C.ENABLED_FLAG = 'Y'
						AND		D.LANGUAGETYPE = #{LANGUAGETYPE}        -- 다국어 코드
					) 					SUB								ON	GRP.CODEID = SUB.PARENTCODEID
					WHERE 1 = 1
                              AND GRP.CODEID IN ('001','002')
                              AND SUB.CODEID IN ('1001','2001')
				)   T_AFT_ANALYSIS
            ON A.SEGMENTTYPE = T_AFT_ANALYSIS.SEGMENTTYPE 
            AND A.DEFECTCODE = T_AFT_ANALYSIS.CHK_S_CODE
-----------------------------------------------------------------   
		LEFT OUTER JOIN (	
							SELECT
									'AOIInspection'                               	AS SEGMENTTYPE	
							    ,   GRP.CODEID										AS GROUPCODE
								,	GRP.GROUPNAME								AS GROUPNAME
								,	GRP.DESCRIPTION 								AS COLOR
								,	SUB.CODEID										AS SUBCODE
								,	SUB.SUBNAME									AS SUBNAME
							FROM	
							(
								SELECT 	C.LOOKUP_CODE   AS CODEID
									,	C.DESCRIPTION
									,	D.DICTIONARYNAME						AS GROUPNAME
								FROM 	CMD_LOOKUP_VALUES									C
								LEFT OUTER JOIN		CMD_DICTIONARY	D	ON	C.DICTIONARYID = D.DICTIONARYID						           	   			   		    
								WHERE	C.LOOKUP_TYPE = 'DefectMapDefectGroup'
								AND		C.ENABLED_FLAG = 'Y'
								AND		D.LANGUAGETYPE = #{LANGUAGETYPE} 
							) 					GRP
							LEFT OUTER JOIN		
							(
								SELECT	C.LOOKUP_CODE AS CODEID
									,	D.DICTIONARYNAME						AS SUBNAME
									,	C.PARENTCODEID
								FROM	CMD_LOOKUP_VALUES									C
								LEFT OUTER JOIN 	CMD_DICTIONARY	D	ON 	C.DICTIONARYID = D.DICTIONARYID
								WHERE	C.LOOKUP_TYPE = 'DefectMapDefectGroupSub'
								AND		C.ENABLED_FLAG = 'Y'
								AND		D.LANGUAGETYPE = #{LANGUAGETYPE} 
							) 					
							SUB		ON GRP.CODEID = SUB.PARENTCODEID              
						) AOI		ON A.DEFECTCODE = AOI.SUBCODE  	
                                  AND A.SEGMENTTYPE = AOI.SEGMENTTYPE	
                                  
		---------------------------------[3]
		-- (21.07.12) 추가
        INNER JOIN BAS_PRODUCTDEFINITION E      ON 	A.PRODUCTDEFID = E.PRODUCTDEFID
											   AND  A.PRODUCTDEFVERSION  = E.PRODUCTDEFVERSION
		---------------------------------
		-----------------------------------(21.08.10) 인계 시간 조건 추가        
		LEFT JOIN T_SENDTIME TT 
				ON TT.LOTID             			= A.LOTID
			   AND TT.PROCESSSEGMENTID  	= A.PROCESSSEGMENTID
		-----------------------------
                                  
		WHERE 1 = 1
		  AND A.SEGMENTTYPE = 'AOIInspection'
		  AND A.ENTERPRISEID = #{P_ENTERPRISEID}
		  AND A.PLANTID = #{P_PLANTID}		  
		<if test="P_PERIOD_PERIODFR != null and P_PERIOD_PERIODFR !='' and P_PERIOD_PERIODTO != null and P_PERIOD_PERIODTO !=''">
		  -- (21.08.10) 인계 시간 조건 추가 A.CREATEDTIME -> TT.SENDTIME
		  AND TT.SENDTIME <![CDATA[>=]]> TO_TIMESTAMP(SUBSTR(#{P_PERIOD_PERIODFR},1,14), 'YYYYMMDDHH24MISS')
		  AND TT.SENDTIME <![CDATA[<]]>  TO_TIMESTAMP(TO_CHAR(TO_DATE(SUBSTR(#{P_PERIOD_PERIODTO},1,8), 'YYYYMMDD'), 'YYYY-MM-DD') || ' ' || SUBSTR(#{P_PERIOD_PERIODTO}, 9, 6), 'YYYY-MM-DD HH24:MI:SS') 
		</if>
		<if test="LOTID_LIST.length != 0">
                AND		A.LOTID IN
	           <foreach collection="LOTID_LIST" item="item" index="index" separator="," open="(" close=")">
	                    #{item}
	           </foreach>				
		</if>	
		<if test="PROCESSSEGMENTID_LIST.length != 0">
                AND		A.PROCESSSEGMENTID IN
	           <foreach collection="PROCESSSEGMENTID_LIST" item="item" index="index" separator="," open="(" close=")">
	                    #{item}
	           </foreach>				
		</if>		
		<if test="PRODUCTDEFIDVER_LIST.length != 0">
                AND		A.PRODUCTDEFID || A.PRODUCTDEFVERSION IN
	           <foreach collection="PRODUCTDEFIDVER_LIST" item="item" index="index" separator="," open="(" close=")">
	                    #{item}
	           </foreach>				
		</if>
		<if test="P_AOIPROCESS != null and P_AOIPROCESS !=''">
			-- AOI 공정
			AND	 EXISTS (SELECT 1 FROM ufn_selectStringToSplit(#{P_AOIPROCESS},',') WHERE value = A.PROCESSSEGMENTID) 
		</if>
		
		<if test="P_PRODUCTIONTYPE != null and P_PRODUCTIONTYPE !='' and !(P_PRODUCTIONTYPE eq '*'.toString()) ">
			-- (21.07.12) 생산구분 추가[3]
			AND 	E.PRODUCTIONTYPE 			= #{P_PRODUCTIONTYPE}
		</if>
		
		) A
		, 
           
		   (
		   SELECT
					A.SEGMENTTYPE    
                ,   A.PROCESSSEGMENTID
                ,   SUM(A.INSPECTIONQTY) AS INSPECTIONQTY
            FROM
           (
		   SELECT
					A.SEGMENTTYPE    
                ,   A.PROCESSSEGMENTID
                ,   A.LOTID
                ,	MAX(A.INSPECTIONQTY) AS INSPECTIONQTY   
		FROM PCM_QCAOIBBTWORKCOMPLETE	A    
			INNER JOIN LOTLIST 					L	ON	A.LOTID = L.LOTID
													AND	A.PRODUCTDEFID = L.PRODUCTDEFID
													AND	A.PRODUCTDEFVERSION = L.PRODUCTDEFVERSION				
            -- (21.06.17) 완료된 상태 체크   -> (21.06.18) 여러건 존재함 하나만 나오도록 수정
            INNER JOIN (SELECT RESOURCEID
                            ,  INSPECTIONDEFID  
                            , PROCESSSEGMENTID, PROCESSSEGMENTVERSION
                         FROM  QAM_INSPECTIONRESULT   
                         GROUP BY  RESOURCEID, INSPECTIONDEFID    
                                    , PROCESSSEGMENTID, PROCESSSEGMENTVERSION
                         ) Q_INSP
            ON Q_INSP.RESOURCEID                 		=  A.LOTID
            AND Q_INSP.INSPECTIONDEFID 					= 	'AOIInspection'
            AND Q_INSP.PROCESSSEGMENTID					= A.PROCESSSEGMENTID
            AND Q_INSP.PROCESSSEGMENTVERSION			= A.PROCESSSEGMENTVERSION
            -----------------------------------------------------------------   	
            LEFT OUTER JOIN (
					SELECT	GRP.CODEID								AS	GROUPCODE
						,	GRP.GROUPNAME							AS	GROUPNAME
						,	GRP.DESCRIPTION 							AS	COLOR
						,	SUB.CODEID									AS	SUBCODE
						,	SUB.SUBNAME								AS	SUBNAME
						,	'AOIInspection'								AS	SEGMENTTYPE
						,   '005'                                       	AS  CHK_G_CODE
                                    ,   (
                                        CASE WHEN SUB.CODEID = '1001'
                                             THEN '5001'
                                             ELSE '5002'
                                             END
                                    )   													AS CHK_S_CODE
					FROM	
					(
						SELECT 	C.LOOKUP_CODE   AS CODEID
							,	C.DESCRIPTION
							,	D.DICTIONARYNAME						AS	GROUPNAME
						FROM 	CMD_LOOKUP_VALUES									C
						LEFT OUTER JOIN		CMD_DICTIONARY	D			ON	C.DICTIONARYID = D.DICTIONARYID						           	   			   		    
						WHERE	C.LOOKUP_TYPE = 'DefectMapDefectGroup'
						AND		C.ENABLED_FLAG = 'Y'
						AND		D.LANGUAGETYPE = #{LANGUAGETYPE}        -- 다국어 코드
					) 					GRP
					LEFT OUTER JOIN		
					(
						SELECT	C.LOOKUP_CODE   AS CODEID
							,	D.DICTIONARYNAME						AS	SUBNAME
							,	C.PARENTCODEID
						FROM	CMD_LOOKUP_VALUES									C
						LEFT OUTER JOIN 	CMD_DICTIONARY	D			ON 	C.DICTIONARYID = D.DICTIONARYID
						WHERE	C.LOOKUP_TYPE = 'DefectMapDefectGroupSub'
						AND		C.ENABLED_FLAG = 'Y'
						AND		D.LANGUAGETYPE = #{LANGUAGETYPE}        -- 다국어 코드
					) 					SUB								ON	GRP.CODEID = SUB.PARENTCODEID
					WHERE 1 = 1
                              AND GRP.CODEID IN ('001','002')
                              AND SUB.CODEID IN ('1001','2001')
				)   T_AFT_ANALYSIS
            ON A.SEGMENTTYPE = T_AFT_ANALYSIS.SEGMENTTYPE 
            AND A.DEFECTCODE = T_AFT_ANALYSIS.CHK_S_CODE
-----------------------------------------------------------------   
		LEFT OUTER JOIN (	
							SELECT
									'AOIInspection'                               	AS SEGMENTTYPE	
							    ,   GRP.CODEID										AS GROUPCODE
								,	GRP.GROUPNAME								AS GROUPNAME
								,	GRP.DESCRIPTION 								AS COLOR
								,	SUB.CODEID										AS SUBCODE
								,	SUB.SUBNAME									AS SUBNAME
							FROM	
							(
								SELECT 	C.LOOKUP_CODE   AS CODEID
									,	C.DESCRIPTION
									,	D.DICTIONARYNAME						AS GROUPNAME
								FROM 	CMD_LOOKUP_VALUES									C
								LEFT OUTER JOIN		CMD_DICTIONARY	D	ON	C.DICTIONARYID = D.DICTIONARYID						           	   			   		    
								WHERE	C.LOOKUP_TYPE = 'DefectMapDefectGroup'
								AND		C.ENABLED_FLAG = 'Y'
								AND		D.LANGUAGETYPE = #{LANGUAGETYPE} 
							) 					GRP
							LEFT OUTER JOIN		
							(
								SELECT	C.LOOKUP_CODE AS CODEID
									,	D.DICTIONARYNAME						AS SUBNAME
									,	C.PARENTCODEID
								FROM	CMD_LOOKUP_VALUES									C
								LEFT OUTER JOIN 	CMD_DICTIONARY	D	ON 	C.DICTIONARYID = D.DICTIONARYID
								WHERE	C.LOOKUP_TYPE = 'DefectMapDefectGroupSub'
								AND		C.ENABLED_FLAG = 'Y'
								AND		D.LANGUAGETYPE = #{LANGUAGETYPE} 
							) 					
							SUB		ON GRP.CODEID = SUB.PARENTCODEID              
						) AOI		ON A.DEFECTCODE = AOI.SUBCODE  	
                                  AND A.SEGMENTTYPE = AOI.SEGMENTTYPE	

		---------------------------------[4]
		-- (21.07.12) 추가
        INNER JOIN BAS_PRODUCTDEFINITION E      ON 	A.PRODUCTDEFID = E.PRODUCTDEFID
											   AND  A.PRODUCTDEFVERSION  = E.PRODUCTDEFVERSION
		---------------------------------        
		-----------------------------------(21.08.10) 인계 시간 조건 추가        
		LEFT JOIN T_SENDTIME TT 
				ON TT.LOTID             			= A.LOTID
			   AND TT.PROCESSSEGMENTID  	= A.PROCESSSEGMENTID
		-----------------------------                          

		WHERE 1 = 1
		  AND A.SEGMENTTYPE = 'AOIInspection'
		  AND A.ENTERPRISEID = #{P_ENTERPRISEID}
		  AND A.PLANTID = #{P_PLANTID}		  
		<if test="P_PERIOD_PERIODFR != null and P_PERIOD_PERIODFR !='' and P_PERIOD_PERIODTO != null and P_PERIOD_PERIODTO !=''">
		  -- (21.08.10) 인계 시간 조건 추가 A.CREATEDTIME -> TT.SENDTIME	
		  AND TT.SENDTIME <![CDATA[>=]]> TO_TIMESTAMP(SUBSTR(#{P_PERIOD_PERIODFR},1,14), 'YYYYMMDDHH24MISS')
		  AND TT.SENDTIME <![CDATA[<]]>  TO_TIMESTAMP(TO_CHAR(TO_DATE(SUBSTR(#{P_PERIOD_PERIODTO},1,8), 'YYYYMMDD'), 'YYYY-MM-DD') || ' ' || SUBSTR(#{P_PERIOD_PERIODTO}, 9, 6), 'YYYY-MM-DD HH24:MI:SS') 
		</if>
		<if test="LOTID_LIST.length != 0">
                AND		A.LOTID IN
	           <foreach collection="LOTID_LIST" item="item" index="index" separator="," open="(" close=")">
	                    #{item}
	           </foreach>				
		</if>	
		<if test="PROCESSSEGMENTID_LIST.length != 0">
                AND		A.PROCESSSEGMENTID IN
	           <foreach collection="PROCESSSEGMENTID_LIST" item="item" index="index" separator="," open="(" close=")">
	                    #{item}
	           </foreach>				
		</if>		
		<if test="PRODUCTDEFIDVER_LIST.length != 0">
                AND		A.PRODUCTDEFID || A.PRODUCTDEFVERSION IN
	           <foreach collection="PRODUCTDEFIDVER_LIST" item="item" index="index" separator="," open="(" close=")">
	                    #{item}
	           </foreach>				
		</if>
		<if test="P_AOIPROCESS != null and P_AOIPROCESS !=''">
			-- AOI 공정
			AND	 EXISTS (SELECT 1 FROM ufn_selectStringToSplit(#{P_AOIPROCESS},',') WHERE value = A.PROCESSSEGMENTID) 
		</if>
		
		<if test="P_PRODUCTIONTYPE != null and P_PRODUCTIONTYPE !='' and !(P_PRODUCTIONTYPE eq '*'.toString()) ">
			-- (21.07.12) 생산구분 추가[4]
			AND 	E.PRODUCTIONTYPE 			= #{P_PRODUCTIONTYPE}
		</if>
		
        GROUP BY 
		 			A.SEGMENTTYPE    
                ,   A.PROCESSSEGMENTID
                ,   A.LOTID
        ) A
        GROUP BY 
		 			A.SEGMENTTYPE    
                ,   A.PROCESSSEGMENTID 
	    ) B
		WHERE A.PROCESSSEGMENTID = B.PROCESSSEGMENTID
				) A
				GROUP BY 
						A.GROUPCODE				
					,	A.GROUPNAME		
					,	A.SUBCODE 									
					,	A.SUBNAME										
			   )	  S -- SUBCODE		
			 WHERE 1 = 1
				AND G.GROUPCODE = S.GROUPCODE
				AND G.AFTERDEFECTRATE <![CDATA[>]]> 0
			<if test="P_GROUPCODE != null and P_GROUPCODE !=''">
				AND G.GROUPCODE = #{P_GROUPCODE}
			</if>		    
			ORDER BY 	
					G.GROUPCODE
				  , 	S.SUBCODE				
    </select>

 <!-- AOI 분석 전/후 비교 조회 -->
    <select id="getDefectRateByRepairAfterDetail" parameterType="map" resultType="hashmap">
		-- getDefectRateByRepairAfterDetail  품목코드 입력시
			WITH	LOTLIST	AS 
			(
					SELECT	C.LOTSTARTDATE
						,	C.LOTID
						,	C.PRODUCTDEFID
						,	C.PRODUCTDEFVERSION
						,	C.PROCESSSEGMENTID
					FROM	PCM_LOT C
					WHERE	
                            --EXISTS
                        	C.LOTID IN		-- (21.06.17) 속도개선 lot 처럼 변경함 
							(	SELECT	A.LOTID		--1 (21.06.17) 속도개선 lot 처럼 변경함
								FROM	PCM_LOTWORKRESULT				A
										INNER JOIN	BAS_PROCESSSEGMENT	B	ON A.PROCESSSEGMENTID = B.PROCESSSEGMENTID 
								WHERE	1=1
					            -- (21.06.17) 속도개선 lot 처럼 변경함
				            	--AND		C.LOTID = A.LOTID
								AND		(
						          			-- (21.08.10) WORKENDTIME -> SENDTIME 변경
						          			(		B.PROCESSSEGMENTCLASSID = '7012'	
						          				AND	A.SENDTIME			-- (21.06.03  endtime로 다 변경)		A.WORKSTARTTIME 
						          				BETWEEN	TO_TIMESTAMP(#{P_PERIOD_PERIODFR}, 'YYYY-MM-DD HH24:MI:SS')	
									                					AND	TO_TIMESTAMP(#{P_PERIOD_PERIODTO}, 'YYYY-MM-DD HH24:MI:SS') 
					  						)
										)
							)
					<if test="P_LOTID != null and P_LOTID !='' and !(P_LOTID eq '*'.toString()) ">
						AND		C.LOTID = #{P_LOTID}
					</if>
					<if test="P_PRODUCTDEFID != null and P_PRODUCTDEFID !=''"> 
					  AND		C.PRODUCTDEFID = #{P_PRODUCTDEFID}
					</if>					
					<if test="P_PRODUCTDEFVERSION != null and P_PRODUCTDEFVERSION !='' and !(P_PRODUCTDEFVERSION eq '*'.toString()) ">
						AND		EXISTS
						(
							SELECT	1
							FROM	(SELECT DATA AS VALUE 
									  FROM TABLE(CAST(FN_TO_ROWS(#{P_PRODUCTDEFVERSION}) AS TP_SIMPLE_TABLE)) 
									) LMP
							WHERE	C.PRODUCTDEFVERSION = LMP.VALUE
						)
					</if>	
			)		
			
			-----------------------------(21.08.10) 인계 시간 조회
			, T_SENDTIME AS (
					SELECT	A.LOTID		
					, 			A.PROCESSSEGMENTID
					, 			MAX(A.SENDTIME) 		AS 	SENDTIME		       -- 인계 시간
					, 			B.PROCESSSEGMENTCLASSID
				FROM			PCM_LOTWORKRESULT				A
				INNER JOIN	BAS_PROCESSSEGMENT				B	
				ON  			A.PROCESSSEGMENTID = B.PROCESSSEGMENTID 
				AND 			B.PROCESSSEGMENTCLASSID IN ('7012','7014','7022')
				WHERE		1=1
				AND 			LOTID IN (
					SELECT LOTID
					  FROM LOTLIST
				)
				GROUP BY    A.LOTID		
					,       A.PROCESSSEGMENTID
					,       B.PROCESSSEGMENTCLASSID
			)
		-----------------------------
			
		SELECT
			  '0'    AS  CHK	
			, T.PROCESSSEGMENTID
			, T.PROCESSSEGMENTNAME				          
			, G.GROUPCODE
			, G.GROUPNAME
			, G.AFTERDEFECTCNT			AS GROUPCNT
			, G.AFTERDEFECTRATE		AS GROUPRATE				
			, S.SUBCODE
			, S.SUBNAME
			, S.AFTERDEFECTCNT		  AS SUBCNT
			, S.AFTERDEFECTRATE	  AS SUBRATE
			, T.AFTERDEFECTRATE	  AS SEGTOTRATE					
		FROM
		(
		SELECT	
				A.PROCESSSEGMENTID
			,   A.PROCESSSEGMENTNAME					
			,   SUM(NVL(A.DEFECTCOUNT,0)) - SUM(NVL(A.REPAIRRESULTQTY, 0)) AS AFTERDEFECTCNT
			,   ROUND(DECODE(MAX(NVL(A.INSPECTIONQTY,0)), 0, 0,  (SUM(NVL(A.DEFECTCOUNT,0)) - SUM(NVL(A.REPAIRRESULTQTY, 0)))/ MAX(NVL(A.INSPECTIONQTY,0))) * 100, 2)  AS AFTERDEFECTRATE       
			
               FROM
               (

			   SELECT
					A.PRODUCTDEFID
				,	A.PRODUCTDEFVERSION
				,	A.LOTID
				,	A.PROCESSSEGMENTID
				,	A.PROCESSSEGMENTNAME 
                ,	B.INSPECTIONQTY                
               ,    A.REPAIRTARGETQTY
               ,    A.REPAIRRESULTQTY 			
                ,  A.GROUPCODE
                ,  A.GROUPNAME
                ,  A.SUBCODE	 
                ,  A.SUBNAME
                ,  A.COLOR
                , A.DEFECTCOUNT
			   FROM
			   (
               SELECT                
					A.PRODUCTDEFID
				,	A.PRODUCTDEFVERSION
				,	A.LOTID
				,	A.PROCESSSEGMENTID
				,	DIC.DICTIONARYNAME 		AS PROCESSSEGMENTNAME 
                ,	A.INSPECTIONQTY                
               ,    A.REPAIRTARGETQTY
               ,    A.REPAIRRESULTQTY 			
			    ----------------------------------------------------------------(21.06.17)
                -- 블량 그룹 
                ,  (
                        CASE WHEN AOI.GROUPCODE = '005'  
                            THEN T_AFT_ANALYSIS.GROUPCODE
                            ELSE COALESCE(AOI.GROUPCODE, '999')
                            END
                    ) AS GROUPCODE
                -- 블량 그룹명 
                ,  (
                        CASE WHEN AOI.GROUPCODE = '005'  
                            THEN T_AFT_ANALYSIS.GROUPNAME
                            ELSE COALESCE(AOI.GROUPNAME, 'NONE')
                            END
                    ) AS GROUPNAME
                -- 불량 코드   
                ,	COALESCE(
                            CASE A.SEGMENTTYPE
                                WHEN 'AOIInspection' 
                                THEN (
                                       CASE WHEN AOI.GROUPCODE = '005'  
                                            THEN T_AFT_ANALYSIS.SUBCODE
                                            ELSE AOI.SUBCODE
                                            END 
                                    )
                                ELSE AOI.SUBCODE
                            END, '9999') 														AS	SUBCODE	 
                -- 불량 코드명
                ,	COALESCE(
                            CASE A.SEGMENTTYPE
                                WHEN 'AOIInspection' 
                                THEN (
                                       CASE WHEN AOI.GROUPCODE = '005'  
                                            THEN T_AFT_ANALYSIS.SUBNAME
                                            ELSE  AOI.SUBNAME
                                            END 
                                    )
                                ELSE AOI.SUBNAME
                            END, 'NONE')														AS	SUBNAME
                -- 불량 색상
                ,  COALESCE(
                            CASE A.SEGMENTTYPE
                                WHEN 'AOIInspection' 
                                THEN (
                                       CASE WHEN AOI.GROUPCODE = '005'  
                                            THEN T_AFT_ANALYSIS.COLOR
                                            ELSE AOI.COLOR
                                            END 
                                    )
                                ELSE AOI.COLOR
                            END, '#000000')														AS	COLOR
                    
                -- 불량 수량 
                , A.DEFECTCOUNT
               -----------------------------------------------------------------------------------------    
		FROM PCM_QCAOIBBTWORKCOMPLETE	A
			INNER JOIN LOTLIST 					L	ON	A.LOTID = L.LOTID
													AND	A.PRODUCTDEFID = L.PRODUCTDEFID
													AND	A.PRODUCTDEFVERSION = L.PRODUCTDEFVERSION				
            -- (21.06.17) 완료된 상태 체크   -> (21.06.18) 여러건 존재함 하나만 나오도록 수정
            INNER JOIN (SELECT RESOURCEID
                            ,  INSPECTIONDEFID  
                            , PROCESSSEGMENTID, PROCESSSEGMENTVERSION
                         FROM  QAM_INSPECTIONRESULT   
                         GROUP BY  RESOURCEID, INSPECTIONDEFID    
                                    , PROCESSSEGMENTID, PROCESSSEGMENTVERSION
                         ) Q_INSP
            ON Q_INSP.RESOURCEID                 		=  A.LOTID
            AND Q_INSP.INSPECTIONDEFID 					= 	'AOIInspection'
            AND Q_INSP.PROCESSSEGMENTID					= A.PROCESSSEGMENTID
            AND Q_INSP.PROCESSSEGMENTVERSION			= A.PROCESSSEGMENTVERSION
            -----------------------------------------------------------------   	
            LEFT OUTER JOIN (
					SELECT	GRP.CODEID								AS	GROUPCODE
						,	GRP.GROUPNAME							AS	GROUPNAME
						,	GRP.DESCRIPTION 							AS	COLOR
						,	SUB.CODEID									AS	SUBCODE
						,	SUB.SUBNAME								AS	SUBNAME
						,	'AOIInspection'								AS	SEGMENTTYPE
						,   '005'                                       	AS  CHK_G_CODE
                                    ,   (
                                        CASE WHEN SUB.CODEID = '1001'
                                             THEN '5001'
                                             ELSE '5002'
                                             END
                                    )   													AS CHK_S_CODE
					FROM	
					(
						SELECT 	C.LOOKUP_CODE   AS CODEID
							,	C.DESCRIPTION
							,	D.DICTIONARYNAME						AS	GROUPNAME
						FROM 	CMD_LOOKUP_VALUES									C
						LEFT OUTER JOIN		CMD_DICTIONARY	D			ON	C.DICTIONARYID = D.DICTIONARYID						           	   			   		    
						WHERE	C.LOOKUP_TYPE = 'DefectMapDefectGroup'
						AND		C.ENABLED_FLAG = 'Y'
						AND		D.LANGUAGETYPE = #{LANGUAGETYPE}        -- 다국어 코드
					) 					GRP
					LEFT OUTER JOIN		
					(
						SELECT	C.LOOKUP_CODE   AS CODEID
							,	D.DICTIONARYNAME						AS	SUBNAME
							,	C.PARENTCODEID
						FROM	CMD_LOOKUP_VALUES									C
						LEFT OUTER JOIN 	CMD_DICTIONARY	D			ON 	C.DICTIONARYID = D.DICTIONARYID
						WHERE	C.LOOKUP_TYPE = 'DefectMapDefectGroupSub'
						AND		C.ENABLED_FLAG = 'Y'
						AND		D.LANGUAGETYPE = #{LANGUAGETYPE}        -- 다국어 코드
					) 					SUB								ON	GRP.CODEID = SUB.PARENTCODEID
					WHERE 1 = 1
                              AND GRP.CODEID IN ('001','002')
                              AND SUB.CODEID IN ('1001','2001')
				)   T_AFT_ANALYSIS
            ON A.SEGMENTTYPE = T_AFT_ANALYSIS.SEGMENTTYPE 
            AND A.DEFECTCODE = T_AFT_ANALYSIS.CHK_S_CODE
-----------------------------------------------------------------   
		INNER JOIN	BAS_PROCESSSEGMENTEXT	C	ON A.PROCESSSEGMENTID = C.PROCESSSEGMENTID 
										  AND A.ENTERPRISEID = C.ENTERPRISEID                                   
		LEFT OUTER JOIN (	
						  SELECT	
								   'AOIInspection'                               	AS SEGMENTTYPE						  
						  	 	,   GRP.CODEID										AS GROUPCODE
								,	GRP.GROUPNAME								AS GROUPNAME
								,	GRP.DESCRIPTION 								AS COLOR
								,	SUB.CODEID										AS SUBCODE
								,	SUB.SUBNAME									AS SUBNAME
							FROM	
							(
								SELECT 	C.LOOKUP_CODE   AS CODEID
									,	C.DESCRIPTION
									,	D.DICTIONARYNAME						AS GROUPNAME
								FROM 	CMD_LOOKUP_VALUES									C
								LEFT OUTER JOIN		CMD_DICTIONARY	D	ON	C.DICTIONARYID = D.DICTIONARYID						           	   			   		    
								WHERE	C.LOOKUP_TYPE = 'DefectMapDefectGroup'
								AND		C.ENABLED_FLAG = 'Y'
								AND		D.LANGUAGETYPE = #{LANGUAGETYPE} 
							) 					GRP
							LEFT OUTER JOIN		
							(
								SELECT	C.LOOKUP_CODE AS CODEID
									,	D.DICTIONARYNAME						AS SUBNAME
									,	C.PARENTCODEID
								FROM	CMD_LOOKUP_VALUES									C
								LEFT OUTER JOIN 	CMD_DICTIONARY	D	ON 	C.DICTIONARYID = D.DICTIONARYID
								WHERE	C.LOOKUP_TYPE = 'DefectMapDefectGroupSub'
								AND		C.ENABLED_FLAG = 'Y'
								AND		D.LANGUAGETYPE = #{LANGUAGETYPE} 
							) 					
							SUB		ON GRP.CODEID = SUB.PARENTCODEID              
						) AOI		ON A.DEFECTCODE = AOI.SUBCODE
								   AND A.SEGMENTTYPE = AOI.SEGMENTTYPE							
        LEFT JOIN CMD_DICTIONARY         	DIC	ON	DIC.DICTIONARYID = C.PROCESSSEGMENTNAME
                                                AND DIC.LANGUAGETYPE = #{LANGUAGETYPE}
                                                
		---------------------------------[1]
		-- (21.07.12) 추가
        INNER JOIN BAS_PRODUCTDEFINITION E      ON 	A.PRODUCTDEFID = E.PRODUCTDEFID
											   AND  A.PRODUCTDEFVERSION  = E.PRODUCTDEFVERSION
		---------------------------------
		
		-----------------------------------(21.08.10) 인계 시간 조건 추가        
		LEFT JOIN T_SENDTIME TT 
				ON TT.LOTID             			= A.LOTID
			   AND TT.PROCESSSEGMENTID  	= A.PROCESSSEGMENTID
		-----------------------------

		WHERE 1 = 1
		  AND A.SEGMENTTYPE = 'AOIInspection'
		  AND A.ENTERPRISEID = #{P_ENTERPRISEID}
		  AND A.PLANTID = #{P_PLANTID}		  
		<if test="P_PERIOD_PERIODFR != null and P_PERIOD_PERIODFR !='' and P_PERIOD_PERIODTO != null and P_PERIOD_PERIODTO !=''">
		  
		  -- (21.08.10) 인계 시간 조건 추가 A.CREATEDTIME --> TT.SENDTIME
		  AND TT.SENDTIME <![CDATA[>=]]> TO_TIMESTAMP(SUBSTR(#{P_PERIOD_PERIODFR},1,14), 'YYYYMMDDHH24MISS')
		  AND TT.SENDTIME <![CDATA[<]]>  TO_TIMESTAMP(TO_CHAR(TO_DATE(SUBSTR(#{P_PERIOD_PERIODTO},1,8), 'YYYYMMDD'), 'YYYY-MM-DD') || ' ' || SUBSTR(#{P_PERIOD_PERIODTO}, 9, 6), 'YYYY-MM-DD HH24:MI:SS') 
		</if>
		<if test="LOTID_LIST.length != 0">
                AND		A.LOTID IN
	           <foreach collection="LOTID_LIST" item="item" index="index" separator="," open="(" close=")">
	                    #{item}
	           </foreach>				
		</if>	
		<if test="PROCESSSEGMENTID_LIST.length != 0">
                AND		A.PROCESSSEGMENTID IN
	           <foreach collection="PROCESSSEGMENTID_LIST" item="item" index="index" separator="," open="(" close=")">
	                    #{item}
	           </foreach>				
		</if>			
		<if test="PRODUCTDEFIDVER_LIST.length != 0">
                AND		A.PRODUCTDEFID || A.PRODUCTDEFVERSION IN
	           <foreach collection="PRODUCTDEFIDVER_LIST" item="item" index="index" separator="," open="(" close=")">
	                    #{item}
	           </foreach>				
		</if>
		<if test="P_AOIPROCESS != null and P_AOIPROCESS !=''">
		    -- AOI 공정
			AND	 EXISTS (SELECT 1 FROM ufn_selectStringToSplit(#{P_AOIPROCESS},',') WHERE value = A.PROCESSSEGMENTID) 
		</if>
		
		<if test="P_PRODUCTIONTYPE != null and P_PRODUCTIONTYPE !='' and !(P_PRODUCTIONTYPE eq '*'.toString()) ">
			-- (21.07.12) 생산구분 추가[1]
			AND 	E.PRODUCTIONTYPE 			= #{P_PRODUCTIONTYPE}
		</if>
		
		) A
		, 
		   (
		   SELECT
					A.SEGMENTTYPE    
                ,   A.PROCESSSEGMENTID
                ,   SUM(A.INSPECTIONQTY) AS INSPECTIONQTY
            FROM
           (
		   SELECT
					A.SEGMENTTYPE    
                ,   A.PROCESSSEGMENTID
                ,   A.LOTID
                ,	MAX(A.INSPECTIONQTY) AS INSPECTIONQTY	   
		FROM PCM_QCAOIBBTWORKCOMPLETE	A
			INNER JOIN LOTLIST 					L	ON	A.LOTID = L.LOTID
													AND	A.PRODUCTDEFID = L.PRODUCTDEFID
													AND	A.PRODUCTDEFVERSION = L.PRODUCTDEFVERSION				
            -- (21.06.17) 완료된 상태 체크   -> (21.06.18) 여러건 존재함 하나만 나오도록 수정
            INNER JOIN (SELECT RESOURCEID
                            ,  INSPECTIONDEFID  
                            , PROCESSSEGMENTID, PROCESSSEGMENTVERSION
                         FROM  QAM_INSPECTIONRESULT   
                         GROUP BY  RESOURCEID, INSPECTIONDEFID    
                                    , PROCESSSEGMENTID, PROCESSSEGMENTVERSION
                         ) Q_INSP
            ON Q_INSP.RESOURCEID                 		=  A.LOTID
            AND Q_INSP.INSPECTIONDEFID 					= 	'AOIInspection'
            AND Q_INSP.PROCESSSEGMENTID					= A.PROCESSSEGMENTID
            AND Q_INSP.PROCESSSEGMENTVERSION			= A.PROCESSSEGMENTVERSION
            -----------------------------------------------------------------   	
            LEFT OUTER JOIN (
					SELECT	GRP.CODEID								AS	GROUPCODE
						,	GRP.GROUPNAME							AS	GROUPNAME
						,	GRP.DESCRIPTION 							AS	COLOR
						,	SUB.CODEID									AS	SUBCODE
						,	SUB.SUBNAME								AS	SUBNAME
						,	'AOIInspection'								AS	SEGMENTTYPE
						,   '005'                                       	AS  CHK_G_CODE
                                    ,   (
                                        CASE WHEN SUB.CODEID = '1001'
                                             THEN '5001'
                                             ELSE '5002'
                                             END
                                    )   													AS CHK_S_CODE
					FROM	
					(
						SELECT 	C.LOOKUP_CODE   AS CODEID
							,	C.DESCRIPTION
							,	D.DICTIONARYNAME						AS	GROUPNAME
						FROM 	CMD_LOOKUP_VALUES									C
						LEFT OUTER JOIN		CMD_DICTIONARY	D			ON	C.DICTIONARYID = D.DICTIONARYID						           	   			   		    
						WHERE	C.LOOKUP_TYPE = 'DefectMapDefectGroup'
						AND		C.ENABLED_FLAG = 'Y'
						AND		D.LANGUAGETYPE = #{LANGUAGETYPE}        -- 다국어 코드
					) 					GRP
					LEFT OUTER JOIN		
					(
						SELECT	C.LOOKUP_CODE   AS CODEID
							,	D.DICTIONARYNAME						AS	SUBNAME
							,	C.PARENTCODEID
						FROM	CMD_LOOKUP_VALUES									C
						LEFT OUTER JOIN 	CMD_DICTIONARY	D			ON 	C.DICTIONARYID = D.DICTIONARYID
						WHERE	C.LOOKUP_TYPE = 'DefectMapDefectGroupSub'
						AND		C.ENABLED_FLAG = 'Y'
						AND		D.LANGUAGETYPE = #{LANGUAGETYPE}        -- 다국어 코드
					) 					SUB								ON	GRP.CODEID = SUB.PARENTCODEID
					WHERE 1 = 1
                              AND GRP.CODEID IN ('001','002')
                              AND SUB.CODEID IN ('1001','2001')
				)   T_AFT_ANALYSIS
            ON A.SEGMENTTYPE = T_AFT_ANALYSIS.SEGMENTTYPE 
            AND A.DEFECTCODE = T_AFT_ANALYSIS.CHK_S_CODE
-----------------------------------------------------------------   
		INNER JOIN	BAS_PROCESSSEGMENTEXT	C	ON A.PROCESSSEGMENTID = C.PROCESSSEGMENTID 
										  AND A.ENTERPRISEID = C.ENTERPRISEID                                   
		LEFT OUTER JOIN (	
						  SELECT	
								   'AOIInspection'                               	AS SEGMENTTYPE						  
						  	 	,   GRP.CODEID										AS GROUPCODE
								,	GRP.GROUPNAME								AS GROUPNAME
								,	GRP.DESCRIPTION 								AS COLOR
								,	SUB.CODEID										AS SUBCODE
								,	SUB.SUBNAME									AS SUBNAME
							FROM	
							(
								SELECT 	C.LOOKUP_CODE   AS CODEID
									,	C.DESCRIPTION
									,	D.DICTIONARYNAME						AS GROUPNAME
								FROM 	CMD_LOOKUP_VALUES									C
								LEFT OUTER JOIN		CMD_DICTIONARY	D	ON	C.DICTIONARYID = D.DICTIONARYID						           	   			   		    
								WHERE	C.LOOKUP_TYPE = 'DefectMapDefectGroup'
								AND		C.ENABLED_FLAG = 'Y'
								AND		D.LANGUAGETYPE = #{LANGUAGETYPE} 
							) 					GRP
							LEFT OUTER JOIN		
							(
								SELECT	C.LOOKUP_CODE AS CODEID
									,	D.DICTIONARYNAME						AS SUBNAME
									,	C.PARENTCODEID
								FROM	CMD_LOOKUP_VALUES									C
								LEFT OUTER JOIN 	CMD_DICTIONARY	D	ON 	C.DICTIONARYID = D.DICTIONARYID
								WHERE	C.LOOKUP_TYPE = 'DefectMapDefectGroupSub'
								AND		C.ENABLED_FLAG = 'Y'
								AND		D.LANGUAGETYPE = #{LANGUAGETYPE} 
							) 					
							SUB		ON GRP.CODEID = SUB.PARENTCODEID              
						) AOI		ON A.DEFECTCODE = AOI.SUBCODE
								   AND A.SEGMENTTYPE = AOI.SEGMENTTYPE							
        LEFT JOIN CMD_DICTIONARY         	DIC	ON	DIC.DICTIONARYID = C.PROCESSSEGMENTNAME
                                                AND DIC.LANGUAGETYPE = #{LANGUAGETYPE}      	

		---------------------------------[2]
		-- (21.07.12) 추가
        INNER JOIN BAS_PRODUCTDEFINITION E      ON 	A.PRODUCTDEFID = E.PRODUCTDEFID
											   AND  A.PRODUCTDEFVERSION  = E.PRODUCTDEFVERSION
		---------------------------------  
		-----------------------------------(21.08.10) 인계 시간 조건 추가        
		LEFT JOIN T_SENDTIME TT 
				ON TT.LOTID             			= A.LOTID
			   AND TT.PROCESSSEGMENTID  	= A.PROCESSSEGMENTID
		-----------------------------                                              
                                                

		WHERE 1 = 1
		  AND A.SEGMENTTYPE = 'AOIInspection'
		  AND A.ENTERPRISEID = #{P_ENTERPRISEID}
		  AND A.PLANTID = #{P_PLANTID}		  
		<if test="P_PERIOD_PERIODFR != null and P_PERIOD_PERIODFR !='' and P_PERIOD_PERIODTO != null and P_PERIOD_PERIODTO !=''">
		  -- (21.08.10) 인계 시간 조건 추가  A.CREATEDTIME --> TT.SENDTIME
		  AND TT.SENDTIME <![CDATA[>=]]> TO_TIMESTAMP(SUBSTR(#{P_PERIOD_PERIODFR},1,14), 'YYYYMMDDHH24MISS')
		  AND TT.SENDTIME <![CDATA[<]]>  TO_TIMESTAMP(TO_CHAR(TO_DATE(SUBSTR(#{P_PERIOD_PERIODTO},1,8), 'YYYYMMDD'), 'YYYY-MM-DD') || ' ' || SUBSTR(#{P_PERIOD_PERIODTO}, 9, 6), 'YYYY-MM-DD HH24:MI:SS') 
		</if>
		<if test="LOTID_LIST.length != 0">
                AND		A.LOTID IN
	           <foreach collection="LOTID_LIST" item="item" index="index" separator="," open="(" close=")">
	                    #{item}
	           </foreach>				
		</if>	
		<if test="PROCESSSEGMENTID_LIST.length != 0">
                AND		A.PROCESSSEGMENTID IN
	           <foreach collection="PROCESSSEGMENTID_LIST" item="item" index="index" separator="," open="(" close=")">
	                    #{item}
	           </foreach>				
		</if>			
		<if test="PRODUCTDEFIDVER_LIST.length != 0">
                AND		A.PRODUCTDEFID || A.PRODUCTDEFVERSION IN
	           <foreach collection="PRODUCTDEFIDVER_LIST" item="item" index="index" separator="," open="(" close=")">
	                    #{item}
	           </foreach>				
		</if>
		<if test="P_AOIPROCESS != null and P_AOIPROCESS !=''">
		    -- AOI 공정
			AND	 EXISTS (SELECT 1 FROM ufn_selectStringToSplit(#{P_AOIPROCESS},',') WHERE value = A.PROCESSSEGMENTID) 
		</if>
		
		<if test="P_PRODUCTIONTYPE != null and P_PRODUCTIONTYPE !='' and !(P_PRODUCTIONTYPE eq '*'.toString()) ">
			-- (21.07.12) 생산구분 추가[2]
			AND 	E.PRODUCTIONTYPE 			= #{P_PRODUCTIONTYPE}
		</if>
		
        GROUP BY 
		 			A.SEGMENTTYPE    
                ,   A.PROCESSSEGMENTID
                ,   A.LOTID
        ) A
        GROUP BY 
		 			A.SEGMENTTYPE    
                ,   A.PROCESSSEGMENTID 
	    ) B
		WHERE A.PROCESSSEGMENTID = B.PROCESSSEGMENTID
		) A
            GROUP BY 
					A.PROCESSSEGMENTID
				,   A.PROCESSSEGMENTNAME	            													
		   )	  T  -- PROCESSSEGMENTNAME			
		  , (
				SELECT	
						A.PROCESSSEGMENTID
					,   A.PROCESSSEGMENTNAME		
					,	A.GROUPCODE
					,	A.GROUPNAME			
					,   SUM(NVL(A.DEFECTCOUNT,0)) - SUM(NVL(A.REPAIRRESULTQTY, 0)) AS AFTERDEFECTCNT
					,   ROUND(DECODE(MAX(NVL(A.INSPECTIONQTY,0)), 0, 0,  (SUM(NVL(A.DEFECTCOUNT,0)) - SUM(NVL(A.REPAIRRESULTQTY, 0)))/ MAX(NVL(A.INSPECTIONQTY,0))) * 100, 2)  AS AFTERDEFECTRATE          
               FROM
               (
			   SELECT
					A.PRODUCTDEFID
				,	A.PRODUCTDEFVERSION
				,	A.LOTID
				,	A.PROCESSSEGMENTID
				,	A.PROCESSSEGMENTNAME 
                ,	B.INSPECTIONQTY                
               ,    A.REPAIRTARGETQTY
               ,    A.REPAIRRESULTQTY 			
                ,  A.GROUPCODE
                ,  A.GROUPNAME
                ,  A.SUBCODE	 
                ,  A.SUBNAME
                ,  A.COLOR
                , A.DEFECTCOUNT
			   FROM
			   (
               SELECT                
					A.PRODUCTDEFID
				,	A.PRODUCTDEFVERSION
				,	A.LOTID
				,	A.PROCESSSEGMENTID
				,	DIC.DICTIONARYNAME 		AS PROCESSSEGMENTNAME 
                ,	A.INSPECTIONQTY                
               ,    A.REPAIRTARGETQTY
               ,    A.REPAIRRESULTQTY 			
			    ----------------------------------------------------------------(21.06.17)
                -- 블량 그룹 
                ,  (
                        CASE WHEN AOI.GROUPCODE = '005'  
                            THEN T_AFT_ANALYSIS.GROUPCODE
                            ELSE COALESCE(AOI.GROUPCODE, '999')
                            END
                    ) AS GROUPCODE
                -- 블량 그룹명 
                ,  (
                        CASE WHEN AOI.GROUPCODE = '005'  
                            THEN T_AFT_ANALYSIS.GROUPNAME
                            ELSE COALESCE(AOI.GROUPNAME, 'NONE')
                            END
                    ) AS GROUPNAME
                -- 불량 코드   
                ,	COALESCE(
                            CASE A.SEGMENTTYPE
                                WHEN 'AOIInspection' 
                                THEN (
                                       CASE WHEN AOI.GROUPCODE = '005'  
                                            THEN T_AFT_ANALYSIS.SUBCODE
                                            ELSE AOI.SUBCODE
                                            END 
                                    )
                                ELSE AOI.SUBCODE
                            END, '9999') 														AS	SUBCODE	 
                -- 불량 코드명
                ,	COALESCE(
                            CASE A.SEGMENTTYPE
                                WHEN 'AOIInspection' 
                                THEN (
                                       CASE WHEN AOI.GROUPCODE = '005'  
                                            THEN T_AFT_ANALYSIS.SUBNAME
                                            ELSE  AOI.SUBNAME
                                            END 
                                    )
                                ELSE AOI.SUBNAME
                            END, 'NONE')														AS	SUBNAME
                -- 불량 색상
                ,  COALESCE(
                            CASE A.SEGMENTTYPE
                                WHEN 'AOIInspection' 
                                THEN (
                                       CASE WHEN AOI.GROUPCODE = '005'  
                                            THEN T_AFT_ANALYSIS.COLOR
                                            ELSE AOI.COLOR
                                            END 
                                    )
                                ELSE AOI.COLOR
                            END, '#000000')														AS	COLOR
                    
                -- 불량 수량 
                , A.DEFECTCOUNT
               -----------------------------------------------------------------------------------------    
		FROM PCM_QCAOIBBTWORKCOMPLETE	A
			INNER JOIN LOTLIST 					L	ON	A.LOTID = L.LOTID
													AND	A.PRODUCTDEFID = L.PRODUCTDEFID
													AND	A.PRODUCTDEFVERSION = L.PRODUCTDEFVERSION				
            -- (21.06.17) 완료된 상태 체크   -> (21.06.18) 여러건 존재함 하나만 나오도록 수정
            INNER JOIN (SELECT RESOURCEID
                            ,  INSPECTIONDEFID  
                            , PROCESSSEGMENTID, PROCESSSEGMENTVERSION
                         FROM  QAM_INSPECTIONRESULT   
                         GROUP BY  RESOURCEID, INSPECTIONDEFID    
                                    , PROCESSSEGMENTID, PROCESSSEGMENTVERSION
                         ) Q_INSP
            ON Q_INSP.RESOURCEID                 		=  A.LOTID
            AND Q_INSP.INSPECTIONDEFID 					= 	'AOIInspection'
            AND Q_INSP.PROCESSSEGMENTID					= A.PROCESSSEGMENTID
            AND Q_INSP.PROCESSSEGMENTVERSION			= A.PROCESSSEGMENTVERSION
            -----------------------------------------------------------------   	
            LEFT OUTER JOIN (
					SELECT	GRP.CODEID								AS	GROUPCODE
						,	GRP.GROUPNAME							AS	GROUPNAME
						,	GRP.DESCRIPTION 							AS	COLOR
						,	SUB.CODEID									AS	SUBCODE
						,	SUB.SUBNAME								AS	SUBNAME
						,	'AOIInspection'								AS	SEGMENTTYPE
						,   '005'                                       	AS  CHK_G_CODE
                                    ,   (
                                        CASE WHEN SUB.CODEID = '1001'
                                             THEN '5001'
                                             ELSE '5002'
                                             END
                                    )   													AS CHK_S_CODE
					FROM	
					(
						SELECT 	C.LOOKUP_CODE   AS CODEID
							,	C.DESCRIPTION
							,	D.DICTIONARYNAME						AS	GROUPNAME
						FROM 	CMD_LOOKUP_VALUES									C
						LEFT OUTER JOIN		CMD_DICTIONARY	D			ON	C.DICTIONARYID = D.DICTIONARYID						           	   			   		    
						WHERE	C.LOOKUP_TYPE = 'DefectMapDefectGroup'
						AND		C.ENABLED_FLAG = 'Y'
						AND		D.LANGUAGETYPE = #{LANGUAGETYPE}        -- 다국어 코드
					) 					GRP
					LEFT OUTER JOIN		
					(
						SELECT	C.LOOKUP_CODE   AS CODEID
							,	D.DICTIONARYNAME						AS	SUBNAME
							,	C.PARENTCODEID
						FROM	CMD_LOOKUP_VALUES									C
						LEFT OUTER JOIN 	CMD_DICTIONARY	D			ON 	C.DICTIONARYID = D.DICTIONARYID
						WHERE	C.LOOKUP_TYPE = 'DefectMapDefectGroupSub'
						AND		C.ENABLED_FLAG = 'Y'
						AND		D.LANGUAGETYPE = #{LANGUAGETYPE}        -- 다국어 코드
					) 					SUB								ON	GRP.CODEID = SUB.PARENTCODEID
					WHERE 1 = 1
                              AND GRP.CODEID IN ('001','002')
                              AND SUB.CODEID IN ('1001','2001')
				)   T_AFT_ANALYSIS
            ON A.SEGMENTTYPE = T_AFT_ANALYSIS.SEGMENTTYPE 
            AND A.DEFECTCODE = T_AFT_ANALYSIS.CHK_S_CODE
-----------------------------------------------------------------   
		INNER JOIN	BAS_PROCESSSEGMENTEXT	C	ON A.PROCESSSEGMENTID = C.PROCESSSEGMENTID 
										  AND A.ENTERPRISEID = C.ENTERPRISEID                                   
		LEFT OUTER JOIN (	
						  SELECT	
								   'AOIInspection'                               	AS SEGMENTTYPE						  
						  	 	,   GRP.CODEID										AS GROUPCODE
								,	GRP.GROUPNAME								AS GROUPNAME
								,	GRP.DESCRIPTION 								AS COLOR
								,	SUB.CODEID										AS SUBCODE
								,	SUB.SUBNAME									AS SUBNAME
							FROM	
							(
								SELECT 	C.LOOKUP_CODE   AS CODEID
									,	C.DESCRIPTION
									,	D.DICTIONARYNAME						AS GROUPNAME
								FROM 	CMD_LOOKUP_VALUES									C
								LEFT OUTER JOIN		CMD_DICTIONARY	D	ON	C.DICTIONARYID = D.DICTIONARYID						           	   			   		    
								WHERE	C.LOOKUP_TYPE = 'DefectMapDefectGroup'
								AND		C.ENABLED_FLAG = 'Y'
								AND		D.LANGUAGETYPE = #{LANGUAGETYPE} 
							) 					GRP
							LEFT OUTER JOIN		
							(
								SELECT	C.LOOKUP_CODE AS CODEID
									,	D.DICTIONARYNAME						AS SUBNAME
									,	C.PARENTCODEID
								FROM	CMD_LOOKUP_VALUES									C
								LEFT OUTER JOIN 	CMD_DICTIONARY	D	ON 	C.DICTIONARYID = D.DICTIONARYID
								WHERE	C.LOOKUP_TYPE = 'DefectMapDefectGroupSub'
								AND		C.ENABLED_FLAG = 'Y'
								AND		D.LANGUAGETYPE = #{LANGUAGETYPE} 
							) 					
							SUB		ON GRP.CODEID = SUB.PARENTCODEID              
						) AOI		ON A.DEFECTCODE = AOI.SUBCODE
								   AND A.SEGMENTTYPE = AOI.SEGMENTTYPE							
        LEFT JOIN CMD_DICTIONARY         	DIC	ON	DIC.DICTIONARYID = C.PROCESSSEGMENTNAME
                                                AND DIC.LANGUAGETYPE = #{LANGUAGETYPE}  
                                                
		---------------------------------[3]
		-- (21.07.12) 추가
        INNER JOIN BAS_PRODUCTDEFINITION E      ON 	A.PRODUCTDEFID = E.PRODUCTDEFID
											   AND  A.PRODUCTDEFVERSION  = E.PRODUCTDEFVERSION
		---------------------------------
		
		-----------------------------------(21.08.10) 인계 시간 조건 추가        
		LEFT JOIN T_SENDTIME TT 
				ON TT.LOTID             			= A.LOTID
			   AND TT.PROCESSSEGMENTID  	= A.PROCESSSEGMENTID
		-----------------------------

		WHERE 1 = 1
		  AND A.SEGMENTTYPE = 'AOIInspection'
		  AND A.ENTERPRISEID = #{P_ENTERPRISEID}
		  AND A.PLANTID = #{P_PLANTID}		  
		<if test="P_PERIOD_PERIODFR != null and P_PERIOD_PERIODFR !='' and P_PERIOD_PERIODTO != null and P_PERIOD_PERIODTO !=''">
		  -- (21.08.10) 인계 시간 조건 추가  A.CREATEDTIME --> TT.SENDTIME
		  AND TT.SENDTIME <![CDATA[>=]]> TO_TIMESTAMP(SUBSTR(#{P_PERIOD_PERIODFR},1,14), 'YYYYMMDDHH24MISS')
		  AND TT.SENDTIME <![CDATA[<]]>  TO_TIMESTAMP(TO_CHAR(TO_DATE(SUBSTR(#{P_PERIOD_PERIODTO},1,8), 'YYYYMMDD'), 'YYYY-MM-DD') || ' ' || SUBSTR(#{P_PERIOD_PERIODTO}, 9, 6), 'YYYY-MM-DD HH24:MI:SS') 
		</if>
		<if test="LOTID_LIST.length != 0">
                AND		A.LOTID IN
	           <foreach collection="LOTID_LIST" item="item" index="index" separator="," open="(" close=")">
	                    #{item}
	           </foreach>				
		</if>	
		<if test="PROCESSSEGMENTID_LIST.length != 0">
                AND		A.PROCESSSEGMENTID IN
	           <foreach collection="PROCESSSEGMENTID_LIST" item="item" index="index" separator="," open="(" close=")">
	                    #{item}
	           </foreach>				
		</if>			
		<if test="PRODUCTDEFIDVER_LIST.length != 0">
                AND		A.PRODUCTDEFID || A.PRODUCTDEFVERSION IN
	           <foreach collection="PRODUCTDEFIDVER_LIST" item="item" index="index" separator="," open="(" close=")">
	                    #{item}
	           </foreach>				
		</if>
		<if test="P_AOIPROCESS != null and P_AOIPROCESS !=''">
		    -- AOI 공정
			AND	 EXISTS (SELECT 1 FROM ufn_selectStringToSplit(#{P_AOIPROCESS},',') WHERE value = A.PROCESSSEGMENTID) 
		</if>
		
		<if test="P_PRODUCTIONTYPE != null and P_PRODUCTIONTYPE !='' and !(P_PRODUCTIONTYPE eq '*'.toString()) ">
			-- (21.07.12) 생산구분 추가[3]
			AND 	E.PRODUCTIONTYPE 			= #{P_PRODUCTIONTYPE}
		</if>
		
		) A
		, 
		   (
		   SELECT
					A.SEGMENTTYPE    
                ,   A.PROCESSSEGMENTID
                ,   SUM(A.INSPECTIONQTY) AS INSPECTIONQTY
            FROM
           (
		   SELECT
					A.SEGMENTTYPE    
                ,   A.PROCESSSEGMENTID
                ,   A.LOTID
                ,	MAX(A.INSPECTIONQTY) AS INSPECTIONQTY	   
		FROM PCM_QCAOIBBTWORKCOMPLETE	A
			INNER JOIN LOTLIST 					L	ON	A.LOTID = L.LOTID
													AND	A.PRODUCTDEFID = L.PRODUCTDEFID
													AND	A.PRODUCTDEFVERSION = L.PRODUCTDEFVERSION				
            -- (21.06.17) 완료된 상태 체크   -> (21.06.18) 여러건 존재함 하나만 나오도록 수정
            INNER JOIN (SELECT RESOURCEID
                            ,  INSPECTIONDEFID  
                            , PROCESSSEGMENTID, PROCESSSEGMENTVERSION
                         FROM  QAM_INSPECTIONRESULT   
                         GROUP BY  RESOURCEID, INSPECTIONDEFID    
                                    , PROCESSSEGMENTID, PROCESSSEGMENTVERSION
                         ) Q_INSP
            ON Q_INSP.RESOURCEID                 		=  A.LOTID
            AND Q_INSP.INSPECTIONDEFID 					= 	'AOIInspection'
            AND Q_INSP.PROCESSSEGMENTID					= A.PROCESSSEGMENTID
            AND Q_INSP.PROCESSSEGMENTVERSION			= A.PROCESSSEGMENTVERSION
            -----------------------------------------------------------------   	
            LEFT OUTER JOIN (
					SELECT	GRP.CODEID								AS	GROUPCODE
						,	GRP.GROUPNAME							AS	GROUPNAME
						,	GRP.DESCRIPTION 							AS	COLOR
						,	SUB.CODEID									AS	SUBCODE
						,	SUB.SUBNAME								AS	SUBNAME
						,	'AOIInspection'								AS	SEGMENTTYPE
						,   '005'                                       	AS  CHK_G_CODE
                                    ,   (
                                        CASE WHEN SUB.CODEID = '1001'
                                             THEN '5001'
                                             ELSE '5002'
                                             END
                                    )   													AS CHK_S_CODE
					FROM	
					(
						SELECT 	C.LOOKUP_CODE   AS CODEID
							,	C.DESCRIPTION
							,	D.DICTIONARYNAME						AS	GROUPNAME
						FROM 	CMD_LOOKUP_VALUES									C
						LEFT OUTER JOIN		CMD_DICTIONARY	D			ON	C.DICTIONARYID = D.DICTIONARYID						           	   			   		    
						WHERE	C.LOOKUP_TYPE = 'DefectMapDefectGroup'
						AND		C.ENABLED_FLAG = 'Y'
						AND		D.LANGUAGETYPE = #{LANGUAGETYPE}        -- 다국어 코드
					) 					GRP
					LEFT OUTER JOIN		
					(
						SELECT	C.LOOKUP_CODE   AS CODEID
							,	D.DICTIONARYNAME						AS	SUBNAME
							,	C.PARENTCODEID
						FROM	CMD_LOOKUP_VALUES									C
						LEFT OUTER JOIN 	CMD_DICTIONARY	D			ON 	C.DICTIONARYID = D.DICTIONARYID
						WHERE	C.LOOKUP_TYPE = 'DefectMapDefectGroupSub'
						AND		C.ENABLED_FLAG = 'Y'
						AND		D.LANGUAGETYPE = #{LANGUAGETYPE}        -- 다국어 코드
					) 					SUB								ON	GRP.CODEID = SUB.PARENTCODEID
					WHERE 1 = 1
                              AND GRP.CODEID IN ('001','002')
                              AND SUB.CODEID IN ('1001','2001')
				)   T_AFT_ANALYSIS
            ON A.SEGMENTTYPE = T_AFT_ANALYSIS.SEGMENTTYPE 
            AND A.DEFECTCODE = T_AFT_ANALYSIS.CHK_S_CODE
-----------------------------------------------------------------   
		INNER JOIN	BAS_PROCESSSEGMENTEXT	C	ON A.PROCESSSEGMENTID = C.PROCESSSEGMENTID 
										  AND A.ENTERPRISEID = C.ENTERPRISEID                                   
		LEFT OUTER JOIN (	
						  SELECT	
								   'AOIInspection'                               	AS SEGMENTTYPE						  
						  	 	,   GRP.CODEID										AS GROUPCODE
								,	GRP.GROUPNAME								AS GROUPNAME
								,	GRP.DESCRIPTION 								AS COLOR
								,	SUB.CODEID										AS SUBCODE
								,	SUB.SUBNAME									AS SUBNAME
							FROM	
							(
								SELECT 	C.LOOKUP_CODE   AS CODEID
									,	C.DESCRIPTION
									,	D.DICTIONARYNAME						AS GROUPNAME
								FROM 	CMD_LOOKUP_VALUES									C
								LEFT OUTER JOIN		CMD_DICTIONARY	D	ON	C.DICTIONARYID = D.DICTIONARYID						           	   			   		    
								WHERE	C.LOOKUP_TYPE = 'DefectMapDefectGroup'
								AND		C.ENABLED_FLAG = 'Y'
								AND		D.LANGUAGETYPE = #{LANGUAGETYPE} 
							) 					GRP
							LEFT OUTER JOIN		
							(
								SELECT	C.LOOKUP_CODE AS CODEID
									,	D.DICTIONARYNAME						AS SUBNAME
									,	C.PARENTCODEID
								FROM	CMD_LOOKUP_VALUES									C
								LEFT OUTER JOIN 	CMD_DICTIONARY	D	ON 	C.DICTIONARYID = D.DICTIONARYID
								WHERE	C.LOOKUP_TYPE = 'DefectMapDefectGroupSub'
								AND		C.ENABLED_FLAG = 'Y'
								AND		D.LANGUAGETYPE = #{LANGUAGETYPE} 
							) 					
							SUB		ON GRP.CODEID = SUB.PARENTCODEID              
						) AOI		ON A.DEFECTCODE = AOI.SUBCODE
								   AND A.SEGMENTTYPE = AOI.SEGMENTTYPE							
        LEFT JOIN CMD_DICTIONARY         	DIC	ON	DIC.DICTIONARYID = C.PROCESSSEGMENTNAME
                                                AND DIC.LANGUAGETYPE = #{LANGUAGETYPE}    
                                                
		---------------------------------[4]
		-- (21.07.12) 추가
        INNER JOIN BAS_PRODUCTDEFINITION E      ON 	A.PRODUCTDEFID = E.PRODUCTDEFID
											   AND  A.PRODUCTDEFVERSION  = E.PRODUCTDEFVERSION
		---------------------------------               
		-----------------------------------(21.08.10) 인계 시간 조건 추가        
		LEFT JOIN T_SENDTIME TT 
				ON TT.LOTID             			= A.LOTID
			   AND TT.PROCESSSEGMENTID  	= A.PROCESSSEGMENTID
		-----------------------------                                 
                                                
  	                                                												
		WHERE 1 = 1
		  AND A.SEGMENTTYPE = 'AOIInspection'
		  AND A.ENTERPRISEID = #{P_ENTERPRISEID}
		  AND A.PLANTID = #{P_PLANTID}		  
		<if test="P_PERIOD_PERIODFR != null and P_PERIOD_PERIODFR !='' and P_PERIOD_PERIODTO != null and P_PERIOD_PERIODTO !=''">
		  -- (21.08.10) 인계 시간 조건 추가  A.CREATEDTIME --> TT.SENDTIME
		  AND TT.SENDTIME <![CDATA[>=]]> TO_TIMESTAMP(SUBSTR(#{P_PERIOD_PERIODFR},1,14), 'YYYYMMDDHH24MISS')
		  AND TT.SENDTIME <![CDATA[<]]>  TO_TIMESTAMP(TO_CHAR(TO_DATE(SUBSTR(#{P_PERIOD_PERIODTO},1,8), 'YYYYMMDD'), 'YYYY-MM-DD') || ' ' || SUBSTR(#{P_PERIOD_PERIODTO}, 9, 6), 'YYYY-MM-DD HH24:MI:SS') 
		</if>
		<if test="LOTID_LIST.length != 0">
                AND		A.LOTID IN
	           <foreach collection="LOTID_LIST" item="item" index="index" separator="," open="(" close=")">
	                    #{item}
	           </foreach>				
		</if>	
		<if test="PROCESSSEGMENTID_LIST.length != 0">
                AND		A.PROCESSSEGMENTID IN
	           <foreach collection="PROCESSSEGMENTID_LIST" item="item" index="index" separator="," open="(" close=")">
	                    #{item}
	           </foreach>				
		</if>			
		<if test="PRODUCTDEFIDVER_LIST.length != 0">
                AND		A.PRODUCTDEFID || A.PRODUCTDEFVERSION IN
	           <foreach collection="PRODUCTDEFIDVER_LIST" item="item" index="index" separator="," open="(" close=")">
	                    #{item}
	           </foreach>				
		</if>
		<if test="P_AOIPROCESS != null and P_AOIPROCESS !=''">
		    -- AOI 공정
			AND	 EXISTS (SELECT 1 FROM ufn_selectStringToSplit(#{P_AOIPROCESS},',') WHERE value = A.PROCESSSEGMENTID) 
		</if>
		
		<if test="P_PRODUCTIONTYPE != null and P_PRODUCTIONTYPE !='' and !(P_PRODUCTIONTYPE eq '*'.toString()) ">
			-- (21.07.12) 생산구분 추가[4]
			AND 	E.PRODUCTIONTYPE 			= #{P_PRODUCTIONTYPE}
		</if>
		
		
        GROUP BY 
		 			A.SEGMENTTYPE    
                ,   A.PROCESSSEGMENTID
                ,   A.LOTID
        ) A
        GROUP BY 
		 			A.SEGMENTTYPE    
                ,   A.PROCESSSEGMENTID 
	    ) B
		WHERE A.PROCESSSEGMENTID = B.PROCESSSEGMENTID
			) A
            GROUP BY 
					A.PROCESSSEGMENTID
				,   A.PROCESSSEGMENTNAME          
				,	A.GROUPCODE					
				,	A.GROUPNAME														
		   )	  G -- GROUPCODE	
         , (
				SELECT	
					A.PROCESSSEGMENTID
				,   A.PROCESSSEGMENTNAME				
				,	A.GROUPCODE
				,	A.GROUPNAME
				,	A.SUBCODE	
				,	A.SUBNAME				
               ,    SUM(NVL(A.DEFECTCOUNT,0)) - SUM(NVL(A.REPAIRRESULTQTY, 0)) AS AFTERDEFECTCNT
               ,    ROUND(DECODE(MAX(NVL(A.INSPECTIONQTY,0)), 0, 0,  (SUM(NVL(A.DEFECTCOUNT,0)) - SUM(NVL(A.REPAIRRESULTQTY, 0)))/ MAX(NVL(A.INSPECTIONQTY,0))) * 100, 2) AS AFTERDEFECTRATE     
               FROM
               (
 			   SELECT
					A.PRODUCTDEFID
				,	A.PRODUCTDEFVERSION
				,	A.LOTID
				,	A.PROCESSSEGMENTID
				,	A.PROCESSSEGMENTNAME 
                ,	B.INSPECTIONQTY                
               ,    A.REPAIRTARGETQTY
               ,    A.REPAIRRESULTQTY 			
                ,  A.GROUPCODE
                ,  A.GROUPNAME
                ,  A.SUBCODE	 
                ,  A.SUBNAME
                ,  A.COLOR
                , A.DEFECTCOUNT
			   FROM
			   (
               SELECT                
					A.PRODUCTDEFID
				,	A.PRODUCTDEFVERSION
				,	A.LOTID
				,	A.PROCESSSEGMENTID
				,	DIC.DICTIONARYNAME 		AS PROCESSSEGMENTNAME 
                ,	A.INSPECTIONQTY                
               ,    A.REPAIRTARGETQTY
               ,    A.REPAIRRESULTQTY 			
			    ----------------------------------------------------------------(21.06.17)
                -- 블량 그룹 
                ,  (
                        CASE WHEN AOI.GROUPCODE = '005'  
                            THEN T_AFT_ANALYSIS.GROUPCODE
                            ELSE COALESCE(AOI.GROUPCODE, '999')
                            END
                    ) AS GROUPCODE
                -- 블량 그룹명 
                ,  (
                        CASE WHEN AOI.GROUPCODE = '005'  
                            THEN T_AFT_ANALYSIS.GROUPNAME
                            ELSE COALESCE(AOI.GROUPNAME, 'NONE')
                            END
                    ) AS GROUPNAME
                -- 불량 코드   
                ,	COALESCE(
                            CASE A.SEGMENTTYPE
                                WHEN 'AOIInspection' 
                                THEN (
                                       CASE WHEN AOI.GROUPCODE = '005'  
                                            THEN T_AFT_ANALYSIS.SUBCODE
                                            ELSE AOI.SUBCODE
                                            END 
                                    )
                                ELSE AOI.SUBCODE
                            END, '9999') 														AS	SUBCODE	 
                -- 불량 코드명
                ,	COALESCE(
                            CASE A.SEGMENTTYPE
                                WHEN 'AOIInspection' 
                                THEN (
                                       CASE WHEN AOI.GROUPCODE = '005'  
                                            THEN T_AFT_ANALYSIS.SUBNAME
                                            ELSE  AOI.SUBNAME
                                            END 
                                    )
                                ELSE AOI.SUBNAME
                            END, 'NONE')														AS	SUBNAME
                -- 불량 색상
                ,  COALESCE(
                            CASE A.SEGMENTTYPE
                                WHEN 'AOIInspection' 
                                THEN (
                                       CASE WHEN AOI.GROUPCODE = '005'  
                                            THEN T_AFT_ANALYSIS.COLOR
                                            ELSE AOI.COLOR
                                            END 
                                    )
                                ELSE AOI.COLOR
                            END, '#000000')														AS	COLOR
                    
                -- 불량 수량 
                , A.DEFECTCOUNT
               -----------------------------------------------------------------------------------------    
		FROM PCM_QCAOIBBTWORKCOMPLETE	A
			INNER JOIN LOTLIST 					L	ON	A.LOTID = L.LOTID
													AND	A.PRODUCTDEFID = L.PRODUCTDEFID
													AND	A.PRODUCTDEFVERSION = L.PRODUCTDEFVERSION				
            -- (21.06.17) 완료된 상태 체크   -> (21.06.18) 여러건 존재함 하나만 나오도록 수정
            INNER JOIN (SELECT RESOURCEID
                            ,  INSPECTIONDEFID  
                            , PROCESSSEGMENTID, PROCESSSEGMENTVERSION
                         FROM  QAM_INSPECTIONRESULT   
                         GROUP BY  RESOURCEID, INSPECTIONDEFID    
                                    , PROCESSSEGMENTID, PROCESSSEGMENTVERSION
                         ) Q_INSP
            ON Q_INSP.RESOURCEID                 		=  A.LOTID
            AND Q_INSP.INSPECTIONDEFID 					= 	'AOIInspection'
            AND Q_INSP.PROCESSSEGMENTID					= A.PROCESSSEGMENTID
            AND Q_INSP.PROCESSSEGMENTVERSION			= A.PROCESSSEGMENTVERSION
            -----------------------------------------------------------------   	
            LEFT OUTER JOIN (
					SELECT	GRP.CODEID								AS	GROUPCODE
						,	GRP.GROUPNAME							AS	GROUPNAME
						,	GRP.DESCRIPTION 							AS	COLOR
						,	SUB.CODEID									AS	SUBCODE
						,	SUB.SUBNAME								AS	SUBNAME
						,	'AOIInspection'								AS	SEGMENTTYPE
						,   '005'                                       	AS  CHK_G_CODE
                                    ,   (
                                        CASE WHEN SUB.CODEID = '1001'
                                             THEN '5001'
                                             ELSE '5002'
                                             END
                                    )   													AS CHK_S_CODE
					FROM	
					(
						SELECT 	C.LOOKUP_CODE   AS CODEID
							,	C.DESCRIPTION
							,	D.DICTIONARYNAME						AS	GROUPNAME
						FROM 	CMD_LOOKUP_VALUES									C
						LEFT OUTER JOIN		CMD_DICTIONARY	D			ON	C.DICTIONARYID = D.DICTIONARYID						           	   			   		    
						WHERE	C.LOOKUP_TYPE = 'DefectMapDefectGroup'
						AND		C.ENABLED_FLAG = 'Y'
						AND		D.LANGUAGETYPE = #{LANGUAGETYPE}        -- 다국어 코드
					) 					GRP
					LEFT OUTER JOIN		
					(
						SELECT	C.LOOKUP_CODE   AS CODEID
							,	D.DICTIONARYNAME						AS	SUBNAME
							,	C.PARENTCODEID
						FROM	CMD_LOOKUP_VALUES									C
						LEFT OUTER JOIN 	CMD_DICTIONARY	D			ON 	C.DICTIONARYID = D.DICTIONARYID
						WHERE	C.LOOKUP_TYPE = 'DefectMapDefectGroupSub'
						AND		C.ENABLED_FLAG = 'Y'
						AND		D.LANGUAGETYPE = #{LANGUAGETYPE}        -- 다국어 코드
					) 					SUB								ON	GRP.CODEID = SUB.PARENTCODEID
					WHERE 1 = 1
                              AND GRP.CODEID IN ('001','002')
                              AND SUB.CODEID IN ('1001','2001')
				)   T_AFT_ANALYSIS
            ON A.SEGMENTTYPE = T_AFT_ANALYSIS.SEGMENTTYPE 
            AND A.DEFECTCODE = T_AFT_ANALYSIS.CHK_S_CODE
-----------------------------------------------------------------   
		INNER JOIN	BAS_PROCESSSEGMENTEXT	C	ON A.PROCESSSEGMENTID = C.PROCESSSEGMENTID 
										  AND A.ENTERPRISEID = C.ENTERPRISEID                                   
		LEFT OUTER JOIN (	
						  SELECT	
								   'AOIInspection'                               	AS SEGMENTTYPE						  
						  	 	,   GRP.CODEID										AS GROUPCODE
								,	GRP.GROUPNAME								AS GROUPNAME
								,	GRP.DESCRIPTION 								AS COLOR
								,	SUB.CODEID										AS SUBCODE
								,	SUB.SUBNAME									AS SUBNAME
							FROM	
							(
								SELECT 	C.LOOKUP_CODE   AS CODEID
									,	C.DESCRIPTION
									,	D.DICTIONARYNAME						AS GROUPNAME
								FROM 	CMD_LOOKUP_VALUES									C
								LEFT OUTER JOIN		CMD_DICTIONARY	D	ON	C.DICTIONARYID = D.DICTIONARYID						           	   			   		    
								WHERE	C.LOOKUP_TYPE = 'DefectMapDefectGroup'
								AND		C.ENABLED_FLAG = 'Y'
								AND		D.LANGUAGETYPE = #{LANGUAGETYPE} 
							) 					GRP
							LEFT OUTER JOIN		
							(
								SELECT	C.LOOKUP_CODE AS CODEID
									,	D.DICTIONARYNAME						AS SUBNAME
									,	C.PARENTCODEID
								FROM	CMD_LOOKUP_VALUES									C
								LEFT OUTER JOIN 	CMD_DICTIONARY	D	ON 	C.DICTIONARYID = D.DICTIONARYID
								WHERE	C.LOOKUP_TYPE = 'DefectMapDefectGroupSub'
								AND		C.ENABLED_FLAG = 'Y'
								AND		D.LANGUAGETYPE = #{LANGUAGETYPE} 
							) 					
							SUB		ON GRP.CODEID = SUB.PARENTCODEID              
						) AOI		ON A.DEFECTCODE = AOI.SUBCODE
								   AND A.SEGMENTTYPE = AOI.SEGMENTTYPE							
        LEFT JOIN CMD_DICTIONARY         	DIC	ON	DIC.DICTIONARYID = C.PROCESSSEGMENTNAME
                                                AND DIC.LANGUAGETYPE = #{LANGUAGETYPE}      
                                                
		---------------------------------[5]
		-- (21.07.12) 추가
        INNER JOIN BAS_PRODUCTDEFINITION E      ON 	A.PRODUCTDEFID = E.PRODUCTDEFID
											   AND  A.PRODUCTDEFVERSION  = E.PRODUCTDEFVERSION
		---------------------------------
		-----------------------------------(21.08.10) 인계 시간 조건 추가        
		LEFT JOIN T_SENDTIME TT 
				ON TT.LOTID             			= A.LOTID
			   AND TT.PROCESSSEGMENTID  	= A.PROCESSSEGMENTID
		-----------------------------


		WHERE 1 = 1
		  AND A.SEGMENTTYPE = 'AOIInspection'
		  AND A.ENTERPRISEID = #{P_ENTERPRISEID}
		  AND A.PLANTID = #{P_PLANTID}		  
		<if test="P_PERIOD_PERIODFR != null and P_PERIOD_PERIODFR !='' and P_PERIOD_PERIODTO != null and P_PERIOD_PERIODTO !=''">
		  -- (21.08.10) 인계 시간 조건 추가  A.CREATEDTIME --> TT.SENDTIME
		  AND TT.SENDTIME <![CDATA[>=]]> TO_TIMESTAMP(SUBSTR(#{P_PERIOD_PERIODFR},1,14), 'YYYYMMDDHH24MISS')
		  AND TT.SENDTIME <![CDATA[<]]>  TO_TIMESTAMP(TO_CHAR(TO_DATE(SUBSTR(#{P_PERIOD_PERIODTO},1,8), 'YYYYMMDD'), 'YYYY-MM-DD') || ' ' || SUBSTR(#{P_PERIOD_PERIODTO}, 9, 6), 'YYYY-MM-DD HH24:MI:SS') 
		</if>
		<if test="LOTID_LIST.length != 0">
                AND		A.LOTID IN
	           <foreach collection="LOTID_LIST" item="item" index="index" separator="," open="(" close=")">
	                    #{item}
	           </foreach>				
		</if>	
		<if test="PROCESSSEGMENTID_LIST.length != 0">
                AND		A.PROCESSSEGMENTID IN
	           <foreach collection="PROCESSSEGMENTID_LIST" item="item" index="index" separator="," open="(" close=")">
	                    #{item}
	           </foreach>				
		</if>			
		<if test="PRODUCTDEFIDVER_LIST.length != 0">
                AND		A.PRODUCTDEFID || A.PRODUCTDEFVERSION IN
	           <foreach collection="PRODUCTDEFIDVER_LIST" item="item" index="index" separator="," open="(" close=")">
	                    #{item}
	           </foreach>				
		</if>
		<if test="P_AOIPROCESS != null and P_AOIPROCESS !=''">
		    -- AOI 공정
			AND	 EXISTS (SELECT 1 FROM ufn_selectStringToSplit(#{P_AOIPROCESS},',') WHERE value = A.PROCESSSEGMENTID) 
		</if>
		
		<if test="P_PRODUCTIONTYPE != null and P_PRODUCTIONTYPE !='' and !(P_PRODUCTIONTYPE eq '*'.toString()) ">
			-- (21.07.12) 생산구분 추가[5]
			AND 	E.PRODUCTIONTYPE 			= #{P_PRODUCTIONTYPE}
		</if>
		
		) A
		, 
		   (
		   SELECT
					A.SEGMENTTYPE    
                ,   A.PROCESSSEGMENTID
                ,   SUM(A.INSPECTIONQTY) AS INSPECTIONQTY
            FROM
           (
		   SELECT
					A.SEGMENTTYPE    
                ,   A.PROCESSSEGMENTID
                ,   A.LOTID
                ,	MAX(A.INSPECTIONQTY) AS INSPECTIONQTY	   
		FROM PCM_QCAOIBBTWORKCOMPLETE	A
			INNER JOIN LOTLIST 					L	ON	A.LOTID = L.LOTID
													AND	A.PRODUCTDEFID = L.PRODUCTDEFID
													AND	A.PRODUCTDEFVERSION = L.PRODUCTDEFVERSION				
            -- (21.06.17) 완료된 상태 체크   -> (21.06.18) 여러건 존재함 하나만 나오도록 수정
            INNER JOIN (SELECT RESOURCEID
                            ,  INSPECTIONDEFID  
                            , PROCESSSEGMENTID, PROCESSSEGMENTVERSION
                         FROM  QAM_INSPECTIONRESULT   
                         GROUP BY  RESOURCEID, INSPECTIONDEFID    
                                    , PROCESSSEGMENTID, PROCESSSEGMENTVERSION
                         ) Q_INSP
            ON Q_INSP.RESOURCEID                 		=  A.LOTID
            AND Q_INSP.INSPECTIONDEFID 					= 	'AOIInspection'
            AND Q_INSP.PROCESSSEGMENTID					= A.PROCESSSEGMENTID
            AND Q_INSP.PROCESSSEGMENTVERSION			= A.PROCESSSEGMENTVERSION
            -----------------------------------------------------------------   	
            LEFT OUTER JOIN (
					SELECT	GRP.CODEID								AS	GROUPCODE
						,	GRP.GROUPNAME							AS	GROUPNAME
						,	GRP.DESCRIPTION 							AS	COLOR
						,	SUB.CODEID									AS	SUBCODE
						,	SUB.SUBNAME								AS	SUBNAME
						,	'AOIInspection'								AS	SEGMENTTYPE
						,   '005'                                       	AS  CHK_G_CODE
                                    ,   (
                                        CASE WHEN SUB.CODEID = '1001'
                                             THEN '5001'
                                             ELSE '5002'
                                             END
                                    )   													AS CHK_S_CODE
					FROM	
					(
						SELECT 	C.LOOKUP_CODE   AS CODEID
							,	C.DESCRIPTION
							,	D.DICTIONARYNAME						AS	GROUPNAME
						FROM 	CMD_LOOKUP_VALUES									C
						LEFT OUTER JOIN		CMD_DICTIONARY	D			ON	C.DICTIONARYID = D.DICTIONARYID						           	   			   		    
						WHERE	C.LOOKUP_TYPE = 'DefectMapDefectGroup'
						AND		C.ENABLED_FLAG = 'Y'
						AND		D.LANGUAGETYPE = #{LANGUAGETYPE}        -- 다국어 코드
					) 					GRP
					LEFT OUTER JOIN		
					(
						SELECT	C.LOOKUP_CODE   AS CODEID
							,	D.DICTIONARYNAME						AS	SUBNAME
							,	C.PARENTCODEID
						FROM	CMD_LOOKUP_VALUES									C
						LEFT OUTER JOIN 	CMD_DICTIONARY	D			ON 	C.DICTIONARYID = D.DICTIONARYID
						WHERE	C.LOOKUP_TYPE = 'DefectMapDefectGroupSub'
						AND		C.ENABLED_FLAG = 'Y'
						AND		D.LANGUAGETYPE = #{LANGUAGETYPE}        -- 다국어 코드
					) 					SUB								ON	GRP.CODEID = SUB.PARENTCODEID
					WHERE 1 = 1
                              AND GRP.CODEID IN ('001','002')
                              AND SUB.CODEID IN ('1001','2001')
				)   T_AFT_ANALYSIS
            ON A.SEGMENTTYPE = T_AFT_ANALYSIS.SEGMENTTYPE 
            AND A.DEFECTCODE = T_AFT_ANALYSIS.CHK_S_CODE
-----------------------------------------------------------------   
		INNER JOIN	BAS_PROCESSSEGMENTEXT	C	ON A.PROCESSSEGMENTID = C.PROCESSSEGMENTID 
										  AND A.ENTERPRISEID = C.ENTERPRISEID                                   
		LEFT OUTER JOIN (	
						  SELECT	
								   'AOIInspection'                               	AS SEGMENTTYPE						  
						  	 	,   GRP.CODEID										AS GROUPCODE
								,	GRP.GROUPNAME								AS GROUPNAME
								,	GRP.DESCRIPTION 								AS COLOR
								,	SUB.CODEID										AS SUBCODE
								,	SUB.SUBNAME									AS SUBNAME
							FROM	
							(
								SELECT 	C.LOOKUP_CODE   AS CODEID
									,	C.DESCRIPTION
									,	D.DICTIONARYNAME						AS GROUPNAME
								FROM 	CMD_LOOKUP_VALUES									C
								LEFT OUTER JOIN		CMD_DICTIONARY	D	ON	C.DICTIONARYID = D.DICTIONARYID						           	   			   		    
								WHERE	C.LOOKUP_TYPE = 'DefectMapDefectGroup'
								AND		C.ENABLED_FLAG = 'Y'
								AND		D.LANGUAGETYPE = #{LANGUAGETYPE} 
							) 					GRP
							LEFT OUTER JOIN		
							(
								SELECT	C.LOOKUP_CODE AS CODEID
									,	D.DICTIONARYNAME						AS SUBNAME
									,	C.PARENTCODEID
								FROM	CMD_LOOKUP_VALUES									C
								LEFT OUTER JOIN 	CMD_DICTIONARY	D	ON 	C.DICTIONARYID = D.DICTIONARYID
								WHERE	C.LOOKUP_TYPE = 'DefectMapDefectGroupSub'
								AND		C.ENABLED_FLAG = 'Y'
								AND		D.LANGUAGETYPE = #{LANGUAGETYPE} 
							) 					
							SUB		ON GRP.CODEID = SUB.PARENTCODEID              
						) AOI		ON A.DEFECTCODE = AOI.SUBCODE
								   AND A.SEGMENTTYPE = AOI.SEGMENTTYPE							
        LEFT JOIN CMD_DICTIONARY         	DIC	ON	DIC.DICTIONARYID = C.PROCESSSEGMENTNAME
                                                AND DIC.LANGUAGETYPE = #{LANGUAGETYPE}      
                                                
                                                
		---------------------------------[6]
		-- (21.07.12) 추가
        INNER JOIN BAS_PRODUCTDEFINITION E      ON 	A.PRODUCTDEFID = E.PRODUCTDEFID
											   AND  A.PRODUCTDEFVERSION  = E.PRODUCTDEFVERSION
		---------------------------------
		-----------------------------------(21.08.10) 인계 시간 조건 추가        
		LEFT JOIN T_SENDTIME TT 
				ON TT.LOTID             			= A.LOTID
			   AND TT.PROCESSSEGMENTID  	= A.PROCESSSEGMENTID
		-----------------------------



		WHERE 1 = 1
		  AND A.SEGMENTTYPE = 'AOIInspection'
		  AND A.ENTERPRISEID = #{P_ENTERPRISEID}
		  AND A.PLANTID = #{P_PLANTID}		  
		<if test="P_PERIOD_PERIODFR != null and P_PERIOD_PERIODFR !='' and P_PERIOD_PERIODTO != null and P_PERIOD_PERIODTO !=''">
		  -- (21.08.10) 인계 시간 조건 추가  A.CREATEDTIME --> TT.SENDTIME
		  AND TT.SENDTIME <![CDATA[>=]]> TO_TIMESTAMP(SUBSTR(#{P_PERIOD_PERIODFR},1,14), 'YYYYMMDDHH24MISS')
		  AND TT.SENDTIME <![CDATA[<]]>  TO_TIMESTAMP(TO_CHAR(TO_DATE(SUBSTR(#{P_PERIOD_PERIODTO},1,8), 'YYYYMMDD'), 'YYYY-MM-DD') || ' ' || SUBSTR(#{P_PERIOD_PERIODTO}, 9, 6), 'YYYY-MM-DD HH24:MI:SS') 
		</if>
		<if test="LOTID_LIST.length != 0">
                AND		A.LOTID IN
	           <foreach collection="LOTID_LIST" item="item" index="index" separator="," open="(" close=")">
	                    #{item}
	           </foreach>				
		</if>	
		<if test="PROCESSSEGMENTID_LIST.length != 0">
                AND		A.PROCESSSEGMENTID IN
	           <foreach collection="PROCESSSEGMENTID_LIST" item="item" index="index" separator="," open="(" close=")">
	                    #{item}
	           </foreach>				
		</if>			
		<if test="PRODUCTDEFIDVER_LIST.length != 0">
                AND		A.PRODUCTDEFID || A.PRODUCTDEFVERSION IN
	           <foreach collection="PRODUCTDEFIDVER_LIST" item="item" index="index" separator="," open="(" close=")">
	                    #{item}
	           </foreach>				
		</if>
		<if test="P_AOIPROCESS != null and P_AOIPROCESS !=''">
		    -- AOI 공정
			AND	 EXISTS (SELECT 1 FROM ufn_selectStringToSplit(#{P_AOIPROCESS},',') WHERE value = A.PROCESSSEGMENTID) 
		</if>
		
		<if test="P_PRODUCTIONTYPE != null and P_PRODUCTIONTYPE !='' and !(P_PRODUCTIONTYPE eq '*'.toString()) ">
			-- (21.07.12) 생산구분 추가[6]
			AND 	E.PRODUCTIONTYPE 			= #{P_PRODUCTIONTYPE}
		</if>
		
        GROUP BY 
		 			A.SEGMENTTYPE    
                ,   A.PROCESSSEGMENTID
                ,   A.LOTID
        ) A
        GROUP BY 
		 			A.SEGMENTTYPE    
                ,   A.PROCESSSEGMENTID 
	    ) B
		WHERE A.PROCESSSEGMENTID = B.PROCESSSEGMENTID
			)  A
            GROUP BY 
					A.PROCESSSEGMENTID
				,   A.PROCESSSEGMENTNAME			            
				,	A.GROUPCODE				
				,	A.GROUPNAME	
				,	A.SUBCODE									
				,	A.SUBNAME											
		   )	  S -- SUBCODE		
		 WHERE 1 = 1
		    AND T.PROCESSSEGMENTID = G.PROCESSSEGMENTID
		    AND G.PROCESSSEGMENTID = S.PROCESSSEGMENTID
		    AND G.GROUPCODE        = S.GROUPCODE
		    AND G.AFTERDEFECTRATE <![CDATA[>]]> 0
		<if test="P_PROCESSSEGMENTID != null and P_PROCESSSEGMENTID !=''">
		    AND T.PROCESSSEGMENTID = #{P_PROCESSSEGMENTID}
		</if>		    
		ORDER BY 
			   G.PROCESSSEGMENTID
			  , G.PROCESSSEGMENTNAME				
			  , G.GROUPCODE
			  , S.SUBCODE				
    </select>
    
   <!-- 품목에 등록된 공정 가져오기   -->
    <select id="getProcessByProductdef" parameterType="map" resultType="hashmap">
    
    				--
				-- id : GetProcessByProductdef
				-- version : 10001

					
			/* getProcessByProductdef -  
			/* 기준정보 - 사양기준정보 - ROUTING AOI 층정보 나오는것 참조 */
			
			WITH DATA AS (
				SELECT	
				        A.PROCESSSEGMENTID		AS PROCESSSEGMENTID
					,	DIC.DICTIONARYNAME 		AS PROCESSSEGMENTNAME
				FROM	BAS_PROCESSPATH 						A
						INNER JOIN BAS_PROCESSSEGMENTEXT 	P	ON	A.PROCESSSEGMENTID = P.PROCESSSEGMENTID
																AND P.SEGMENTTYPE = #{P_INSPECTIONTYPE}
				  		LEFT JOIN CMD_DICTIONARY         	DIC	ON	DIC.DICTIONARYID = P.PROCESSSEGMENTNAME
				  												AND DIC.LANGUAGETYPE = #{LANGUAGETYPE}
				WHERE	A.ENTERPRISEID = #{P_ENTERPRISEID}
				AND		A.PLANTID = #{P_PLANTID}
				AND 	A.PROCESSDEFID = #{P_PRODUCTDEFID}
				
				<if test="P_PRODUCTDEFVERSION != null and P_PRODUCTDEFVERSION !='' and !(P_PRODUCTDEFVERSION eq '*'.toString())">
					AND		EXISTS(SELECT 1 FROM ufn_selectStringToSplit(#{P_PRODUCTDEFVERSION},',') WHERE value = A.PROCESSDEFVERSION)
				</if>
				GROUP BY 
						A.PROCESSSEGMENTID
					,	DIC.DICTIONARYNAME
			)
          SELECT
				   '0'                         	 		AS CHK
			     , '' 						    		AS CODE
				 , (
					SELECT DICTIONARYNAME
					  FROM CMD_DICTIONARY
					 WHERE 1 = 1
					   AND DICTIONARYID = 'ALLVIEWS'        -- 전체조회
					   AND LANGUAGETYPE = #{LANGUAGETYPE}
					) 									 AS VALUE				 
				 , '1'                                    AS P_CODE
          FROM
          DUAL
          UNION ALL
          SELECT
				   CHK
			     , CODE
				 , VALUE
				 , P_CODE    
          FROM
          (
          	SELECT
				   '0' 							    AS CHK
			     , PROCESSSEGMENTID 	    AS CODE 		
				 , PROCESSSEGMENTNAME	AS VALUE		
				 , '2' 								AS P_CODE
			  FROM 
		      DATA
	          ORDER BY PROCESSSEGMENTID DESC
          )      
    </select>    

</mapper>
