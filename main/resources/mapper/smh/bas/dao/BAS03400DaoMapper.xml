<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE mapper 
  PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN"
  "http://mybatis.org/dtd/mybatis-3-mapper.dtd">
<mapper namespace="smh.bas.dao.BAS03400Dao">

   <!-- 표준공정 사용품목 조회 -->
    <select id="selectBasProcesssegmentUseProduct" parameterType="map" resultType="hashmap">
    	/*selectBasProcesssegmentUseProduct*/
	  SELECT 
				PD.PRODUCTDEFID
			,	PD.PRODUCTDEFVERSION
			,	PD.PRODUCTDEFNAME
			,	PP.PLANTID
			,	PP.USERSEQUENCE
			,	PP.PROCESSSEGMENTID
			,	PP.PROCESSSEGMENTVERSION
			--,	PS.PROCESSSEGMENTNAME
			,	DC.DICTIONARYNAME		AS PROCESSSEGMENTNAME
			,	PD.CUSTOMERID
			,	CST.CUSTOMERNAME
			,	PP.DESCRIPTION
			,	DC2.DICTIONARYNAME		AS VALIDSTATE
		FROM BAS_PRODUCTDEFINITION PD
		LEFT OUTER JOIN BAS_PROCESSPATH		PP	ON	PD.PROCESSDEFID = PP.PROCESSDEFID
												AND PD.PROCESSDEFVERSION = PP.PROCESSDEFVERSION
		LEFT OUTER JOIN BAS_PROCESSSEGMENT	PS	ON 	PP.PROCESSSEGMENTID = PS.PROCESSSEGMENTID
												AND PP.PROCESSSEGMENTVERSION = PS.PROCESSSEGMENTVERSION
		LEFT OUTER JOIN CMD_DICTIONARY		DC 	ON	PS.PROCESSSEGMENTNAME = DC.DICTIONARYID
												AND LANGUAGETYPE = #{LANGUAGETYPE} 
		LEFT OUTER JOIN BAS_CUSTOMER		CST	ON	PD.CUSTOMERID = CST.CUSTOMERID
		LEFT OUTER JOIN CMD_LOOKUP_VALUES	CD	ON  PP.VALIDSTATE = CD.LOOKUP_CODE
												AND	CD.LOOKUP_TYPE = 'ValidState'
		LEFT OUTER JOIN CMD_DICTIONARY		DC2 ON  CD.DICTIONARYID = DC2.DICTIONARYID
												AND DC2.LANGUAGETYPE = #{LANGUAGETYPE}			
		WHERE 1=1
		<if test="PLANTID != null and PLANTID !='' and !(PLANTID eq '*'.toString())">
			AND PP.PLANTID = #{PLANTID}
		</if>
		<if test="PROCESSSEGMENTID != null and PROCESSSEGMENTID !=''"> 
			AND	EXISTS
				(
							SELECT	1
							FROM	ufn_selectStringToSplit(#{PROCESSSEGMENTID} ||',' , ',') 		MAP
							WHERE	  PS.PROCESSSEGMENTID = MAP.VALUE
					)
		</if> 
		<if test="PRODUCTDEFID != null and PRODUCTDEFID !=''">										
			AND	PD.PRODUCTDEFID = #{PRODUCTDEFID} 
			AND PD.PRODUCTDEFVERSION =#{PRODUCTDEFVERSION}
		</if>
		ORDER BY PD.PRODUCTDEFID , PD.PRODUCTDEFVERSION , TO_NUMBER(PP.USERSEQUENCE)
    </select>    
    
     <!-- 공정 팝업 -->
    <select id="selectProcesssegmentPopup" parameterType="map" resultType="hashmap">
    	/* GetProcessSegmentExtPupop 10001 */
    	
    			SELECT   
					 	PG.PROCESSSEGMENTID             
				    ,	DI.DICTIONARYNAME          	 	AS PROCESSSEGMENTNAME
				    ,	PG.DESCRIPTION
				    ,	PG.PROCESSSEGMENTCLASSID
				    ,	PG.SEGMENTTYPE
				    ,	PG.STEPCLASS
				    ,   (
					      SELECT 
					            LISTAGG(B.DICTIONARYNAME,',') WITHIN GROUP(ORDER BY A.DISPLAYSEQUENCE)
					      FROM CMD_LOOKUP_VALUES A
					      LEFT JOIN CMD_DICTIONARY B ON A.DICTIONARYID = B.DICTIONARYID AND B.LANGUAGETYPE = #{LANGUAGETYPE}
					      WHERE A.LOOKUP_TYPE  = PG.STEPCLASS				    
				        ) STEPTYPE
				    ,	PG.SUBSEGMENTID
				    ,	PG.ISTOOLWORK
				    ,	PG.ISINCOMINGINSPECTION
				    ,	PG.COSTCODE
				    ,	PG.VALIDSTATE
					,   CU.USER_NM AS CREATOR
					,   PG.CREATEDTIME
					,   MU.USER_NM AS MODIFIER
					,   PG.MODIFIEDTIME
				FROM BAS_PROCESSSEGMENTEXT           	PG
				LEFT JOIN CMD_USERS                       CU   ON CU.USER_ID = PG.CREATOR
				LEFT JOIN CMD_USERS                       MU   ON MU.USER_ID = PG.MODIFIER
				LEFT JOIN CMD_DICTIONARY 				DI	 ON DI.DICTIONARYID = PG.PROCESSSEGMENTNAME
														 	 AND DI.LANGUAGETYPE = #{LANGUAGETYPE}
				WHERE 1=1
			<if test="PROCESSSEGMENT != null and PROCESSSEGMENT !='' and !(PROCESSSEGMENT eq '*'.toString())"> 
		  		AND	(UPPER(PG.PROCESSSEGMENTID) LIKE UPPER(<![CDATA['%' ||]]> #{PROCESSSEGMENT} <![CDATA[|| '%']]> ) 
		  			OR UPPER(DI.DICTIONARYNAME) LIKE UPPER(<![CDATA['%' ||]]> #{PROCESSSEGMENT} <![CDATA[|| '%']]> ))
		  	</if>
		  		AND PG.VALIDSTATE = #{VALIDSTATE}
		  		ORDER BY PG.PROCESSSEGMENTID 
	</select>

</mapper>
