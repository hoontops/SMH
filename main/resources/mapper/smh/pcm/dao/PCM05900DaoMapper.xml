<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE mapper 
  PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN"
  "http://mybatis.org/dtd/mybatis-3-mapper.dtd">
<mapper namespace="smh.pcm.dao.PCM05900Dao">

	<select id="selectprogressperproductSearchList" parameterType="map" resultType="hashmap">	
	--id : selectprogressperproductSearchList
	SELECT
		'"''' ||
		TO_CHAR( ROW_NUMBER() OVER(ORDER BY MAX(PATHSEQUENCE), PROCESSSEGMENTID) - 1 )
		|| '''_VALUE" AS VALUE_' 
		|| TO_CHAR( ROW_NUMBER() OVER(ORDER BY MAX(PATHSEQUENCE), PROCESSSEGMENTID) - 1 )
																			AS COLUMNS_SELECT
	,	ROW_NUMBER() OVER(ORDER BY MAX(PATHSEQUENCE), PROCESSSEGMENTID) - 1 AS COLUMNS
	,	'"''' || PROCESSSEGMENTID || '''_VALUE" AS VALUE_'  || PROCESSSEGMENTID  AS COLUMNS_PROCESSSEGMENTID
	,	PROCESSSEGMENTID
		FROM
		(
			SELECT	'TOTAL'	AS PROCESSSEGMENTID
				,	0		AS PATHSEQUENCE
			FROM DUAL
			UNION ALL
		
			SELECT
			    	PP.PROCESSSEGMENTID
			    ,	PP.PATHSEQUENCE
			FROM	UFN_SELECTSTRINGTOSPLIT2(#{PRODUCTDEF}, ',', '|')	PRO
			JOIN	BAS_PRODUCTDEFINITION	PD	ON  PD.PRODUCTDEFID = PRO.VALUE
												AND PD.PRODUCTDEFVERSION = PRO.VALUE2
			JOIN    PCM_LOT                  L  ON  PD.PRODUCTDEFID = L.PRODUCTDEFID
                                                      AND PD.PRODUCTDEFVERSION = L.PRODUCTDEFVERSION
                  JOIN	BAS_PROCESSPATH	        PP  ON  ((NVL(L.SUBPROCESSDEFID, '*') = '*' AND L.PROCESSDEFID = PP.PROCESSDEFID)  OR (NVL(L.SUBPROCESSDEFID, '*') != '*' AND L.SUBPROCESSDEFID = PP.PROCESSDEFID))
		                                        AND ((NVL(L.SUBPROCESSDEFVERSION, '*') = '*' AND L.PROCESSDEFVERSION = PP.PROCESSDEFVERSION)  OR (NVL(L.SUBPROCESSDEFVERSION, '*') != '*' AND L.SUBPROCESSDEFVERSION = PP.PROCESSDEFVERSION))                  					
			WHERE	1 = 1
			AND   	(PD.PRODUCTDEFTYPE = #{PRODUCTDIVISION} OR #{PRODUCTDIVISION} IS NULL)
			AND   	(PD.PRODUCTIONTYPE = #{PRODUCTIONTYPE} OR #{PRODUCTIONTYPE} IS NULL)		
			AND   	PD.PRODUCTDEFNAME LIKE '%' || #{PRODUCTDEFNAME} || '%'
			GROUP BY   	PP.PROCESSSEGMENTID
			    ,	PP.PATHSEQUENCE
			UNION ALL
			
	
			SELECT
			  		PT.PROCESSSEGMENTID
				,	PT.PATHSEQUENCE
			FROM	UFN_SELECTSTRINGTOSPLIT2(#{PRODUCTDEF}, ',', '|')	PRO
			JOIN	PCM_LOT              	L	ON	L.PRODUCTDEFID = PRO.VALUE
												AND	L.PRODUCTDEFVERSION = PRO.VALUE2
			JOIN	BAS_PRODUCTDEFINITION 	PD	ON	PD.PRODUCTDEFID = L.PRODUCTDEFID
												AND	PD.PRODUCTDEFVERSION = L.PRODUCTDEFVERSION
			JOIN	BAS_PROCESSPATH	        PT  ON  ((NVL(L.SUBPROCESSDEFID, '*') = '*' AND L.PROCESSDEFID = PT.PROCESSDEFID)  OR (NVL(L.SUBPROCESSDEFID, '*') != '*' AND L.SUBPROCESSDEFID = PT.PROCESSDEFID))
		                                        AND ((NVL(L.SUBPROCESSDEFVERSION, '*') = '*' AND L.PROCESSDEFVERSION = PT.PROCESSDEFVERSION)  OR (NVL(L.SUBPROCESSDEFVERSION, '*') != '*' AND L.SUBPROCESSDEFVERSION = PT.PROCESSDEFVERSION))
			WHERE	1 = 1
			AND		L.PROCESSDEFID = L.LOTID
			AND   	(PD.PRODUCTDEFTYPE = #{PRODUCTDIVISION} OR #{PRODUCTDIVISION} IS NULL)
			AND   	(PD.PRODUCTIONTYPE = #{PRODUCTIONTYPE} OR #{PRODUCTIONTYPE} IS NULL)		
			AND   	PD.PRODUCTDEFNAME LIKE '%' || #{PRODUCTDEFNAME} || '%'
			AND   	(L.PLANTID = #{PLANTID} OR #{PLANTID} IS NULL)
			AND   	(L.ISHOLD = #{ISHOLD} OR #{ISHOLD} IS NULL)
			AND		(#{WORKTYPE} IS NULL
					OR #{WORKTYPE} = CASE	WHEN L.LOTCREATEDTYPE = 'Return' THEN 'Return'
						                    WHEN L.LOTCREATEDTYPE = 'Repair' THEN 'MRB'
						                    WHEN L.LOTCREATEDTYPE = 'Claim' THEN 'Claim'
						                    ELSE CASE	WHEN L.ISREWORK = 'Y' OR L.WORKCOUNT > 0 THEN 'IsRework' 
						                    			ELSE 'Normal'
						                    	 END
						            END)
		) X
		GROUP BY	PROCESSSEGMENTID
		ORDER BY	MAX(PATHSEQUENCE), PROCESSSEGMENTID
	</select>
	<select id="selectprogressperproduct" parameterType="map" resultType="hashmap">	
	--id : selectprogressperproduct
	SELECT
				CASE WHEN T.PRODUCTDEFID IS NOT NULL THEN T.PRODUCTDEFID
					ELSE (SELECT DICTIONARYNAME FROM CMD_DICTIONARY WHERE DICTIONARYID = 'SUM' AND LANGUAGETYPE = 'ko-KR')
				END AS PRODUCTDEFID
			,	T.PRODUCTDEFVERSION
			,	PD.PRODUCTDEFNAME
--			,	WH.QTY	AS INVENTORY	05.17 품목별 진행현황 INVENTORY 조회못함 뷰테이블에 PRODUCTDEFVERSION 없음
			,	PD.PCSPNL
			,	COALESCE(TD.DICTIONARYNAME, T.TYPENAME) AS TYPENAME
			,	T."TYPE"
			,	T.*
	FROM
	(
		SELECT
				CASE WHEN 
					("TYPE" = '1' AND (LEAD(COALESCE("'TOTAL'_VALUE", '0'), 1, '0') OVER(ORDER BY PRODUCTDEFID, PRODUCTDEFVERSION, "TYPE")  !=  '0'
						OR LEAD(COALESCE("'TOTAL'_VALUE", '0'), 2, '0') OVER(ORDER BY PRODUCTDEFID, PRODUCTDEFVERSION, "TYPE")  !=  '0'))
					OR ("TYPE" = '2' AND (COALESCE("'TOTAL'_VALUE", '0')  !=  '0'
						OR LEAD(COALESCE("'TOTAL'_VALUE", '0'), 1, '0') OVER(ORDER BY PRODUCTDEFID, PRODUCTDEFVERSION, "TYPE")  !=  '0'))
					OR ("TYPE" = '3' AND (COALESCE("'TOTAL'_VALUE", '0')  !=  '0'
						OR LAG(COALESCE("'TOTAL'_VALUE", '0'), 1, '0') OVER(ORDER BY PRODUCTDEFID, PRODUCTDEFVERSION, "TYPE")  !=  '0'))
					OR ("TYPE" = '4' AND (LAG(COALESCE("'TOTAL'_VALUE", '0'), 1, '0') OVER(ORDER BY PRODUCTDEFID, PRODUCTDEFVERSION, "TYPE")  !=  '0'
						OR LAG(COALESCE("'TOTAL'_VALUE", '0'), 2, '0') OVER(ORDER BY PRODUCTDEFID, PRODUCTDEFVERSION, "TYPE")  !=  '0'))
					OR ("TYPE" = '5' AND (LAG(COALESCE("'TOTAL'_VALUE", '0'), 2, '0') OVER(ORDER BY PRODUCTDEFID, PRODUCTDEFVERSION, "TYPE")  !=  '0'
						OR LAG(COALESCE("'TOTAL'_VALUE", '0'), 3, '0') OVER(ORDER BY PRODUCTDEFID, PRODUCTDEFVERSION, "TYPE")  !=  '0'))
					THEN 'Y'
					ELSE 'N'
				END AS DISPLAY				
					,	ROW_NAME
					,	PRODUCTDEFID
					,	PRODUCTDEFVERSION
					,	"TYPE"
					,	TYPENAME
					,	${COLUMNS_SELECT}
		FROM 
		(
			WITH ALLSEGLIST AS (
			SELECT
				    	PROCESSSEGMENTID
				    ,	ROW_NUMBER() OVER(ORDER BY MAX(PATHSEQUENCE), PROCESSSEGMENTID) - 1 AS COL
				FROM
				(
					SELECT	'TOTAL'	AS PROCESSSEGMENTID
						,	0		AS PATHSEQUENCE
					FROM DUAL
					UNION ALL
				
					SELECT
					    	PP.PROCESSSEGMENTID
					    ,	PP.PATHSEQUENCE
					FROM	UFN_SELECTSTRINGTOSPLIT2(#{PRODUCTDEF}, ',', '|')	PRO
					JOIN	BAS_PRODUCTDEFINITION	PD	ON  PD.PRODUCTDEFID = PRO.VALUE
														AND PD.PRODUCTDEFVERSION = PRO.VALUE2
					JOIN 	PCM_LOTWORKRESULT		WR  ON  WR.PRODUCTDEFID = PD.PRODUCTDEFID 
														AND	WR.PRODUCTDEFVERSION = PD.PRODUCTDEFVERSION 
					JOIN	BAS_PROCESSPATH	        PP  ON  WR.PROCESSDEFID = PP.PROCESSDEFID
														AND WR.PROCESSDEFVERSION = PP.PROCESSDEFVERSION 
					--JOIN    PCM_LOT                  L  ON  PD.PRODUCTDEFID = L.PRODUCTDEFID
                    --                                    AND PD.PRODUCTDEFVERSION = L.PRODUCTDEFVERSION
                    --JOIN	BAS_PROCESSPATH	        PP  ON  ((NVL(L.SUBPROCESSDEFID, '*') = '*' AND L.PROCESSDEFID = PP.PROCESSDEFID)  OR (NVL(L.SUBPROCESSDEFID, '*') != '*' AND L.SUBPROCESSDEFID = PP.PROCESSDEFID))
				    --                                    AND ((NVL(L.SUBPROCESSDEFVERSION, '*') = '*' AND L.PROCESSDEFVERSION = PP.PROCESSDEFVERSION)  OR (NVL(L.SUBPROCESSDEFVERSION, '*') != '*' AND L.SUBPROCESSDEFVERSION = PP.PROCESSDEFVERSION))                  					
					WHERE	1 = 1
					AND   	(PD.PRODUCTDEFTYPE = #{PRODUCTDIVISION} OR #{PRODUCTDIVISION} IS NULL)
					AND   	(PD.PRODUCTIONTYPE = #{PRODUCTIONTYPE} OR #{PRODUCTIONTYPE} IS NULL)		
					AND   	PD.PRODUCTDEFNAME LIKE '%' || #{PRODUCTDEFNAME} || '%'
					GROUP BY   	PP.PROCESSSEGMENTID
					    ,	PP.PATHSEQUENCE
					UNION ALL
					
			
					SELECT
					  		PT.PROCESSSEGMENTID
						,	PT.PATHSEQUENCE
					FROM	UFN_SELECTSTRINGTOSPLIT2(#{PRODUCTDEF}, ',', '|')	PRO
					JOIN	PCM_LOT              	L	ON	L.PRODUCTDEFID = PRO.VALUE
														AND	L.PRODUCTDEFVERSION = PRO.VALUE2
					JOIN	BAS_PRODUCTDEFINITION 	PD	ON	PD.PRODUCTDEFID = L.PRODUCTDEFID
														AND	PD.PRODUCTDEFVERSION = L.PRODUCTDEFVERSION
					JOIN	BAS_PROCESSPATH	        PT  ON  ((NVL(L.SUBPROCESSDEFID, '*') = '*' AND L.PROCESSDEFID = PT.PROCESSDEFID)  OR (NVL(L.SUBPROCESSDEFID, '*') != '*' AND L.SUBPROCESSDEFID = PT.PROCESSDEFID))
				                                        AND ((NVL(L.SUBPROCESSDEFVERSION, '*') = '*' AND L.PROCESSDEFVERSION = PT.PROCESSDEFVERSION)  OR (NVL(L.SUBPROCESSDEFVERSION, '*') != '*' AND L.SUBPROCESSDEFVERSION = PT.PROCESSDEFVERSION))
					WHERE	1 = 1
					AND		L.PROCESSDEFID = L.LOTID
					AND   	(PD.PRODUCTDEFTYPE = #{PRODUCTDIVISION} OR #{PRODUCTDIVISION} IS NULL)
					AND   	(PD.PRODUCTIONTYPE = #{PRODUCTIONTYPE} OR #{PRODUCTIONTYPE} IS NULL)		
					AND   	PD.PRODUCTDEFNAME LIKE '%' || #{PRODUCTDEFNAME} || '%'
					AND   	(L.PLANTID = #{PLANTID} OR #{PLANTID} IS NULL)
					AND   	(L.ISHOLD = #{ISHOLD} OR #{ISHOLD} IS NULL)
					AND		(#{WORKTYPE} IS NULL
							OR #{WORKTYPE} = CASE	WHEN L.LOTCREATEDTYPE = 'Return' THEN 'Return'
								                    WHEN L.LOTCREATEDTYPE = 'Repair' THEN 'MRB'
								                    WHEN L.LOTCREATEDTYPE = 'Claim' THEN 'Claim'
								                    ELSE CASE	WHEN L.ISREWORK = 'Y' OR L.WORKCOUNT > 0 THEN 'IsRework' 
								                    			ELSE 'Normal'
								                    	 END
								            END)
				) X
				GROUP BY	PROCESSSEGMENTID
				ORDER BY	MAX(PATHSEQUENCE), PROCESSSEGMENTID
			)
			,SEGLIST AS 
			(
				SELECT
						PRODUCTDEFID
					,	PRODUCTDEFVERSION
					,	PROCESSSEGMENTID
					,	MAX(ROUND(USERSEQUENCE)) AS USERSEQUENCE
					,	MAX(PLANTID) AS PLANTID
				FROM
				(
					SELECT
							PD.PRODUCTDEFID
						,	PD.PRODUCTDEFVERSION
						,	PP.PROCESSSEGMENTID
						,	PP.PLANTID
						,	PP.USERSEQUENCE
					FROM	UFN_SELECTSTRINGTOSPLIT2(#{PRODUCTDEF}, ',', '|')	PRO
					JOIN	BAS_PRODUCTDEFINITION	PD	ON	PD.PRODUCTDEFID = PRO.VALUE
														AND	PD.PRODUCTDEFVERSION = PRO.VALUE2
					JOIN 	PCM_LOTWORKRESULT		WR  ON  WR.PRODUCTDEFID = PD.PRODUCTDEFID 
														AND	WR.PRODUCTDEFVERSION = PD.PRODUCTDEFVERSION 
					JOIN	BAS_PROCESSPATH	        PP  ON  WR.PROCESSDEFID = PP.PROCESSDEFID
														AND WR.PROCESSDEFVERSION = PP.PROCESSDEFVERSION 	
					--JOIN    PCM_LOT                  L  ON  PD.PRODUCTDEFID = L.PRODUCTDEFID
                    --                                    AND PD.PRODUCTDEFVERSION = L.PRODUCTDEFVERSION
--					--JOIN	BAS_PROCESSPATH			PT	ON	PT.PROCESSDEFID = PD.PROCESSDEFID
--														AND PT.PROCESSDEFVERSION = PD.PROCESSDEFVERSION
                    --JOIN	BAS_PROCESSPATH	        PP  ON  ((NVL(L.SUBPROCESSDEFID, '*') = '*' AND L.PROCESSDEFID = PP.PROCESSDEFID)  OR (NVL(L.SUBPROCESSDEFID, '*') != '*' AND L.SUBPROCESSDEFID = PP.PROCESSDEFID))
				    --                                    AND ((NVL(L.SUBPROCESSDEFVERSION, '*') = '*' AND L.PROCESSDEFVERSION = PP.PROCESSDEFVERSION)  OR (NVL(L.SUBPROCESSDEFVERSION, '*') != '*' AND L.SUBPROCESSDEFVERSION = PP.PROCESSDEFVERSION))
					WHERE	1 = 1
					AND   	(PD.PRODUCTDEFTYPE = #{PRODUCTDIVISION} OR #{PRODUCTDIVISION} IS NULL)
					AND   	(PD.PRODUCTIONTYPE = #{PRODUCTIONTYPE} OR #{PRODUCTIONTYPE} IS NULL)		
					AND   	PD.PRODUCTDEFNAME LIKE '%' || #{PRODUCTDEFNAME} || '%'
					GROUP BY   	PD.PRODUCTDEFID
						,	PD.PRODUCTDEFVERSION
						,	PP.PROCESSSEGMENTID
						,	PP.PLANTID
						,	PP.USERSEQUENCE
					UNION ALL
			
					SELECT
							L.PRODUCTDEFID
					  	,	L.PRODUCTDEFVERSION
					  	,	PT.PROCESSSEGMENTID
						,	PT.PLANTID
						,	PT.USERSEQUENCE
					FROM	UFN_SELECTSTRINGTOSPLIT2(#{PRODUCTDEF}, ',', '|')	PRO
					JOIN	PCM_LOT              	L	ON	L.PRODUCTDEFID = PRO.VALUE
														AND	L.PRODUCTDEFVERSION = PRO.VALUE2
					JOIN	BAS_PRODUCTDEFINITION 	PD	ON	PD.PRODUCTDEFID = L.PRODUCTDEFID
														AND	PD.PRODUCTDEFVERSION = L.PRODUCTDEFVERSION
					JOIN	BAS_PROCESSPATH			PT	ON  ((NVL(L.SUBPROCESSDEFID, '*') = '*' AND L.PROCESSDEFID = PT.PROCESSDEFID)  OR (NVL(L.SUBPROCESSDEFID, '*') != '*' AND L.SUBPROCESSDEFID = PT.PROCESSDEFID))
				                                        AND ((NVL(L.SUBPROCESSDEFVERSION, '*') = '*' AND L.PROCESSDEFVERSION = PT.PROCESSDEFVERSION)  OR (NVL(L.SUBPROCESSDEFVERSION, '*') != '*' AND L.SUBPROCESSDEFVERSION = PT.PROCESSDEFVERSION))
					WHERE	1 = 1
					AND		L.PROCESSDEFID = L.LOTID
					AND   	(PD.PRODUCTDEFTYPE = #{PRODUCTDIVISION} OR #{PRODUCTDIVISION} IS NULL)
					AND   	(PD.PRODUCTIONTYPE = #{PRODUCTIONTYPE} OR #{PRODUCTIONTYPE} IS NULL)		
					AND   	PD.PRODUCTDEFNAME LIKE '%' || #{PRODUCTDEFNAME} || '%'
					AND   	(L.PLANTID = #{PLANTID} OR #{PLANTID} IS NULL)
					AND   	(L.ISHOLD = #{ISHOLD} OR #{ISHOLD} IS NULL)
					AND		(#{WORKTYPE} IS NULL
							OR #{WORKTYPE} = CASE	WHEN L.LOTCREATEDTYPE = 'Return' THEN 'Return'
								                    WHEN L.LOTCREATEDTYPE = 'Repair' THEN 'MRB'
								                    WHEN L.LOTCREATEDTYPE = 'Claim' THEN 'Claim'
								                    ELSE CASE	WHEN L.ISREWORK = 'Y' OR L.WORKCOUNT > 0 THEN 'IsRework' 
								                    			ELSE 'Normal'
								                    	 END
								            END)
				) X
				GROUP BY PRODUCTDEFID, PRODUCTDEFVERSION, PROCESSSEGMENTID
			)
			,JOIN_BASE AS 
			(
				SELECT
						COALESCE(SL.PRODUCTDEFID, LWR.PRODUCTDEFID) AS PRODUCTDEFID
					,	COALESCE(SL.PRODUCTDEFVERSION, LWR.PRODUCTDEFVERSION) AS PRODUCTDEFVERSION
					,	COALESCE(SL.PROCESSSEGMENTID, LWR.PROCESSSEGMENTID) AS PROCESSSEGMENTID
					,	COALESCE(SL.PLANTID, LWR.PLANTID) AS PLANTID
					,	COALESCE(SL.USERSEQUENCE, LWR.USERSEQUENCE) AS USERSEQUENCE
					, 	L.QTY AS WIP_PCSQTY
					, 	LWR.SENDPCSQTY AS RESULT_PCSQTY
					, 	L.LOTID AS WIP_LOTID
					, 	LWR.LOTID AS RESULT_LOTID
				FROM		SEGLIST					SL
				LEFT JOIN	PCM_LOT					L	ON	L.PRODUCTDEFID = SL.PRODUCTDEFID
														AND	L.PRODUCTDEFVERSION = SL.PRODUCTDEFVERSION
														AND	L.PROCESSSEGMENTID = SL.PROCESSSEGMENTID
														AND L.LOTSTATE IN ('InProduction', 'InTransit')
														AND COALESCE(L.ISDEFECTED, 'N') = 'N'
														AND COALESCE(L.ISREPRESENTROLLLOT, 'N') <![CDATA[<>]]> 'Y'
													  	AND L.PLANTID IN (#{PLANTID}, '', '*')
													  	AND	(L.ISHOLD = #{ISHOLD} or #{ISHOLD} IS NULL)
														AND	(#{WORKTYPE} IS NULL
															OR #{WORKTYPE} = CASE	WHEN L.LOTCREATEDTYPE = 'Return' THEN 'Return'
																                    WHEN L.LOTCREATEDTYPE = 'Repair' THEN 'MRB'
																                    WHEN L.LOTCREATEDTYPE = 'Claim' THEN 'Claim'
																                    ELSE CASE	WHEN L.ISREWORK = 'Y' OR L.WORKCOUNT > 0 THEN 'IsRework' 
																                    			ELSE 'Normal'
																                    	 END
																		    END)
				FULL OUTER JOIN
				(
					SELECT
							R.PRODUCTDEFID
						,	R.PRODUCTDEFVERSION
						,	R.PROCESSSEGMENTID
						,	R.SENDPCSQTY
						,	R.PLANTID
						,	SL.USERSEQUENCE
						,	R.LOTID
					FROM		SEGLIST				SL
					LEFT  JOIN	PCM_LOTWORKRESULT	R	ON	R.PRODUCTDEFID = SL.PRODUCTDEFID
														AND	R.PRODUCTDEFVERSION = SL.PRODUCTDEFVERSION
														AND	R.PROCESSSEGMENTID = SL.PROCESSSEGMENTID
					LEFT JOIN	PCM_LOT				L	on	L.LOTID = R.LOTID
					LEFT JOIN 	BAS_PLANT			PLT ON	PLT.PLANTID = R.PLANTID
					WHERE	1 = 1
					AND		COALESCE(R.RESULTTYPE, ' ') NOT IN ('SKIP')
					AND 	COALESCE(R.SENDPCSQTY, 0) > 0
					AND		R.WORKCOUNT = 0		
					AND 	L.LOTSTATE IN ('InProduction', 'InTransit')
				  	AND		R.PLANTID IN (#{PLANTID}, '', '*')
					AND		(#{WORKTYPE} IS NULL
							OR #{WORKTYPE} = CASE	WHEN L.LOTCREATEDTYPE = 'Return' THEN 'Return'
								                    WHEN L.LOTCREATEDTYPE = 'Repair' THEN 'MRB'
							                    	WHEN L.LOTCREATEDTYPE = 'Claim' THEN 'Claim'
							                    	ELSE 'Normal'
									    	END)
					<if test="PERIOD_PERIODFR != null and PERIOD_PERIODFR !='' and PERIOD_PERIODTO != null and PERIOD_PERIODTO !=''">
						AND R.SENDTIME <![CDATA[>=]]> TO_TIMESTAMP(SUBSTR(#{PERIOD_PERIODFR},1,14), 'YYYYMMDDHH24MISS')
						AND R.SENDTIME <![CDATA[<]]>  TO_TIMESTAMP(TO_CHAR(TO_DATE(SUBSTR(#{PERIOD_PERIODTO},1,8), 'YYYYMMDD'), 'YYYY-MM-DD') || ' ' || SUBSTR(#{PERIOD_PERIODTO}, 9, 6), 'YYYY-MM-DD HH24:MI:SS') 
					</if>
				) LWR 	ON	LWR.PRODUCTDEFID = SL.PRODUCTDEFID
						AND	LWR.PRODUCTDEFVERSION = SL.PRODUCTDEFVERSION
						AND	LWR.PROCESSSEGMENTID = SL.PROCESSSEGMENTID
						AND LWR.LOTID = L.LOTID
						
			)
			, BASE AS (
				SELECT
						B.PRODUCTDEFID
					,	B.PRODUCTDEFVERSION
					-- ,	ROW_NUMBER() OVER(PARTITION BY B.PRODUCTDEFID, B.PRODUCTDEFVERSION ORDER BY MAX(B.USERSEQUENCE::INT)) AS COL
					,	CASE	WHEN GROUPING(B.PRODUCTDEFID) = 0 AND GROUPING(B.PRODUCTDEFVERSION) = 0 AND GROUPING(B.PROCESSSEGMENTID) = 0  THEN ROW_NUMBER() OVER(PARTITION BY B.PRODUCTDEFID, B.PRODUCTDEFVERSION ORDER BY MAX(ROUND(B.USERSEQUENCE)))
								WHEN GROUPING(B.PRODUCTDEFID) + GROUPING(B.PRODUCTDEFVERSION) + GROUPING(B.PROCESSSEGMENTID) = 1  THEN 0
						END AS COL
					-- ,	B.PROCESSSEGMENTID
					,	CASE	WHEN GROUPING(B.PRODUCTDEFID) = 0 AND GROUPING(B.PRODUCTDEFVERSION) = 0 AND GROUPING(B.PROCESSSEGMENTID) = 0  THEN B.PROCESSSEGMENTID
								WHEN GROUPING(B.PRODUCTDEFID) + GROUPING(B.PRODUCTDEFVERSION) + GROUPING(B.PROCESSSEGMENTID) = 1 THEN 'TOTAL'
						END AS PROCESSSEGMENTID
					,	MAX(B.PLANTID) AS PLANTID
					,	CASE #{SUMMARYTYPE} 	WHEN 'PCS'	THEN ROUND(SUM(B.RESULT_PCSQTY)) 
											WHEN 'PNL'	THEN CEIL(SUM(B.RESULT_PCSQTY) / MAX(PD.PCSPNL))
											WHEN 'M2'	THEN ROUND((SUM(B.RESULT_PCSQTY) / MAX(PD.PCSMM)), 1)
											WHEN 'LOT'	THEN NULLIF(COUNT(B.RESULT_LOTID), 0)
						END AS RESULT_VALUE
					,	CASE #{SUMMARYTYPE}	WHEN 'PCS'	THEN ROUND(SUM(B.WIP_PCSQTY)) 
											WHEN 'PNL'	THEN CEIL(SUM(B.WIP_PCSQTY) / MAX(PD.PCSPNL))
											WHEN 'M2'	THEN ROUND((SUM(B.WIP_PCSQTY) / MAX(PD.PCSMM)), 1)
											WHEN 'LOT'	THEN NULLIF(COUNT(B.WIP_LOTID), 0)
						END AS WIP_VALUE
				FROM      	JOIN_BASE  				B
				INNER JOIN 	ALLSEGLIST				AL	ON 	AL.PROCESSSEGMENTID = B.PROCESSSEGMENTID
				INNER JOIN  BAS_PRODUCTDEFINITION 	PD 	ON  PD.PRODUCTDEFID = B.PRODUCTDEFID
												  		AND PD.PRODUCTDEFVERSION = B.PRODUCTDEFVERSION
				GROUP BY ROLLUP(B.PRODUCTDEFID,	B.PRODUCTDEFVERSION, B.PROCESSSEGMENTID)
				HAVING ((GROUPING(B.PRODUCTDEFID) = 0 AND GROUPING(B.PRODUCTDEFVERSION) = 0 AND GROUPING(B.PROCESSSEGMENTID) = 0) 
					OR (GROUPING(B.PRODUCTDEFID) + GROUPING(B.PRODUCTDEFVERSION) + GROUPING(B.PROCESSSEGMENTID) = 1))
			)
			, SUM_BASE AS (
				SELECT
				      	PRODUCTDEFID
				    ,	PRODUCTDEFVERSION
				    ,	COL
				    ,	PROCESSSEGMENTID
				    ,	PLANTID
				    , 	CASE #{SUMMARYTYPE} 	WHEN 'M2'	THEN TO_CHAR(SUM(RESULT_VALUE), '99,999,999,999,999,999.9')
				    						ELSE 			 TO_CHAR(SUM(RESULT_VALUE), '99,999,999,999,999,999')
				    	END AS RESULT_VALUE
				    , 	CASE #{SUMMARYTYPE} 	WHEN 'M2'	THEN TO_CHAR(SUM(WIP_VALUE), '99,999,999,999,999,999.9') 
				    						ELSE			 TO_CHAR(SUM(WIP_VALUE), '99,999,999,999,999,999')
				    	END AS WIP_VALUE
				FROM  	BASE
				GROUP BY	ROLLUP(COL, PRODUCTDEFID, PRODUCTDEFVERSION, PROCESSSEGMENTID, PLANTID)
				HAVING		GROUPING(COL) = 0
				AND			(GROUPING(PRODUCTDEFID) = 0 AND GROUPING(PRODUCTDEFVERSION) = 0  AND GROUPING(PROCESSSEGMENTID) = 0 AND GROUPING(PLANTID) = 0)
			
				UNION ALL
				
				SELECT
				      	NULL					AS PRODUCTDEFID
				    ,	NULL					AS PRODUCTDEFVERSION
				    ,	ALS.COL
				    ,	BAS.PROCESSSEGMENTID
				    ,	NULL					AS PLANTID
				    , 	CASE #{SUMMARYTYPE} 	WHEN 'M2'	THEN TO_CHAR(SUM(RESULT_VALUE), '99,999,999,999,999,999.9')
				    						ELSE 			 TO_CHAR(SUM(RESULT_VALUE), '99,999,999,999,999,999')
				    	END AS RESULT_VALUE
				    , 	CASE #{SUMMARYTYPE} 	WHEN 'M2'	THEN TO_CHAR(SUM(WIP_VALUE), '99,999,999,999,999,999.9') 
				    						ELSE			 TO_CHAR(SUM(WIP_VALUE), '99,999,999,999,999,999')
				    	END AS WIP_VALUE
				FROM		ALLSEGLIST	ALS  	
				JOIN		BASE		BAS	ON	BAS.PROCESSSEGMENTID = ALS.PROCESSSEGMENTID
				GROUP BY	ALS.COL, BAS.PROCESSSEGMENTID 
			)
			, MULT_BASE AS (
				SELECT
								PRODUCTDEFID
							,	PRODUCTDEFVERSION
							,	'1' AS "TYPE"
							,	'OPERATION' AS TYPENAME
							,	PROCESSSEGMENTID
							,	PROCESSSEGMENTID AS VALUE
						FROM	SUM_BASE
						UNION ALL
						SELECT
									PRODUCTDEFID
							,	PRODUCTDEFVERSION
							,	'2' AS "TYPE"
							,	'WIPSTOCK' AS TYPENAME
							,	PROCESSSEGMENTID
							,	WIP_VALUE AS VALUE
						FROM	SUM_BASE
						UNION ALL
						SELECT
									PRODUCTDEFID
							,	PRODUCTDEFVERSION
							,	'3' AS "TYPE"
							,	'OSPCLOSEACTUALAINFO' AS TYPENAME
							,	PROCESSSEGMENTID
							,	RESULT_VALUE AS VALUE
						FROM	SUM_BASE
						UNION ALL
						SELECT
									PRODUCTDEFID
							,	PRODUCTDEFVERSION
							,	'4' AS "TYPE"
							,	'PROCESSSEGMENTID' AS TYPENAME
							,	PROCESSSEGMENTID
							,	PROCESSSEGMENTID AS VALUE
						FROM	SUM_BASE
			)
			,	PROGRESS_RAW AS 
			(
				SELECT
						COALESCE(MB.PRODUCTDEFID, '') || ',' || COALESCE(MB.PRODUCTDEFVERSION, '') || ',' || TYPE AS ROW_NAME
					,	MB.PRODUCTDEFID
					,	MB.PRODUCTDEFVERSION
					,	MB.TYPE
					,	MB.TYPENAME
					,	MB.PROCESSSEGMENTID
					,	CASE WHEN MB.TYPE = '1' THEN COALESCE(SD.DICTIONARYNAME, MB.VALUE)
							ELSE VALUE
						END AS VALUE
				FROM 		MULT_BASE			MB
				LEFT JOIN	BAS_PROCESSSEGMENT	SEG	ON	MB.TYPE = '1'
													AND	SEG.PROCESSSEGMENTID = MB.VALUE
				LEFT JOIN	CMD_DICTIONARY		SD	ON	SD.DICTIONARYID = SEG.PROCESSSEGMENTNAME
													AND SD.LANGUAGETYPE = #{SESSION_LANGUAGETYPE}
			)
		SELECT * FROM PROGRESS_RAW
		)
		PIVOT
		(
			MAX(VALUE) AS VALUE
			FOR PROCESSSEGMENTID in(${COLUMNS})
		) 
	) T
--	LEFT JOIN	CT_WAREHOUSESTOCKPERPRODUCT WH	ON 	WH.PRODUCTDEFID = T.PRODUCTDEFID
--												AND	WH.PRODUCTDEFVERSION = T.PRODUCTDEFVERSION
--												AND WH.WAREHOUSEID = 'P1011'
	LEFT JOIN	BAS_PRODUCTDEFINITION		PD	ON	PD.PRODUCTDEFID = T.PRODUCTDEFID
												AND	PD.PRODUCTDEFVERSION = T.PRODUCTDEFVERSION
	LEFT JOIN	CMD_DICTIONARY				TD	ON	TD.DICTIONARYID = T.TYPENAME
												AND	TD.LANGUAGETYPE = #{SESSION_LANGUAGETYPE}
	WHERE		T.DISPLAY = 'Y'
	ORDER BY	CASE WHEN PD.PRODUCTIONTYPE = 'Production' THEN 1 ELSE 2 END, PD.PRODUCTDEFID, PD.PRODUCTDEFVERSION, T."TYPE"	   	  	
	</select>
	
	<select id="selectProgressPerProductWipList" parameterType="map" resultType="hashmap">
	/* "SelectProgressPerProductWipList" 10001 */
	--id : selectProgressPerProductWipList
	SELECT
				L.LOTID																									-- LOT ID
			,	COALESCE(SGD.DICTIONARYNAME, SEG.PROCESSSEGMENTNAME, L.PROCESSSEGMENTID) AS PROCESSSEGMENTNAME			-- 공정명
			,	PT.PROCESSUOM																							-- 단위
		<choose>
			<when test='SUMMARYTYPE == "PNL"'>		
				,	CASE WHEN L.PROCESSSTATE = 'WaitForReceive' THEN CEIL(L.QTY / NULLIF(PD.PCSPNL, 0)) ELSE NULL END AS SENDPCSQTY -- 인계 수량
				,	CASE WHEN L.PROCESSSTATE = 'Wait'			THEN CEIL(L.QTY / NULLIF(PD.PCSPNL, 0)) ELSE NULL END AS RECEIVEPCSQTY					-- 인수 수량
				,	CASE WHEN L.PROCESSSTATE = 'Run'			THEN CEIL(L.QTY / NULLIF(PD.PCSPNL, 0)) ELSE NULL END AS WORKSTARTPCSQTY					-- 작업시작 수량
				,	CASE WHEN L.PROCESSSTATE = 'WaitForSend'	THEN CEIL(L.QTY / NULLIF(PD.PCSPNL, 0)) ELSE NULL END AS WORKENDPCSQTY 					-- 작업완료 수량
			</when>
			<when test='SUMMARYTYPE == "M2"'>		
				,	CASE WHEN L.PROCESSSTATE = 'WaitForReceive' THEN ROUND((L.QTY / NULLIF(PD.PCSMM, 0)), 1) ELSE NULL END AS SENDPCSQTY 						-- 인계 수량
				,	CASE WHEN L.PROCESSSTATE = 'Wait'			THEN ROUND((L.QTY / NULLIF(PD.PCSMM, 0)), 1) ELSE NULL END AS RECEIVEPCSQTY					-- 인수 수량
				,	CASE WHEN L.PROCESSSTATE = 'Run'			THEN ROUND((L.QTY / NULLIF(PD.PCSMM, 0)), 1) ELSE NULL END AS WORKSTARTPCSQTY					-- 작업시작 수량
				,	CASE WHEN L.PROCESSSTATE = 'WaitForSend'	THEN ROUND((L.QTY / NULLIF(PD.PCSMM, 0)), 1) ELSE NULL END AS WORKENDPCSQTY 					-- 작업완료 수량
			</when>
			<otherwise>
				,	CASE WHEN L.PROCESSSTATE = 'WaitForReceive' THEN L.QTY ELSE NULL END AS SENDPCSQTY 						-- 인계 수량
				,	CASE WHEN L.PROCESSSTATE = 'WaitForReceive' THEN SLF.INSPECTIONQTY ELSE NULL END AS SELFINSPECTIONQTY	-- 자주검사(입고) 수량
				,	CASE WHEN L.PROCESSSTATE = 'Wait'			THEN L.QTY ELSE NULL END AS RECEIVEPCSQTY					-- 인수 수량
				,	CASE WHEN L.PROCESSSTATE = 'Run'			THEN L.QTY ELSE NULL END AS WORKSTARTPCSQTY					-- 작업시작 수량
				,	CASE WHEN L.PROCESSSTATE = 'Run'			THEN SHP.INSPECTIONQTY ELSE NULL END AS SHIPINSPECTIONQTY	-- 출하검사 수량
				,	CASE WHEN L.PROCESSSTATE = 'WaitForSend'	THEN L.QTY ELSE NULL END AS WORKENDPCSQTY 					-- 작업완료 수량
			</otherwise>
		</choose>
			,	COALESCE(ARD.DICTIONARYNAME, AR.AREANAME, L.AREAID) AS AREANAME											-- 작업처
			,	CASE WHEN L.PROCESSSTATE = 'WaitForReceive' THEN NULL ELSE ROUND((TRUNC(CURRENT_TIMESTAMP, 'MI') - L.RECEIVETIME) * 24, 1) END AS STAYINGHOUR -- 체공시간
			,	COALESCE (L.SENDTIME,LW.CREATEDTIME )															AS SENDTIME				-- 인계 시간
			,	CASE WHEN L.PROCESSSTATE = 'WaitForReceive' THEN SLF.INSPECTIONDATE ELSE NULL END 				AS SELFINSPECTIONDATE	-- 자주검사(입고) 시간
			,	CASE WHEN L.PROCESSSTATE IN ('Wait', 'Run', 'WaitForSend') THEN L.RECEIVETIME ELSE NULL END 	AS RECEIVETIME			-- 인수 시간
			,	CASE WHEN L.PROCESSSTATE IN ('Run', 'WaitForSend') THEN L.TRACKINTIME ELSE NULL END 			AS WORKSTARTTIME		-- 작업시작 시간
			,	CASE WHEN L.PROCESSSTATE = 'Run'			THEN SHP.INSPECTIONDATE ELSE NULL END				AS SHIPINSPECTIONDATE	-- 출하검사 시간
			,	CASE WHEN L.PROCESSSTATE IN ('WaitForSend')	THEN L.TRACKOUTTIME ELSE NULL END 					AS WORKENDTIME			-- 작업완료 시간
			/*
		    ,	ROUND(CASE	WHEN L.PROCESSSTATE = 'WaitForReceive' THEN DATEDIFF('SS', L.SENDTIME :: TIMESTAMP , CURRENT_TIMESTAMP :: TIMESTAMP)
							WHEN L.PROCESSSTATE = 'Wait'           THEN DATEDIFF('SS', L.RECEIVETIME :: TIMESTAMP , CURRENT_TIMESTAMP :: TIMESTAMP)
							WHEN L.PROCESSSTATE = 'Run'            THEN DATEDIFF('SS', L.TRACKINTIME :: TIMESTAMP , CURRENT_TIMESTAMP :: TIMESTAMP)
							WHEN L.PROCESSSTATE = 'WaitForSend'    THEN DATEDIFF('SS', L.TRACKOUTTIME :: TIMESTAMP , CURRENT_TIMESTAMP :: TIMESTAMP)
					END / 3600.0, 1) AS STAYINGHOUR																		-- 체공시간(단위:시간)
			*/
			/*
			,	CASE WHEN L.PROCESSSTATE = 'WaitForReceive' THEN L.SENDTIME ELSE NULL END AS SENDTIME					-- 인계 시간
			,	CASE WHEN L.PROCESSSTATE = 'WaitForReceive' THEN SLF.INSPECTIONDATE ELSE NULL END AS SELFINSPECTIONDATE	-- 자주검사(입고) 시간
			,	CASE WHEN L.PROCESSSTATE = 'Wait'			THEN L.RECEIVETIME ELSE NULL END AS RECEIVETIME				-- 인수 시간
			,	CASE WHEN L.PROCESSSTATE = 'Run'			THEN L.TRACKINTIME ELSE NULL END AS WORKSTARTTIME			-- 작업시작 시간
			,	CASE WHEN L.PROCESSSTATE = 'Run'			THEN SHP.INSPECTIONDATE ELSE NULL END AS SHIPINSPECTIONDATE	-- 출하검사 시간
			,	CASE WHEN L.PROCESSSTATE = 'WaitForSend'	THEN L.TRACKOUTTIME ELSE NULL END AS WORKENDTIME			-- 작업완료 시간
			*/
		FROM		UFN_SELECTSTRINGTOSPLIT3(#{PRODUCTSEGMENT}, ',', '|')	M
		INNER JOIN	PCM_LOT					L	ON	L.PRODUCTDEFID = M.VALUE
												AND	L.PRODUCTDEFVERSION = M.VALUE2
												AND (L.PROCESSSEGMENTID = M.VALUE3 OR M.VALUE3 = '*')
		INNER JOIN	BAS_PRODUCTDEFINITION 	PD	ON	PD.PRODUCTDEFID = L.PRODUCTDEFID
												AND	PD.PRODUCTDEFVERSION = L.PRODUCTDEFVERSION
		--INNER JOIN PCM_LOTWORKRESULT          LW ON  L.LOTID = LW.LOTID 
		--                                        AND L.PROCESSSEGMENTID  = LW.PROCESSSEGMENTID 
		--                                        AND L.WORKCOUNT  = LW.WORKCOUNT
		LEFT JOIN PCM_LOTWORKRESULT          LW ON L.LOTID                  = LW.LOTID             
												AND L.PROCESSSEGMENTID      = LW.PROCESSSEGMENTID 
												AND L.USERSEQUENCE   = LW.USERSEQUENCE 
												AND LW.RESULTTYPE = 'NORMAL' 
												AND L.WORKCOUNT = LW.WORKCOUNT	 														
		LEFT JOIN	BAS_PROCESSSEGMENT		SEG	ON	SEG.PROCESSSEGMENTID = L.PROCESSSEGMENTID
		LEFT JOIN	CMD_DICTIONARY			SGD	ON	SGD.DICTIONARYID = SEG.PROCESSSEGMENTNAME
												AND	SGD.LANGUAGETYPE = #{SESSION_LANGUAGETYPE}
		LEFT JOIN	BAS_PROCESSPATH			PT	ON	PT.PROCESSPATHID = SPLIT_PART(L.PROCESSPATHSTACK, '.', 1)
		LEFT JOIN	BAS_AREA					AR	ON	AR.AREAID = L.AREAID
		LEFT JOIN	CMD_DICTIONARY			ARD	ON	ARD.DICTIONARYID = AR.AREANAME
												AND	ARD.LANGUAGETYPE = #{SESSION_LANGUAGETYPE}
		LEFT JOIN	QAM_INSPECTIONRESULT		SLF	ON	SLF.RESOURCEID = L.LOTID
												AND	SLF.RESOURCETYPE = 'SelfInspectionTake'
												AND	SLF.PROCESSSEGMENTID = L.PROCESSSEGMENTID
												AND SLF.WORKCOUNT = L.WORKCOUNT
												AND	SLF."degree" =
													(
														SELECT	MAX(INS."degree")
														FROM	QAM_INSPECTIONRESULT		INS
														WHERE	INS.RESOURCEID = SLF.RESOURCEID
														AND		INS.RESOURCETYPE = SLF.RESOURCETYPE
														AND		INS.PROCESSSEGMENTID = SLF.PROCESSSEGMENTID
														AND 	INS.WORKCOUNT = SLF.WORKCOUNT
													)
		LEFT JOIN	QAM_INSPECTIONRESULT		SHP	ON	SHP.RESOURCEID = L.LOTID
												AND	SHP.RESOURCETYPE = 'ShipmentInspection'
												AND	SHP.PROCESSSEGMENTID = L.PROCESSSEGMENTID
												AND SHP.WORKCOUNT = L.WORKCOUNT
												AND	SHP."degree" =
													(
														SELECT	MAX(INS."degree")
														FROM	QAM_INSPECTIONRESULT		INS
														WHERE	INS.RESOURCEID = SHP.RESOURCEID
														AND		INS.RESOURCETYPE = SHP.RESOURCETYPE
														AND		INS.PROCESSSEGMENTID = SHP.PROCESSSEGMENTID
														AND 	INS.WORKCOUNT = SHP.WORKCOUNT
													)
		WHERE	1 = 1
		AND	COALESCE(LW.RESULTTYPE, ' ') NOT IN ('SKIP')
		AND L.LOTSTATE IN ('InProduction', 'InTransit')
		AND COALESCE(L.ISDEFECTED, 'N') = 'N'
		AND COALESCE(L.ISREPRESENTROLLLOT, 'N') = 'N'
		<if test="PLANTID != null and PLANTID !=''">
			AND     L.PLANTID = #{PLANTID}
		</if>	
		-- Hold 
		<if test="ISHOLD != null and ISHOLD !=''">
			AND     L.ISHOLD = #{ISHOLD}
		</if>
				
	</select>
	<select id="selectProgressPerProductResultList" parameterType="map" resultType="hashmap">
	/* "SelectProgressPerProductResultList" 10001 */
	--id : selectProgressPerProductResultList
	SELECT
				LWR.LOTID						-- LOT ID
			,	LWR.PROCESSSEGMENTID			-- 공정 ID
			,	LWR.WORKCOUNT					-- 작업차수
			,	COALESCE(MAX(SD.DICTIONARYNAME), MAX(SEG.PROCESSSEGMENTNAME), MAX(LWR.PROCESSSEGMENTID)) AS PROCESSSEGMENTNAME	-- 공정명
			,	MAX(PT.PROCESSUOM) AS PROCESSUOM								-- 단위
			,	CEIL(MAX(LWR.SENDPCSQTY) / MAX(PD.PCSPNL)) AS RESULT_PNLQTY		-- 실적 PNL 수량
			,	ROUND(MAX(LWR.SENDPCSQTY)) AS RESULT_PCSQTY						-- 실적 PCS 수량
			,	ROUND((MAX(LWR.SENDPCSQTY) / NULLIF(MAX(PD.PCSMM), 0)), 1) AS RESULT_MMQTY	-- 실적 MM 수량
			,	CEIL(SUM(DL.DEFECTQTY) / MAX(PD.PCSPNL)) AS DEFECT_PNLQTY		-- 불량 PNL 수량
			,	ROUND(SUM(DL.DEFECTQTY)) AS DEFECT_PCSQTY						-- 불량 PCS 수량
			,	ROUND((SUM(DL.DEFECTQTY) / NULLIF(MAX(PD.PCSMM), 0)), 1) AS DEFECT_MMQTY		-- 불량 MM 수량
			,	MAX(LWR.AREAID) AS AREAID															-- 작업처 ID
			,	COALESCE(MAX(AD.DICTIONARYNAME), MAX(AR.AREANAME), MAX(LWR.AREAID)) AS AREANAME		-- 작업처명
			,	ROUND((MAX(LWR.SENDTIME) - MAX(LWR.RECEIVETIME)) * 24, 1) AS STAYINGHOUR 	-- 체공시간(단위:시간, 인계시간 - 인수시간)
			,	MAX(LWR.RECEIVETIME) AS RECEIVETIME					-- 인수 시간
			,	MAX(SLF.INSPECTIONDATE) AS SELFINSPECTIONDATE		-- 자주검사(입고) 시간
			,	MAX(LWR.WORKSTARTTIME) AS WORKSTARTTIME				-- 작업시작 시간
			,	MAX(SHP.INSPECTIONDATE) AS SHIPINSPECTIONDATE		-- 출하검사 시간
			,	MAX(LWR.WORKENDTIME) AS WORKENDTIME					-- 작업완료 시간
			,	MAX(LWR.SENDTIME) AS SENDTIME						-- 인계 시간
		FROM	UFN_SELECTSTRINGTOSPLIT3(#{PRODUCTSEGMENT}, ',', '|')	M
		INNER JOIN	PCM_LOTWORKRESULT		LWR	ON	LWR.PRODUCTDEFID = M.VALUE
												AND	LWR.PRODUCTDEFVERSION = M.VALUE2
												AND (LWR.PROCESSSEGMENTID = M.VALUE3 OR M.VALUE3 = '*')
		INNER JOIN	BAS_PLANT				PLT	ON	PLT.PLANTID = LWR.PLANTID
		LEFT JOIN	BAS_PRODUCTDEFINITION	PD	ON	PD.PRODUCTDEFID = LWR.PRODUCTDEFID
												AND	PD.PRODUCTDEFVERSION = LWR.PRODUCTDEFVERSION
		LEFT JOIN	BAS_PROCESSPATH			PT	ON	PT.PROCESSPATHID = LWR.PROCESSPATHID 
		LEFT JOIN	PCM_LOT					DL	ON	DL.PARENTLOTID = LWR.LOTID
												AND DL.ISDEFECTED = 'Y'
												AND DL.PROCESSSEGMENTID = LWR.PROCESSSEGMENTID
		LEFT JOIN	QAM_INSPECTIONRESULT		SLF	ON	SLF.RESOURCEID = LWR.LOTID
												AND	SLF.RESOURCETYPE = 'SelfInspectionTake'
												AND	SLF.PROCESSSEGMENTID = LWR.PROCESSSEGMENTID
												AND SLF.WORKCOUNT = LWR.WORKCOUNT
												AND	SLF."degree" =
													(
														SELECT	MAX(INS."degree")
														FROM	QAM_INSPECTIONRESULT		INS
														WHERE	INS.RESOURCEID = SLF.RESOURCEID
														AND		INS.RESOURCETYPE = SLF.RESOURCETYPE
														AND		INS.PROCESSSEGMENTID = SLF.PROCESSSEGMENTID
														AND 	INS.WORKCOUNT = SLF.WORKCOUNT
													)
		LEFT JOIN	QAM_INSPECTIONRESULT		SHP	ON	SHP.RESOURCEID = LWR.LOTID
												AND	SHP.RESOURCETYPE = 'ShipmentInspection'
												AND	SHP.PROCESSSEGMENTID = LWR.PROCESSSEGMENTID
												AND SHP.WORKCOUNT = LWR.WORKCOUNT
												AND	SHP."degree" =
													(
														SELECT	MAX(INS."degree")
														FROM	QAM_INSPECTIONRESULT		INS
														WHERE	INS.RESOURCEID = SHP.RESOURCEID
														AND		INS.RESOURCETYPE = SHP.RESOURCETYPE
														AND		INS.PROCESSSEGMENTID = SHP.PROCESSSEGMENTID
														AND 	INS.WORKCOUNT = SHP.WORKCOUNT
													)
		LEFT JOIN	BAS_PROCESSSEGMENT		SEG	ON	SEG.PROCESSSEGMENTID = LWR.PROCESSSEGMENTID
												AND	SEG.PROCESSSEGMENTVERSION = LWR.PROCESSSEGMENTVERSION
		LEFT JOIN	CMD_DICTIONARY			SD	ON	SD.DICTIONARYID = SEG.PROCESSSEGMENTNAME
												AND	SD.LANGUAGETYPE = #{SESSION_LANGUAGETYPE}
		LEFT JOIN	BAS_AREA					AR	ON	AR.AREAID = LWR.AREAID	
		LEFT JOIN	CMD_DICTIONARY			AD	ON	AD.DICTIONARYID = AR.AREANAME
												AND	AD.LANGUAGETYPE = #{SESSION_LANGUAGETYPE}
		LEFT JOIN	PCM_LOT					LOT	ON	LOT.LOTID = LWR.LOTID
		WHERE	1 = 1 
		AND		COALESCE(LWR.RESULTTYPE, ' ') NOT IN ('SKIP')
		AND 	COALESCE(LWR.SENDPCSQTY, 0) > 0		
		AND		LWR.WORKCOUNT = 0
		AND		COALESCE(LOT.LOTSTATE, ' ') != 'Terminated'
		AND		COALESCE(LOT.LOTSTATE, ' ') != 'Finished'
		<if test="PLANTID != null and PLANTID !=''">
			AND     LWR.PLANTID = #{PLANTID}
		</if>		
		<if test="PERIOD_PERIODFR != null and PERIOD_PERIODFR !='' and PERIOD_PERIODTO != null and PERIOD_PERIODTO !=''">
			AND LWR.SENDTIME <![CDATA[>=]]> TO_TIMESTAMP(SUBSTR(#{PERIOD_PERIODFR},1,14), 'YYYYMMDDHH24MISS')
			AND LWR.SENDTIME <![CDATA[<]]>  TO_TIMESTAMP(TO_CHAR(TO_DATE(SUBSTR(#{PERIOD_PERIODTO},1,8), 'YYYYMMDD'), 'YYYY-MM-DD') || ' ' || SUBSTR(#{PERIOD_PERIODTO}, 9, 6), 'YYYY-MM-DD HH24:MI:SS') 
		</if>
		GROUP BY	LWR.LOTID
				,	LWR.PROCESSSEGMENTID
				,	LWR.WORKCOUNT
		ORDER BY	LWR.LOTID
				,	LWR.PROCESSSEGMENTID
				,	LWR.WORKCOUNT
	</select>
	
</mapper>