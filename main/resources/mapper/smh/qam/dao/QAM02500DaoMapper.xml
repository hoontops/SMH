<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE mapper
  PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN"
  "http://mybatis.org/dtd/mybatis-3-mapper.dtd">
<mapper namespace="smh.qam.dao.QAM02500Dao">

    <!-- desc   : 일별 수율현황>>일별 수율 조회
         modify : 일별 수율현황 수율 = 100 - 불량율(양품수도 변경됨)
         asis => SelectYieldRateByDay_10001
    -->
    <select id="selectYieldRateByDayList" parameterType="map" resultType="hashmap">
        /* smh.qam.dao.QAM02500Dao.selectYieldRateByDayList */
        WITH FINALDATA AS
        (
            SELECT YS.*
                 , PS.PROCESSSEGMENTVERSION
                 , RANK() OVER (PARTITION BY ROOTLOTID, LOTID ORDER BY TO_NUMBER(USERSEQUENCE), TO_NUMBER(SUBUSERSEQUENCE), WORKCOUNT DESC)   AS RNK
              FROM       PCM_YIELDSUMMARY        YS
              INNER JOIN BAS_PROCESSSEGMENT      PS  ON YS.PROCESSSEGMENTID = PS.PROCESSSEGMENTID
             WHERE YS.SUMMARYDATE >=  TO_DATE(#{P_PERIODFR}, 'YYYY-MM-DD HH24:MI:SS')
               AND YS.SUMMARYDATE <![CDATA[<]]> TO_DATE(#{P_PERIODTO}, 'YYYY-MM-DD HH24:MI:SS')
               AND YS.SUMMARYTYPE = 'Normal'
               AND YS.SENDTIME IS NOT NULL
            <choose>
            <when test="P_INSPTYPE eq 'SHIPMENT'.toString() ">
               AND PS.PROCESSSEGMENTCLASSID IN ('7030','7536')
            </when>
            <when test="P_INSPTYPE eq 'FINISH'.toString() ">
               AND PS.PROCESSSEGMENTCLASSID IN ('7026','7534')
            </when>
            <otherwise>
               AND PS.PROCESSSEGMENTCLASSID IN ('8012','8014')
            </otherwise>
            </choose>
            <if test="P_INSPECTIONPROCESS != null and P_INSPECTIONPROCESS !='' and !(P_INSPECTIONPROCESS eq 'Final'.toString())">
            AND     YS.PROCESSSEGMENTID = '$!{P_INSPECTIONPROCESS}'
            </if>
            <if test="P_PRODUCTDEFID != null and P_PRODUCTDEFID !='' ">
               AND YS.PRODUCTDEFID||YS.PRODUCTDEFVERSION IN (SELECT regexp_substr(#{P_PRODUCTDEFID}, '[^,]+', 1, LEVEL)
                                                               FROM dual
                                                             CONNECT BY LEVEL <![CDATA[<=]]> length(#{P_PRODUCTDEFID})-length(replace(#{P_PRODUCTDEFID},',',''))+1)
            </if>
            <if test="P_ROOTLOT != null and P_ROOTLOT !='' ">
               AND YS.ROOTLOTID IN (SELECT regexp_substr(#{P_ROOTLOT}, '[^,]+', 1, LEVEL)
                                      FROM dual
                                    CONNECT BY LEVEL <![CDATA[<=]]> length(#{P_ROOTLOT})-length(replace(#{P_ROOTLOT},',',''))+1)
            </if>
            <if test="P_LOTNO != null and P_LOTNO !='' ">
               AND YS.LOTID IN (SELECT regexp_substr(#{P_LOTNO}, '[^,]+', 1, LEVEL)
                                  FROM dual
                                CONNECT BY LEVEL <![CDATA[<=]]> length(#{P_LOTNO})-length(replace(#{P_LOTNO},',',''))+1)
            </if>
            UNION ALL
            SELECT YS.*
                 , PS.PROCESSSEGMENTVERSION
                 , RANK() OVER (PARTITION BY ROOTLOTID, LOTID ORDER BY TO_NUMBER(USERSEQUENCE), TO_NUMBER(SUBUSERSEQUENCE), WORKCOUNT DESC)   AS RNK
              FROM       PCM_YIELDSUMMARY     YS
              INNER JOIN BAS_PROCESSSEGMENT   PS  ON YS.PROCESSSEGMENTID = PS.PROCESSSEGMENTID
             WHERE YS.SUMMARYDATE >=  TO_DATE(#{P_PERIODFR}, 'YYYY-MM-DD HH24:MI:SS')
               AND YS.SUMMARYDATE <![CDATA[<]]> TO_DATE(#{P_PERIODTO}, 'YYYY-MM-DD HH24:MI:SS')
               AND YS.SUMMARYTYPE = 'CompleteDefect'
            <if test="P_PRODUCTDEFID != null and P_PRODUCTDEFID !='' ">
               AND YS.PRODUCTDEFID||YS.PRODUCTDEFVERSION IN (SELECT regexp_substr(#{P_PRODUCTDEFID}, '[^,]+', 1, LEVEL)
                                                               FROM dual
                                                             CONNECT BY LEVEL <![CDATA[<=]]> length(#{P_PRODUCTDEFID})-length(replace(#{P_PRODUCTDEFID},',',''))+1)
            </if>
            <if test="P_ROOTLOT != null and P_ROOTLOT !='' ">
               AND YS.ROOTLOTID IN (SELECT regexp_substr(#{P_ROOTLOT}, '[^,]+', 1, LEVEL)
                                      FROM dual
                                    CONNECT BY LEVEL <![CDATA[<=]]> length(#{P_ROOTLOT})-length(replace(#{P_ROOTLOT},',',''))+1)
            </if>
            <if test="P_LOTNO != null and P_LOTNO !='' ">
               AND YS.LOTID IN (SELECT regexp_substr(#{P_LOTNO}, '[^,]+', 1, LEVEL)
                                  FROM dual
                                CONNECT BY LEVEL <![CDATA[<=]]> length(#{P_LOTNO})-length(replace(#{P_LOTNO},',',''))+1)
            </if>
        ),
        BASETGT AS
        (
            SELECT DISTINCT LO.LOCALE
                 , SM.SHIPSITE                                  AS SHIPMENTSITE
                 , CASE WHEN LO.LOCALE = 'Local' THEN SM.SHIPSITE
                <choose>
                <when test="P_LINKPLANTID != null and P_LINKPLANTID !='' and !(P_LINKPLANTID eq '*'.toString())">
                    ELSE RP.RELATEPLANTID END                   AS RELATEDSITE
                </when>
                <otherwise>
                    ELSE ''               END                   AS RELATEDSITE
                </otherwise>
                </choose>
                 , PIS.PRODUCTTYPE                              AS PRODUCTSHAPE
                 , PIS.CUSTOMERID
                 , PIS.CUSTOMERNAME                             AS COMPANYCLIENT
                 , SPD.PRODUCTDEFNAME                           AS PRODUCTDEFNAME
                 , RP.RELATEPLANTID
                 , IQ.PLANTID
                 , IQ.INPUTQTY                                  AS PCSINPUTQTY
                 , FD.ROOTLOTID
                 , FD.LOTID
                 , FD.PLANTID                                   AS LOTCREATEDPLANTID
                 , FD.PRODUCTDEFID
                 , FD.PRODUCTDEFVERSION
                 , FD.PROCESSDEFID
                 , FD.PROCESSDEFVERSION
                 , FD.PROCESSSEGMENTID
                 , FD.USERSEQUENCE
                 , FD.SUBUSERSEQUENCE
                 , FD.WORKCOUNT
                 , DC1.DICTIONARYNAME                           AS INSPPROCESSSEGMENT
                 , FD.SUMMARYTYPE
                 , FD.SUMMARYDATE
                 , FD.SENDTIME
                 , FD.CREATEDTIME
                <choose>
                <when test="P_LOTSTANDARD != null and P_LOTSTANDARD !='' and (P_LOTSTANDARD eq 'ROOTLOT'.toString())">
                 , CASE WHEN RLC.LOTCOUNT = RLC.ENDLOTCOUNT THEN 'COMPLETE'
                   ELSE ''
                   END                                          AS ROOTCOMPLETE
                </when>
                <otherwise>
                 , ''                                           AS ROOTCOMPLETE
                </otherwise>
                </choose>
                 , PIS.PCSSIZEXAXIS*PIS.PCSSIZEYAXIS            AS M2SIZE
                 , PIS.PCSMM                                    AS AREADIV
                 , SOA.UNITPRICE                                AS UNITPRICE
                 , SOA.CURRENCY
                 , LTD.DICTIONARYNAME                           AS PRODUCTDEFTYPE
              FROM       FINALDATA                                                     FD
              INNER JOIN PCM_LOT                                                       L    ON   FD.LOTID               = L.LOTID
              /*--2016.06.16 TOBE Modify
              LEFT JOIN  FN_GETYIELDLOCALE(FD.PRODUCTDEFID||FD.PRODUCTDEFVERSION)      LO   ON   LO.PRODUCTDEFID        = FD.PRODUCTDEFID
                                                                                            AND  LO.PRODUCTDEFVERSION   = FD.PROCESSDEFVERSION*/
              LEFT JOIN  QAM_YIELD_LOCALE_V                                            LO   ON   LO.PRODUCTDEFID        = FD.PRODUCTDEFID
                                                                                            AND  LO.PRODUCTDEFVERSION   = FD.PRODUCTDEFVERSION
              LEFT JOIN  FN_GETYIELDSHIPMENT(FD.LOTID, FD.PRODUCTDEFID, FD.PRODUCTDEFVERSION)
                                                                                       SM   ON   SM.RETLOTID            = FD.LOTID
              LEFT JOIN  FN_GETYIELDRELPLANT(FD.LOTID, FD.PROCESSDEFID, FD.PROCESSDEFVERSION)
                                                                                       RP   ON   RP.RETLOTID            = FD.LOTID
                                                                                            AND  RP.RETPROCESSDEFID     = FD.PROCESSDEFID
                                                                                            AND  RP.LV                  > 0
            <if test="P_LOTSTANDARD != null and P_LOTSTANDARD !='' and (P_LOTSTANDARD eq 'ROOTLOT'.toString())">
              LEFT JOIN    FN_GETYIELDROOTCOMPLETE(FD.ROOTLOTID,#{P_INSPTYPE})         RLC  ON   RLC.RETROOTLOTID       = FD.ROOTLOTID
            </if>
            <choose>
            <when test="P_INTERPLANTID != null and P_INTERPLANTID !='' and !(P_INTERPLANTID eq '*'.toString()) ">
              LEFT JOIN FN_GETYIELDINPUTQTY2(FD.LOTID, #{P_INTERPLANTID})             IQ   ON   FD.LOTID               = IQ.LOTID
                                                                                           AND  IQ.RNK                 = 1
            </when>
            <otherwise>
              LEFT JOIN FN_GETYIELDINPUTQTY2(FD.LOTID, '*')                           IQ   ON   FD.LOTID               = IQ.LOTID
                                                                                           AND  IQ.RNK                 = 1
            </otherwise>
            </choose>
              LEFT JOIN BAS_PRODUCTDEFINITION                                          SPD  ON   SPD.PRODUCTDEFID       = FD.PRODUCTDEFID
                                                                                            AND  SPD.PRODUCTDEFVERSION  = FD.PRODUCTDEFVERSION
              LEFT JOIN BAS_PROCESSSEGMENT                                             SG   ON   SG.PROCESSSEGMENTID    = FD.PROCESSSEGMENTID
              LEFT JOIN CMD_DICTIONARY                                                 DC1  ON   SG.PROCESSSEGMENTNAME  = DC1.DICTIONARYID
                                                                                            AND  DC1.LANGUAGETYPE       = #{LANGUAGETYPE}
              LEFT JOIN BAS_PRODUCTITEMSPEC                                            PIS  ON   PIS.ITEMID             = FD.PRODUCTDEFID
                                                                                            AND  PIS.ITEMVERSION        = FD.PRODUCTDEFVERSION
              LEFT JOIN MFM_PRODUCTIONORDER                                            PO   ON   PO.PRODUCTIONORDERID   = L.PRODUCTIONORDERID
                                                                                            AND  PO.LINENO              = L.LINENO
                                                                                            AND  PO.ENTERPRISEID        = L.ENTERPRISEID
              LEFT JOIN BAS_SALEORDERAPPROVAL                                          SOA  ON   SOA.SALESORDERID       = L.PRODUCTIONORDERID
                                                                                            AND  SOA.LINENO             = L.LINENO
                                                                                            AND  SOA.ENTERPRISEID       = L.ENTERPRISEID
              LEFT JOIN CMD_LOOKUP_VALUES                                              LTC  ON   LTC.LOOKUP_CODE        = L.LOTTYPE
                                                                                            AND  LTC.LOOKUP_TYPE        = 'ProductionType'
              LEFT JOIN CMD_DICTIONARY                                                 LTD  ON   LTD.DICTIONARYID       = LTC.DICTIONARYID
                                                                                            AND  LTD.LANGUAGETYPE       = #{LANGUAGETYPE}
             WHERE FD.RNK =1
            <if test="P_PRODUCTIONDIVISION != null and P_PRODUCTIONDIVISION !='' and !(P_PRODUCTIONDIVISION eq '*'.toString()) ">
               AND L.LOTTYPE = #{P_PRODUCTIONDIVISION}
            </if>
        ),
        LOTDFDTL AS
        (
            SELECT DL.*
              FROM      BASETGT    BT
              LEFT JOIN FN_GETYIELDDEFECTLIST(BT.LOTID, #{LANGUAGETYPE})  DL    ON   DL.LOTID = BT.LOTID
            <if test="P_INSPECTIONPROCESS != null and P_INSPECTIONPROCESS !='' and !(P_INSPECTIONPROCESS eq 'Final'.toString())">
                                                                                AND  (DL.USERSEQUENCE||'.'||DL.SUBUSERSEQUENCE) <![CDATA[<=]]>  (BT.USERSEQUENCE||'.'||BT.SUBUSERSEQUENCE)
                                                                                AND  DL.WORKCOUNT <![CDATA[<=]]>  BT.WORKCOUNT
            </if>
             WHERE 1=1
               AND DL.SUMMARYTYPE = 'Normal'
            <if test="P_EXCEPTDEFECTCLASS != null and P_EXCEPTDEFECTCLASS !='' and !(P_EXCEPTDEFECTCLASS eq '*'.toString())">
               AND DL.DEFECTCODECLASSID NOT IN (SELECT regexp_substr(#{P_EXCEPTDEFECTCLASS}, '[^,]+', 1, LEVEL)
                                                  FROM dual
                                                CONNECT BY LEVEL <![CDATA[<=]]> length(#{P_EXCEPTDEFECTCLASS})-length(replace(#{P_EXCEPTDEFECTCLASS},',',''))+1)
            </if>
            UNION ALL
            SELECT DL.*
              FROM      BASETGT    BT
              LEFT JOIN FN_GETYIELDDEFECTLIST(BT.LOTID, #{LANGUAGETYPE})    DL    ON DL.LOTID = BT.LOTID
             WHERE 1=1
               AND DL.SUMMARYTYPE = 'CompleteDefect'
            <if test="P_EXCEPTDEFECTCLASS != null and P_EXCEPTDEFECTCLASS !='' and !(P_EXCEPTDEFECTCLASS eq '*'.toString())">
               AND DL.DEFECTCODECLASSID NOT IN (SELECT regexp_substr(#{P_EXCEPTDEFECTCLASS}, '[^,]+', 1, LEVEL)
                                                  FROM dual
                                                CONNECT BY LEVEL <![CDATA[<=]]> length(#{P_EXCEPTDEFECTCLASS})-length(replace(#{P_EXCEPTDEFECTCLASS},',',''))+1)
            </if>
        ),
        DFSUM AS
        (
           <choose>
           <when test="P_INTERPLANTID != null and P_INTERPLANTID !='' and !(P_INTERPLANTID eq '*'.toString())">
            SELECT DD.LOTID
                 , DD.DISCOVERYSITE           AS PLANTID
                 , NVL(SUM(DD.DEFECTQTY), 0)  AS DEFECTQTY
              FROM LOTDFDTL    DD
             WHERE DD.DISCOVERYSITE = #{P_INTERPLANTID}
               AND 1=1
            GROUP BY DD.LOTID
                   , DD.DISCOVERYSITE
           </when>
           <otherwise>
            SELECT DD.LOTID
                 , ''    AS PLANTID
                 , NVL(SUM(DD.DEFECTQTY), 0)  AS DEFECTQTY
              FROM LOTDFDTL    DD
             WHERE 1=1
            GROUP BY DD.LOTID
           </otherwise>
           </choose>
        ),
        DAT AS
        (
            SELECT BT.LOCALE
                 , BT.SHIPMENTSITE
                 , BT.RELATEDSITE
                 , CASE WHEN BT.LOCALE = 'Local' THEN BT.SHIPMENTSITE
                   ELSE DS.PLANTID
                   END                               AS INTERSECTSITE
                 , BT.PRODUCTSHAPE
                 , BT.CUSTOMERID
                 , BT.COMPANYCLIENT
                 , BT.PRODUCTDEFNAME
                 , BT.RELATEPLANTID
                 , BT.PLANTID
                 , CASE WHEN BT.PCSINPUTQTY IS NULL THEN IQ.INPUTQTY
                   ELSE BT.PCSINPUTQTY
                   END                                AS PCSINPUTQTY
                 , BT.ROOTLOTID
                 , BT.LOTID
                 , BT.LOTCREATEDPLANTID
                 , BT.PRODUCTDEFID
                 , BT.PRODUCTDEFVERSION
                 , BT.PROCESSDEFID
                 , BT.PROCESSDEFVERSION
                 , BT.PROCESSSEGMENTID
                 , BT.USERSEQUENCE
                 , BT.SUBUSERSEQUENCE
                 , BT.WORKCOUNT
                 , BT.INSPPROCESSSEGMENT
                 , BT.SUMMARYTYPE
                 , BT.SUMMARYDATE
                 , BT.SENDTIME
                 , BT.CREATEDTIME
                 , BT.ROOTCOMPLETE
                 , BT.M2SIZE
                 , BT.AREADIV
                 , BT.UNITPRICE
                 , BT.CURRENCY
                 , BT.PRODUCTDEFTYPE
                 , CASE WHEN BT.PCSINPUTQTY IS NULL THEN NVL(IQ.INPUTQTY, 0) - NVL(DS.DEFECTQTY, 0)
                   ELSE NVL(BT.PCSINPUTQTY, 0) - NVL(DS.DEFECTQTY, 0)
                   END                               AS PCSNORMALQTY
                 , NVL(DS.DEFECTQTY, 0)              AS PCSDEFECTQTY
              FROM      BASETGT                     BT
              LEFT JOIN DFSUM                       DS   ON   DS.LOTID = BT.LOTID
              LEFT JOIN FN_GETYIELDINPUTQTY2(BT.LOTID, BT.LOTCREATEDPLANTID)
                                                    IQ   ON   BT.LOTID = IQ.LOTID
                                                         AND  IQ.RNK   = 1
            /*--checkpoint 확인필요 NULL이 존재하여 LOT별과 차이발생하는 원인
            WHERE DB.INTERSECTSITE IS NOT NULL*/
        ),
        <if test="P_LOTSTANDARD != null and P_LOTSTANDARD !='' and (P_LOTSTANDARD eq 'ROOTLOT'.toString())">
        ROOTINPUTQTY AS
        (
            SELECT D.ROOTLOTID
            <if test="P_INTERPLANTID != null and P_INTERPLANTID !='' and !(P_INTERPLANTID eq '*'.toString())">
                 , D.INTERSECTSITE
            </if>
                 , NVL(SUM(D.PCSINPUTQTY), 0)     AS INPUTQTY
              FROM
                   (
                      SELECT DISTINCT ROOTLOTID
                           , LOTID
                           , INTERSECTSITE
                           , PCSINPUTQTY
                        FROM DAT
                   ) D
            GROUP BY D.ROOTLOTID
            <if test="P_INTERPLANTID != null and P_INTERPLANTID !='' and !(P_INTERPLANTID eq '*'.toString())">
                   , D.INTERSECTSITE
            </if>
        ),
        </if>
        FIN1 AS
        (
            SELECT DISTINCT
                   F.PRODUCTSHAPE
                 , F.COMPANYCLIENT
                 , F.PRODUCTDEFNAME
                 , F.PRODUCTDEFID
                 , F.LOCALE
                 , F.SHIPMENTSITE
                 , F.RELATEDSITE
                 , F.INTERSECTSITE
                 , F.PRODUCTDEFVERSION
                 , F.ROOTLOTID
                 , F.LOTID
                 , F.PROCESSSEGMENTID
                 , F.PCSINPUTQTY
                 , NVL(F.PCSDEFECTQTY, 0)                                                   AS PCSDEFECTQTY
                 , F.PCSNORMALQTY
                 , ROUND((F.PCSINPUTQTY/F.AREADIV), 2)                                      AS AREAINPUTQTY
                 , ROUND((F.PCSDEFECTQTY/F.AREADIV), 2)                                     AS AREADEFECTQTY
                 , ROUND((F.PCSNORMALQTY/F.AREADIV), 2)                                     AS AREANORMALQTY
                 , (F.UNITPRICE*F.PCSINPUTQTY)/NVL(E.EXCHANGE_RATE, 1)                      AS PRICEINPUTQTY
                 , (F.UNITPRICE*F.PCSDEFECTQTY)/NVL(E.EXCHANGE_RATE, 1)                     AS PRICEDEFECTQTY
                 , (F.UNITPRICE*F.PCSNORMALQTY)/NVL(E.EXCHANGE_RATE, 1)                     AS PRICENORMALQTY
                 , F.INSPPROCESSSEGMENT
                 , F.ROOTCOMPLETE
                 , F.PRODUCTDEFTYPE
                 , F.SUMMARYDATE
                 , F.CREATEDTIME
            FROM DAT F
            <choose>
            <when test="PLANT eq 'IFC'.toString()">
              LEFT OUTER JOIN  QAM_YIELD_EXCHANGE_V E ON E.PLANTID = #{PLANT} AND E.CURRENCY_CODE = 'KRW'
            </when>
            <when test="PLANT eq 'IFV'.toString()">
              LEFT OUTER JOIN  QAM_YIELD_EXCHANGE_V E ON E.PLANTID = #{PLANT} AND E.CURRENCY_CODE = 'VND'
            </when>
            <when test="PLANT eq 'CCV'.toString()">
              LEFT OUTER JOIN  QAM_YIELD_EXCHANGE_V E ON E.PLANTID = #{PLANT} AND E.CURRENCY_CODE = 'CNY'
            </when>
            <otherwise>
              LEFT OUTER JOIN  QAM_YIELD_EXCHANGE_V E ON E.PLANTID = #{PLANT} AND E.CURRENCY_CODE = 'USD'
            </otherwise>
            </choose>
             WHERE 1=1
               AND F.PCSINPUTQTY IS NOT NULL
               AND F.PCSINPUTQTY != 0
            <if test="P_LOCALEDIV != null and P_LOCALEDIV !='' and !(P_LOCALEDIV eq '*'.toString())">
               AND UPPER(F.LOCALE) = #{P_LOCALEDIV}
            </if>
            <if test="P_LINKPLANTID != null and P_LINKPLANTID !='' and !(P_LINKPLANTID eq '*'.toString())">
               AND F.RELATEDSITE IN (SELECT regexp_substr(#{P_LINKPLANTID}, '[^,]+', 1, LEVEL)
                                       FROM dual
                                     CONNECT BY LEVEL <![CDATA[<=]]> length(#{P_LINKPLANTID})-length(replace(#{P_LINKPLANTID},',',''))+1)
            </if>
            <if test="P_PRODSHAPETYPE != null and P_PRODSHAPETYPE !='' and !(P_PRODSHAPETYPE eq '*'.toString())">
               AND F.PRODUCTSHAPE = #{P_PRODSHAPETYPE}
            </if>
            <if test="P_CUSTOMER != null and P_CUSTOMER !=''">
               AND F.CUSTOMERID IN (SELECT regexp_substr(#{P_CUSTOMER}, '[^,]+', 1, LEVEL)
                                      FROM dual
                                    CONNECT BY LEVEL <![CDATA[<=]]> length(#{P_CUSTOMER})-length(replace(#{P_CUSTOMER},',',''))+1)
            </if>
            <if test="P_PLANTID != null and P_PLANTID !='' and !(P_PLANTID eq '*'.toString())">
               /*--2021.06.17 TOBE Modify 화면단에서 하나의 값만 넘김
               AND F.SHIPMENTSITE IN (SELECT VALUE FROM UFN_SELECTSTRINGTOSPLIT({P_PLANTID}, ','))*/
               AND F.SHIPMENTSITE = #{P_PLANTID}
            </if>
            <if test="P_LOTSTANDARD != null and P_LOTSTANDARD !='' and (P_LOTSTANDARD eq 'ROOTLOT'.toString())">
               AND F.ROOTCOMPLETE = 'COMPLETE'
            </if>
        ),
        FIN2 AS
        (
            SELECT DISTINCT
                   F.PRODUCTSHAPE
                 , F.COMPANYCLIENT
                 , F.PRODUCTDEFNAME
                 , F.PRODUCTDEFID
                 , F.LOCALE
                 , F.SHIPMENTSITE
                 , F.RELATEDSITE
                 , CASE WHEN F.INTERSECTSITE IS NULL THEN ''
                   ELSE F.INTERSECTSITE
                   END                                        AS INTERSECTSITE
                 , F.PRODUCTDEFVERSION
                 , F.ROOTLOTID
                 , F.PROCESSSEGMENTID
                <choose>
                <when test="P_LOTSTANDARD != null and P_LOTSTANDARD !='' and (P_LOTSTANDARD eq 'ROOTLOT'.toString())">
                 , F.ROOTLOTID                                                               AS LOTID
                 , RIQ.INPUTQTY                                                              AS PCSINPUTQTY
                 , SUM(F.PCSDEFECTQTY)       OVER(PARTITION BY F.ROOTLOTID, F.INTERSECTSITE) AS PCSDEFECTQTY
                 , SUM(F.PCSNORMALQTY)       OVER(PARTITION BY F.ROOTLOTID, F.INTERSECTSITE) AS PCSNORMALQTY
                 , SUM(F.AREAINPUTQTY)       OVER(PARTITION BY F.ROOTLOTID, F.INTERSECTSITE) AS AREAINPUTQTY
                 , SUM(F.AREADEFECTQTY)      OVER(PARTITION BY F.ROOTLOTID, F.INTERSECTSITE) AS AREADEFECTQTY
                 , SUM(F.AREANORMALQTY)      OVER(PARTITION BY F.ROOTLOTID, F.INTERSECTSITE) AS AREANORMALQTY
                 , SUM(F.PRICEINPUTQTY)      OVER(PARTITION BY F.ROOTLOTID, F.INTERSECTSITE) AS PRICEINPUTQTY
                 , SUM(F.PRICEDEFECTQTY)     OVER(PARTITION BY F.ROOTLOTID, F.INTERSECTSITE) AS PRICEDEFECTQTY
                 , SUM(F.PRICENORMALQTY)     OVER(PARTITION BY F.ROOTLOTID, F.INTERSECTSITE) AS PRICENORMALQTY
                 , MAX(F.INSPPROCESSSEGMENT) OVER(PARTITION BY F.ROOTLOTID, F.INTERSECTSITE) AS INSPPROCESSSEGMENT
                 , MAX(F.SUMMARYDATE)        OVER(PARTITION BY F.ROOTLOTID)                  AS SUMMARYDATE
                 , MAX(F.CREATEDTIME)        OVER(PARTITION BY F.ROOTLOTID)                  AS CREATEDTIME
                </when>
                <otherwise>
                 , F.LOTID
                 , F.PCSINPUTQTY
                 , F.PCSDEFECTQTY
                 , F.PCSNORMALQTY
                 , F.AREAINPUTQTY
                 , F.AREADEFECTQTY
                 , F.AREANORMALQTY
                 , F.PRICEINPUTQTY
                 , F.PRICEDEFECTQTY
                 , F.PRICENORMALQTY
                 , F.INSPPROCESSSEGMENT
                 , F.SUMMARYDATE
                 , F.CREATEDTIME
                </otherwise>
                </choose>
                 , F.ROOTCOMPLETE
                 , F.PRODUCTDEFTYPE
              FROM FIN1 F
            <if test="P_LOTSTANDARD != null and P_LOTSTANDARD !='' and (P_LOTSTANDARD eq 'ROOTLOT'.toString())">
              INNER JOIN ROOTINPUTQTY  RIQ  ON   RIQ.ROOTLOTID     = F.ROOTLOTID
                                            AND  RIQ.INTERSECTSITE = F.INTERSECTSITE
            </if>
        ),
        FINBASE AS
        (
            SELECT X.SUMMARYDATE
                 , X.LOCALE
                 , SUM(X.PCSINPUTQTY)          AS PCSINPUTQTY
                 , SUM(X.PCSDEFECTQTY)         AS PCSDEFECTQTY
                 , SUM(X.PCSNORMALQTY)         AS PCSNORMALQTY
                 , SUM(X.CUMPCSINPUTQTY)       AS CUMPCSINPUTQTY
                 , SUM(X.CUMPCSDEFECTQTY)      AS CUMPCSDEFECTQTY
                 , SUM(X.TOTCUMPCSINPUTQTY)    AS TOTCUMPCSINPUTQTY
                 , SUM(X.TOTCUMPCSDEFECTQTY)   AS TOTCUMPCSDEFECTQTY                 
                 , SUM(X.AREAINPUTQTY)         AS AREAINPUTQTY
                 , SUM(X.AREADEFECTQTY)        AS AREADEFECTQTY
                 , SUM(X.AREANORMALQTY)        AS AREANORMALQTY
                 , SUM(X.CUMAREAINPUTQTY)      AS CUMAREAINPUTQTY
                 , SUM(X.CUMAREADEFECTQTY)     AS CUMAREADEFECTQTY
                 , SUM(X.TOTCUMAREAINPUTQTY)   AS TOTCUMAREAINPUTQTY
                 , SUM(X.TOTCUMAREADEFECTQTY)  AS TOTCUMAREADEFECTQTY
                 , SUM(X.PRICEINPUTQTY)        AS PRICEINPUTQTY
                 , SUM(X.PRICEDEFECTQTY)       AS PRICEDEFECTQTY
                 , SUM(X.PRICENORMALQTY)       AS PRICENORMALQTY
                 , SUM(X.CUMPRICEINPUTQTY)     AS CUMPRICEINPUTQTY
                 , SUM(X.CUMPRICEDEFECTQTY)    AS CUMPRICEDEFECTQTY
                 , SUM(X.TOTCUMPRICEINPUTQTY)  AS TOTCUMPRICEINPUTQTY
                 , SUM(X.TOTCUMPRICEDEFECTQTY) AS TOTCUMPRICEDEFECTQTY
              FROM  (
                        SELECT SDQ.SUMMARYDATE
                             , SDQ.LOCALE
                             , NVL(SDQ.PCSINPUTQTY, 0)                 AS PCSINPUTQTY
                             , SDQ.PCSDEFECTQTY
                             , SDQ.PCSNORMALQTY
                             , SUM(NVL(SDQ.PCSINPUTQTY, 0))     OVER(PARTITION BY SDQ.LOCALE ORDER BY SDQ.SUMMARYDATE) AS CUMPCSINPUTQTY
                             , SUM(NVL(SDQ.PCSDEFECTQTY, 0))    OVER(PARTITION BY SDQ.LOCALE ORDER BY SDQ.SUMMARYDATE) AS CUMPCSDEFECTQTY
                             , SUM(NVL(SDQ.PCSINPUTQTY, 0))     OVER(PARTITION BY 1 ORDER BY SDQ.SUMMARYDATE) AS TOTCUMPCSINPUTQTY
                             , SUM(NVL(SDQ.PCSDEFECTQTY, 0))    OVER(PARTITION BY 1 ORDER BY SDQ.SUMMARYDATE) AS TOTCUMPCSDEFECTQTY
                             , SDQ.AREAINPUTQTY
                             , SDQ.AREADEFECTQTY
                             , SDQ.AREANORMALQTY
                             , SUM(NVL(SDQ.AREAINPUTQTY, 0))    OVER(PARTITION BY SDQ.LOCALE ORDER BY SDQ.SUMMARYDATE) AS CUMAREAINPUTQTY
                             , SUM(NVL(SDQ.AREADEFECTQTY, 0))   OVER(PARTITION BY SDQ.LOCALE ORDER BY SDQ.SUMMARYDATE) AS CUMAREADEFECTQTY
                             , SUM(NVL(SDQ.AREAINPUTQTY, 0))    OVER(PARTITION BY 1 ORDER BY SDQ.SUMMARYDATE) AS TOTCUMAREAINPUTQTY
                             , SUM(NVL(SDQ.AREADEFECTQTY, 0))   OVER(PARTITION BY 1 ORDER BY SDQ.SUMMARYDATE) AS TOTCUMAREADEFECTQTY                             
                             , SDQ.PRICEINPUTQTY
                             , SDQ.PRICEDEFECTQTY
                             , SDQ.PRICENORMALQTY
                             , SUM(NVL(SDQ.PRICEINPUTQTY, 0))   OVER(PARTITION BY SDQ.LOCALE ORDER BY SDQ.SUMMARYDATE) AS CUMPRICEINPUTQTY
                             , SUM(NVL(SDQ.PRICEDEFECTQTY, 0))  OVER(PARTITION BY SDQ.LOCALE ORDER BY SDQ.SUMMARYDATE) AS CUMPRICEDEFECTQTY
                             , SUM(NVL(SDQ.PRICEINPUTQTY, 0))   OVER(PARTITION BY 1 ORDER BY SDQ.SUMMARYDATE) AS TOTCUMPRICEINPUTQTY
                             , SUM(NVL(SDQ.PRICEDEFECTQTY, 0))  OVER(PARTITION BY 1 ORDER BY SDQ.SUMMARYDATE) AS TOTCUMPRICEDEFECTQTY
                          FROM      (/*SITEDEFECTQTYALL*/
                                         SELECT CASE WHEN SUMMARYDATE  <![CDATA[<]]>  (TRUNC(SUMMARYDATE) + INTERVAL '8' HOUR +INTERVAL '30' MINUTE)
                                                      AND SUMMARYDATE >= (TRUNC(SUMMARYDATE) + INTERVAL '8' HOUR +INTERVAL '30' MINUTE) - INTERVAL '1' DAY
                                                THEN TO_CHAR((SUMMARYDATE - INTERVAL '1' DAY), 'YYYYMMDD')
                                                ELSE TO_CHAR(SUMMARYDATE, 'YYYYMMDD')
                                                END                  AS SUMMARYDATE
                                              , LOCALE
                                              , SUM(PCSINPUTQTY)     AS PCSINPUTQTY
                                              , SUM(PCSDEFECTQTY)    AS PCSDEFECTQTY
                                              , SUM(PCSNORMALQTY)    AS PCSNORMALQTY
                                              , SUM(AREAINPUTQTY)    AS AREAINPUTQTY
                                              , SUM(AREADEFECTQTY)   AS AREADEFECTQTY
                                              , SUM(AREANORMALQTY)   AS AREANORMALQTY
                                              , SUM(PRICEINPUTQTY)   AS PRICEINPUTQTY
                                              , SUM(PRICEDEFECTQTY)  AS PRICEDEFECTQTY
                                              , SUM(PRICENORMALQTY)  AS PRICENORMALQTY
                                           FROM FIN2
                                          WHERE 1=1
                                         GROUP BY CASE WHEN SUMMARYDATE  <![CDATA[<]]>  (TRUNC(SUMMARYDATE) + INTERVAL '8' HOUR +INTERVAL '30' MINUTE)
                                                        AND SUMMARYDATE >= (TRUNC(SUMMARYDATE) + INTERVAL '8' HOUR +INTERVAL '30' MINUTE) - INTERVAL '1' DAY
                                                  THEN TO_CHAR((SUMMARYDATE - INTERVAL '1' DAY), 'YYYYMMDD')
                                                  ELSE TO_CHAR(SUMMARYDATE, 'YYYYMMDD')
                                                  END
                                                , LOCALE
                                     ) SDQ
                    )X
            GROUP BY X.SUMMARYDATE
                   , X.LOCALE
        )
        SELECT *
          FROM (
                SELECT D.DAYGUBUN                                                     AS SUMMARYDATE
                <choose>
                    <when test="P_YIELDQTYSTANDARD eq 'PCS'.toString()">
                     /*TOTAL*/
                     , 100-(CASE WHEN TOT.PCSINPUTQTY IS NULL THEN NULL
                            ELSE ROUND((TOT.PCSDEFECTQTY/TOT.PCSINPUTQTY)*100, 2)
                            END)                                                      AS TOTALYIELDRATE
                     , CASE WHEN TOT.PCSINPUTQTY IS NULL THEN NULL
                       ELSE ROUND((TOT.PCSDEFECTQTY/TOT.PCSINPUTQTY)*100, 2)
                       END                                                            AS TOTALDEFECTRATE
                     , 100-(CASE WHEN TOT.TOTCUMPCSINPUTQTY IS NULL THEN NULL
                            ELSE ROUND((TOT.TOTCUMPCSDEFECTQTY/TOT.TOTCUMPCSINPUTQTY)*100, 2)
                            END)                                                      AS TOTALYIELDRATECUM
                     , TOT.PCSINPUTQTY                                                AS TOTALINPUTQTY
                     , TOT.PCSDEFECTQTY                                               AS TOTALDEFECTQTY
                     , TOT.PCSNORMALQTY                                               AS TOTALNORMALQTY
                     , TOT.TOTCUMPCSINPUTQTY                                          AS TOTALCUMINPUTQTY
                     , TOT.TOTCUMPCSDEFECTQTY                                         AS TOTALCUMDEFECTQTY
                     /*LOCAL*/
                     , 100-(CASE WHEN LOC.PCSINPUTQTY IS NULL THEN NULL
                            ELSE ROUND((LOC.PCSDEFECTQTY/LOC.PCSINPUTQTY)*100, 2)
                            END )                                                     AS LOCALYIELDRATE
                     , CASE WHEN LOC.PCSINPUTQTY IS NULL THEN NULL
                       ELSE ROUND((LOC.PCSDEFECTQTY/LOC.PCSINPUTQTY)*100, 2)
                       END                                                            AS LOCALDEFECTRATE
                     , 100-(CASE WHEN LOC.CUMPCSINPUTQTY IS NULL THEN NULL
                            ELSE ROUND((LOC.CUMPCSDEFECTQTY/LOC.CUMPCSINPUTQTY)*100, 2)
                            END)                                                      AS LOCALYIELDRATECUM
                     , LOC.PCSINPUTQTY                                                AS LOCALINPUTQTY
                     , LOC.PCSDEFECTQTY                                               AS LOCALDEFECTQTY
                     , LOC.PCSNORMALQTY                                               AS LOCALNORMALQTY
                     , LOC.CUMPCSINPUTQTY                                             AS LOCALCUMINPUTQTY
                     , LOC.CUMPCSDEFECTQTY                                            AS LOCALCUMDEFECTQTY
                     /*GLOBAL*/
                     , 100-(CASE WHEN GLO.PCSINPUTQTY IS NULL THEN NULL
                            ELSE ROUND((GLO.PCSDEFECTQTY/GLO.PCSINPUTQTY)*100, 2)
                            END)                                                      AS GLOBALYIELDRATE
                     , CASE WHEN GLO.PCSINPUTQTY IS NULL THEN NULL
                       ELSE ROUND((GLO.PCSDEFECTQTY/GLO.PCSINPUTQTY)*100, 2)
                       END                                                            AS GLOBALDEFECTRATE
                     , 100-(CASE WHEN GLO.CUMPCSINPUTQTY IS NULL THEN NULL
                            ELSE ROUND((GLO.CUMPCSDEFECTQTY/GLO.CUMPCSINPUTQTY)*100, 2)
                            END)                                                      AS GLOBALYIELDRATECUM
                     , GLO.PCSINPUTQTY                                                AS GLOBALINPUTQTY
                     , GLO.PCSDEFECTQTY                                               AS GLOBALDEFECTQTY
                     , GLO.PCSNORMALQTY                                               AS GLOBALNORMALQTY
                     , GLO.CUMPCSINPUTQTY                                             AS GLOBALCUMINPUTQTY
                     , GLO.CUMPCSDEFECTQTY                                            AS GLOBALCUMDEFECTQTY
                    </when>
                    <when test="P_YIELDQTYSTANDARD eq 'AREA'.toString()">
                     /*TOTAL*/
                     , 100-(CASE WHEN TOT.AREAINPUTQTY IS NULL THEN NULL
                            ELSE ROUND((TOT.AREADEFECTQTY/TOT.AREAINPUTQTY)*100, 2)
                            END)                                                        AS TOTALYIELDRATE
                     , CASE WHEN TOT.AREAINPUTQTY IS NULL THEN NULL
                       ELSE ROUND((TOT.AREADEFECTQTY/TOT.AREAINPUTQTY)*100, 2)
                       END                                                              AS TOTALDEFECTRATE
                     , 100-(CASE WHEN TOT.TOTCUMAREAINPUTQTY IS NULL THEN NULL
                            ELSE ROUND((TOT.TOTCUMAREADEFECTQTY/TOT.TOTCUMAREAINPUTQTY)*100, 2)
                            END)                                                        AS TOTALYIELDRATECUM
                     , TOT.AREAINPUTQTY                                                 AS TOTALINPUTQTY
                     , TOT.AREADEFECTQTY                                                AS TOTALDEFECTQTY
                     , TOT.AREANORMALQTY                                                AS TOTALNORMALQTY
                     , TOT.TOTCUMAREAINPUTQTY                                           AS TOTALCUMINPUTQTY
                     , TOT.TOTCUMAREADEFECTQTY                                          AS TOTALCUMDEFECTQTY
                     /*LOCAL*/
                     , 100-(CASE WHEN LOC.AREAINPUTQTY IS NULL THEN NULL
                            ELSE ROUND((LOC.AREADEFECTQTY/LOC.AREAINPUTQTY)*100, 2)
                            END)                                                        AS LOCALYIELDRATE
                     , CASE WHEN LOC.AREAINPUTQTY IS NULL THEN NULL
                       ELSE ROUND((LOC.AREADEFECTQTY/LOC.AREAINPUTQTY)*100, 2)
                       END                                                              AS LOCALDEFECTRATE
                     , 100-(CASE WHEN LOC.CUMAREAINPUTQTY IS NULL THEN NULL
                            ELSE ROUND((LOC.CUMAREADEFECTQTY/LOC.CUMAREAINPUTQTY)*100, 2)
                            END)                                                        AS LOCALYIELDRATECUM
                     , LOC.AREAINPUTQTY                                                 AS LOCALINPUTQTY
                     , LOC.AREADEFECTQTY                                                AS LOCALDEFECTQTY
                     , LOC.AREANORMALQTY                                                AS LOCALNORMALQTY
                     , LOC.CUMAREAINPUTQTY                                              AS LOCALCUMINPUTQTY
                     , LOC.CUMAREADEFECTQTY                                             AS LOCALCUMDEFECTQTY
                     /*GLOBAL*/
                     , 100-(CASE WHEN GLO.AREAINPUTQTY IS NULL THEN NULL
                            ELSE ROUND((GLO.AREADEFECTQTY/GLO.AREAINPUTQTY)*100, 2)
                            END)                                                        AS GLOBALYIELDRATE
                     , CASE WHEN GLO.AREAINPUTQTY IS NULL THEN NULL
                       ELSE ROUND((GLO.AREADEFECTQTY/GLO.AREAINPUTQTY)*100, 2)
                       END                                                              AS GLOBALDEFECTRATE
                     , 100-(CASE WHEN GLO.CUMAREAINPUTQTY IS NULL THEN NULL
                            ELSE ROUND((GLO.CUMAREADEFECTQTY/GLO.CUMAREAINPUTQTY)*100, 2)
                            END)                                                        AS GLOBALYIELDRATECUM
                     , GLO.AREAINPUTQTY                                                 AS GLOBALINPUTQTY
                     , GLO.AREADEFECTQTY                                                AS GLOBALDEFECTQTY
                     , GLO.AREANORMALQTY                                                AS GLOBALNORMALQTY
                     , GLO.CUMAREAINPUTQTY                                              AS GLOBALCUMINPUTQTY
                     , GLO.CUMAREADEFECTQTY                                             AS GLOBALCUMDEFECTQTY
                    </when>
                    <otherwise>
                     /*TOTAL*/
                     , 100-(CASE WHEN TOT.PRICEINPUTQTY IS NULL THEN NULL
                            ELSE ROUND((TOT.PRICEDEFECTQTY/TOT.PRICEINPUTQTY)*100, 2)
                            END)                                                        AS TOTALYIELDRATE
                     , CASE WHEN TOT.PRICEINPUTQTY IS NULL THEN NULL
                       ELSE ROUND((TOT.PRICEDEFECTQTY/TOT.PRICEINPUTQTY)*100, 2)
                       END                                                              AS TOTALDEFECTRATE
                     , 100-(CASE WHEN TOT.TOTCUMPRICEINPUTQTY IS NULL THEN NULL
                            ELSE ROUND((TOT.TOTCUMPRICEDEFECTQTY/TOT.TOTCUMPRICEINPUTQTY)*100, 2)
                            END)                                                        AS TOTALYIELDRATECUM
                     , TOT.PRICEINPUTQTY                                                AS TOTALINPUTQTY
                     , TOT.PRICEDEFECTQTY                                               AS TOTALDEFECTQTY
                     , TOT.PRICENORMALQTY                                               AS TOTALNORMALQTY
                     , TOT.TOTCUMPRICEINPUTQTY                                          AS TOTALCUMINPUTQTY
                     , TOT.TOTCUMPRICEDEFECTQTY                                         AS TOTALCUMDEFECTQTY
                     /*LOCAL*/
                     , 100-(CASE WHEN LOC.PRICEINPUTQTY IS NULL THEN NULL
                            ELSE ROUND((LOC.PRICEDEFECTQTY/LOC.PRICEINPUTQTY)*100, 2)
                            END)                                                        AS LOCALYIELDRATE
                     , CASE WHEN LOC.PRICEINPUTQTY IS NULL THEN NULL
                       ELSE ROUND((LOC.PRICEDEFECTQTY/LOC.PRICEINPUTQTY)*100, 2)
                       END                                                              AS LOCALDEFECTRATE
                     , 100-(CASE WHEN LOC.CUMPRICEINPUTQTY IS NULL THEN NULL
                            ELSE ROUND((LOC.CUMPRICEDEFECTQTY/LOC.CUMPRICEINPUTQTY)*100, 2)
                            END)                                                        AS LOCALYIELDRATECUM
                     , LOC.PRICEINPUTQTY                                                AS LOCALINPUTQTY
                     , LOC.PRICEDEFECTQTY                                               AS LOCALDEFECTQTY
                     , LOC.PRICENORMALQTY                                               AS LOCALNORMALQTY
                     , LOC.CUMPRICEINPUTQTY                                             AS LOCALCUMINPUTQTY
                     , LOC.CUMPRICENORMALQTY                                            AS LOCALCUMNORMALQTY
                     /*GLOBAL*/
                     , 100-(CASE WHEN GLO.PRICEINPUTQTY IS NULL THEN NULL
                            ELSE ROUND((GLO.PRICEDEFECTQTY/GLO.PRICEINPUTQTY)*100, 2)
                            END)                                                        AS GLOBALYIELDRATE
                     , CASE WHEN GLO.PRICEINPUTQTY IS NULL THEN NULL
                       ELSE ROUND((GLO.PRICEDEFECTQTY/GLO.PRICEINPUTQTY)*100, 2)
                       END                                                              AS GLOBALDEFECTRATE
                     , 100-(CASE WHEN GLO.CUMPRICEINPUTQTY IS NULL THEN NULL
                            ELSE ROUND((GLO.CUMPRICEDEFECTQTY/GLO.CUMPRICEINPUTQTY)*100, 2)
                            END)                                                        AS GLOBALYIELDRATECUM
                     , GLO.PRICEINPUTQTY                                                AS GLOBALINPUTQTY
                     , GLO.PRICEDEFECTQTY                                               AS GLOBALDEFECTQTY
                     , GLO.PRICENORMALQTY                                               AS GLOBALNORMALQTY
                     , GLO.CUMPRICEINPUTQTY                                             AS GLOBALCUMINPUTQTY
                     , GLO.CUMPRICEDEFECTQTY                                            AS GLOBALCUMDEFECTQTY
                    </otherwise>
                </choose>
                  FROM      (
                                SELECT TO_CHAR(TO_DATE(#{P_PERIODFR}, 'YYYYMMDD HH24:MI:SS')+LEVEL-1, 'YYYYMMDD') AS DAYGUBUN
                                  FROM DUAL
                                CONNECT BY LEVEL <![CDATA[<=]]> TO_DATE(#{P_PERIODTO}, 'YYYYMMDD HH24:MI:SS')- TO_DATE(#{P_PERIODFR}, 'YYYYMMDD HH24:MI:SS')
                            )                D
                  LEFT JOIN (
                                SELECT X.SUMMARYDATE
                                <choose>
                                    <when test="P_YIELDQTYSTANDARD eq 'PCS'.toString()">
                                     , SUM(X.PCSINPUTQTY)        AS PCSINPUTQTY
                                     , SUM(X.PCSDEFECTQTY)       AS PCSDEFECTQTY
                                     , SUM(X.PCSNORMALQTY)       AS PCSNORMALQTY
                                     , SUM(X.CUMPCSINPUTQTY)     AS CUMPCSINPUTQTY
                                     , SUM(X.CUMPCSDEFECTQTY)    AS CUMPCSDEFECTQTY
                                     , MAX(X.TOTCUMPCSINPUTQTY)  AS TOTCUMPCSINPUTQTY
                                     , MAX(X.TOTCUMPCSDEFECTQTY) AS TOTCUMPCSDEFECTQTY
                                    </when>
                                    <when test="P_YIELDQTYSTANDARD eq 'AREA'.toString()">
                                     , SUM(X.AREAINPUTQTY)       AS AREAINPUTQTY
                                     , SUM(X.AREADEFECTQTY)      AS AREADEFECTQTY
                                     , SUM(X.AREANORMALQTY)      AS AREANORMALQTY
                                     , SUM(X.CUMAREAINPUTQTY)    AS CUMAREAINPUTQTY
                                     , SUM(X.CUMAREADEFECTQTY)   AS CUMAREADEFECTQTY
                                     , MAX(X.TOTCUMPCSINPUTQTY)  AS TOTCUMAREAINPUTQTY
                                     , MAX(X.TOTCUMPCSDEFECTQTY) AS TOTCUMAREADEFECTQTY
                                    </when>
                                    <otherwise>
                                     , SUM(X.PRICEINPUTQTY)      AS PRICEINPUTQTY
                                     , SUM(X.PRICEDEFECTQTY)     AS PRICEDEFECTQTY
                                     , SUM(X.PRICENORMALQTY)     AS PRICENORMALQTY
                                     , SUM(X.CUMPRICEINPUTQTY)   AS CUMPRICEINPUTQTY
                                     , SUM(X.CUMPRICEDEFECTQTY)  AS CUMPRICEDEFECTQTY
                                     , MAX(X.TOTCUMPCSINPUTQTY)  AS TOTCUMPRICEINPUTQTY
                                     , MAX(X.TOTCUMPCSDEFECTQTY) AS TOTCUMPRICEDEFECTQTY
                                    </otherwise>
                                </choose>
                                  FROM FINBASE X
                                 WHERE 1=1
                                GROUP BY X.SUMMARYDATE
                             )              TOT               ON   D.DAYGUBUN               = TOT.SUMMARYDATE
                  LEFT JOIN FINBASE         LOC               ON   D.DAYGUBUN               = LOC.SUMMARYDATE
                                                              AND  NVL(LOC.LOCALE, 'Local') = 'Local'
                  LEFT JOIN FINBASE         GLO               ON   D.DAYGUBUN               = GLO.SUMMARYDATE
                                                              AND  NVL(GLO.LOCALE, 'Local') = 'Global'
                )X
         WHERE X.TOTALINPUTQTY IS NOT NULL
        ORDER BY X.SUMMARYDATE DESC
    </select>



    <!-- desc   : 일별 수율현황>>일별 WORST
         modify : 일별 수율현황 수율 = 100 - 불량율(양품수도 변경됨)
         asis => SelectYieldRateWorstByDay_10001
    -->
    <select id="selectYieldRateWorstByDayList" parameterType="map" resultType="hashmap">
        /* smh.qam.dao.QAM02500Dao.selectYieldRateWorstByDayList */
        WITH FINALDATA AS
        (
            SELECT  YS.*
                 , PS.PROCESSSEGMENTVERSION
                 , RANK() OVER (PARTITION BY ROOTLOTID, LOTID ORDER BY TO_NUMBER(USERSEQUENCE), TO_NUMBER(SUBUSERSEQUENCE), WORKCOUNT DESC)   AS RNK
              FROM       PCM_YIELDSUMMARY        YS
              INNER JOIN BAS_PROCESSSEGMENT      PS  ON YS.PROCESSSEGMENTID = PS.PROCESSSEGMENTID
             WHERE YS.SUMMARYDATE >=  TO_DATE(#{P_PERIODFR}, 'YYYY-MM-DD HH24:MI:SS')
               AND YS.SUMMARYDATE <![CDATA[<]]> TO_DATE(#{P_PERIODTO}, 'YYYY-MM-DD HH24:MI:SS')
               AND YS.SUMMARYTYPE = 'Normal'
               AND YS.SENDTIME IS NOT NULL
            <choose>
            <when test="P_INSPTYPE eq 'SHIPMENT'.toString() ">
               AND PS.PROCESSSEGMENTCLASSID IN ('7030','7536')
            </when>
            <when test="P_INSPTYPE eq 'FINISH'.toString() ">
               AND PS.PROCESSSEGMENTCLASSID IN ('7026','7534')
            </when>
            <otherwise>
               AND PS.PROCESSSEGMENTCLASSID IN ('8012','8014')
            </otherwise>
            </choose>
            <if test="P_INSPECTIONPROCESS != null and P_INSPECTIONPROCESS !='' and !(P_INSPECTIONPROCESS eq 'Final'.toString())">
            AND     YS.PROCESSSEGMENTID = '$!{P_INSPECTIONPROCESS}'
            </if>
            <if test="P_PRODUCTDEFID != null and P_PRODUCTDEFID !='' ">
               AND YS.PRODUCTDEFID||YS.PRODUCTDEFVERSION IN (SELECT regexp_substr(#{P_PRODUCTDEFID}, '[^,]+', 1, LEVEL)
                                                               FROM dual
                                                             CONNECT BY LEVEL <![CDATA[<=]]> length(#{P_PRODUCTDEFID})-length(replace(#{P_PRODUCTDEFID},',',''))+1)
            </if>
            <if test="P_ROOTLOT != null and P_ROOTLOT !='' ">
               AND YS.ROOTLOTID IN (SELECT regexp_substr(#{P_ROOTLOT}, '[^,]+', 1, LEVEL)
                                      FROM dual
                                    CONNECT BY LEVEL <![CDATA[<=]]> length(#{P_ROOTLOT})-length(replace(#{P_ROOTLOT},',',''))+1)
            </if>
            <if test="P_LOTNO != null and P_LOTNO !='' ">
               AND YS.LOTID IN (SELECT regexp_substr(#{P_LOTNO}, '[^,]+', 1, LEVEL)
                                  FROM dual
                                CONNECT BY LEVEL <![CDATA[<=]]> length(#{P_LOTNO})-length(replace(#{P_LOTNO},',',''))+1)
            </if>
            UNION ALL
            SELECT YS.*
                 , PS.PROCESSSEGMENTVERSION
                 , RANK() OVER (PARTITION BY ROOTLOTID, LOTID ORDER BY TO_NUMBER(USERSEQUENCE), TO_NUMBER(SUBUSERSEQUENCE), WORKCOUNT DESC)   AS RNK
              FROM       PCM_YIELDSUMMARY     YS
              INNER JOIN BAS_PROCESSSEGMENT   PS  ON YS.PROCESSSEGMENTID = PS.PROCESSSEGMENTID
             WHERE YS.SUMMARYDATE >=  TO_DATE(#{P_PERIODFR}, 'YYYY-MM-DD HH24:MI:SS')
               AND YS.SUMMARYDATE <![CDATA[<]]> TO_DATE(#{P_PERIODTO}, 'YYYY-MM-DD HH24:MI:SS')
               AND YS.SUMMARYTYPE = 'CompleteDefect'
            <if test="P_PRODUCTDEFID != null and P_PRODUCTDEFID !='' ">
               AND YS.PRODUCTDEFID||YS.PRODUCTDEFVERSION IN (SELECT regexp_substr(#{P_PRODUCTDEFID}, '[^,]+', 1, LEVEL)
                                                               FROM dual
                                                             CONNECT BY LEVEL <![CDATA[<=]]> length(#{P_PRODUCTDEFID})-length(replace(#{P_PRODUCTDEFID},',',''))+1)
            </if>
            <if test="P_ROOTLOT != null and P_ROOTLOT !='' ">
               AND YS.ROOTLOTID IN (SELECT regexp_substr(#{P_ROOTLOT}, '[^,]+', 1, LEVEL)
                                      FROM dual
                                    CONNECT BY LEVEL <![CDATA[<=]]> length(#{P_ROOTLOT})-length(replace(#{P_ROOTLOT},',',''))+1)
            </if>
            <if test="P_LOTNO != null and P_LOTNO !='' ">
               AND YS.LOTID IN (SELECT regexp_substr(#{P_LOTNO}, '[^,]+', 1, LEVEL)
                                  FROM dual
                                CONNECT BY LEVEL <![CDATA[<=]]> length(#{P_LOTNO})-length(replace(#{P_LOTNO},',',''))+1)
            </if>
        ),
        BASETGT AS
        (
            SELECT DISTINCT LO.LOCALE
                 , SM.SHIPSITE                                  AS SHIPMENTSITE
                 , CASE WHEN LO.LOCALE = 'Local' THEN SM.SHIPSITE
                <choose>
                <when test="P_LINKPLANTID != null and P_LINKPLANTID !='' and !(P_LINKPLANTID eq '*'.toString())">
                    ELSE RP.RELATEPLANTID END                   AS RELATEDSITE
                </when>
                <otherwise>
                    ELSE ''               END                   AS RELATEDSITE
                </otherwise>
                </choose>
                 , PIS.PRODUCTTYPE                              AS PRODUCTSHAPE
                 , PIS.CUSTOMERID
                 , PIS.CUSTOMERNAME                             AS COMPANYCLIENT
                 , SPD.PRODUCTDEFNAME                           AS PRODUCTDEFNAME
                 , RP.RELATEPLANTID
                 , IQ.PLANTID
                 , IQ.INPUTQTY                                  AS PCSINPUTQTY
                 , FD.ROOTLOTID
                 , FD.LOTID
                 , FD.PLANTID                                   AS LOTCREATEDPLANTID
                 , FD.PRODUCTDEFID
                 , FD.PRODUCTDEFVERSION
                 , FD.PROCESSDEFID
                 , FD.PROCESSDEFVERSION
                 , FD.PROCESSSEGMENTID
                 , FD.USERSEQUENCE
                 , FD.SUBUSERSEQUENCE
                 , FD.WORKCOUNT
                 , DC1.DICTIONARYNAME                           AS INSPPROCESSSEGMENT
                 , FD.SUMMARYTYPE
                 , FD.SUMMARYDATE
                 , FD.SENDTIME
                 , FD.CREATEDTIME
                <choose>
                <when test="P_LOTSTANDARD != null and P_LOTSTANDARD !='' and (P_LOTSTANDARD eq 'ROOTLOT'.toString())">
                 , CASE WHEN RLC.LOTCOUNT = RLC.ENDLOTCOUNT THEN 'COMPLETE'
                   ELSE ''
                   END                                          AS ROOTCOMPLETE
                </when>
                <otherwise>
                 , ''                                           AS ROOTCOMPLETE
                </otherwise>
                </choose>
                 , PIS.PCSSIZEXAXIS*PIS.PCSSIZEYAXIS            AS M2SIZE
                 , PIS.PCSMM                                    AS AREADIV
                 , SOA.UNITPRICE                                AS UNITPRICE
                 , SOA.CURRENCY
                 , LTD.DICTIONARYNAME                           AS PRODUCTDEFTYPE
              FROM       FINALDATA                                                     FD
              INNER JOIN PCM_LOT                                                       L    ON   FD.LOTID               = L.LOTID
              /*--2016.06.16 TOBE Modify
              LEFT JOIN  FN_GETYIELDLOCALE(FD.PRODUCTDEFID||FD.PRODUCTDEFVERSION)      LO   ON   LO.PRODUCTDEFID        = FD.PRODUCTDEFID
                                                                                            AND  LO.PRODUCTDEFVERSION   = FD.PROCESSDEFVERSION*/
              LEFT JOIN  QAM_YIELD_LOCALE_V                                            LO   ON   LO.PRODUCTDEFID        = FD.PRODUCTDEFID
                                                                                            AND  LO.PRODUCTDEFVERSION   = FD.PRODUCTDEFVERSION
              LEFT JOIN  FN_GETYIELDSHIPMENT(FD.LOTID, FD.PRODUCTDEFID, FD.PRODUCTDEFVERSION)
                                                                                       SM   ON   SM.RETLOTID            = FD.LOTID
              LEFT JOIN  FN_GETYIELDRELPLANT(FD.LOTID, FD.PROCESSDEFID, FD.PROCESSDEFVERSION)
                                                                                       RP   ON   RP.RETLOTID            = FD.LOTID
                                                                                            AND  RP.RETPROCESSDEFID     = FD.PROCESSDEFID
                                                                                            AND  RP.LV                  > 0
            <if test="P_LOTSTANDARD != null and P_LOTSTANDARD !='' and (P_LOTSTANDARD eq 'ROOTLOT'.toString())">
              LEFT JOIN    FN_GETYIELDROOTCOMPLETE(FD.ROOTLOTID,#{P_INSPTYPE})         RLC  ON   RLC.RETROOTLOTID       = FD.ROOTLOTID
            </if>
            <choose>
            <when test="P_INTERPLANTID != null and P_INTERPLANTID !='' and !(P_INTERPLANTID eq '*'.toString()) ">
              LEFT JOIN FN_GETYIELDINPUTQTY2(FD.LOTID, #{P_INTERPLANTID})              IQ   ON   FD.LOTID               = IQ.LOTID
                                                                                            AND  IQ.RNK                 = 1
            </when>
            <otherwise>
              LEFT JOIN FN_GETYIELDINPUTQTY2(FD.LOTID, '*')                            IQ   ON   FD.LOTID               = IQ.LOTID
                                                                                            AND  IQ.RNK                 = 1
            </otherwise>
            </choose>
              LEFT JOIN BAS_PRODUCTDEFINITION                                          SPD  ON   SPD.PRODUCTDEFID       = FD.PRODUCTDEFID
                                                                                            AND  SPD.PRODUCTDEFVERSION  = FD.PRODUCTDEFVERSION
              LEFT JOIN BAS_PROCESSSEGMENT                                             SG   ON   SG.PROCESSSEGMENTID    = FD.PROCESSSEGMENTID
              LEFT JOIN CMD_DICTIONARY                                                 DC1  ON   SG.PROCESSSEGMENTNAME  = DC1.DICTIONARYID
                                                                                            AND  DC1.LANGUAGETYPE       = #{LANGUAGETYPE}
              LEFT JOIN BAS_PRODUCTITEMSPEC                                            PIS  ON   PIS.ITEMID             = FD.PRODUCTDEFID
                                                                                            AND  PIS.ITEMVERSION        = FD.PRODUCTDEFVERSION
              LEFT JOIN MFM_PRODUCTIONORDER                                            PO   ON   PO.PRODUCTIONORDERID   = L.PRODUCTIONORDERID
                                                                                            AND  PO.LINENO              = L.LINENO
                                                                                            AND  PO.ENTERPRISEID        = L.ENTERPRISEID
              LEFT JOIN BAS_SALEORDERAPPROVAL                                          SOA  ON   SOA.SALESORDERID       = L.PRODUCTIONORDERID
                                                                                            AND  SOA.LINENO             = L.LINENO
                                                                                            AND  SOA.ENTERPRISEID       = L.ENTERPRISEID
              LEFT JOIN CMD_LOOKUP_VALUES                                              LTC  ON   LTC.LOOKUP_CODE        = L.LOTTYPE
                                                                                            AND  LTC.LOOKUP_TYPE        = 'ProductionType'
              LEFT JOIN CMD_DICTIONARY                                                 LTD  ON   LTD.DICTIONARYID       = LTC.DICTIONARYID
                                                                                            AND  LTD.LANGUAGETYPE       = #{LANGUAGETYPE}
             WHERE FD.RNK =1
            <if test="P_PRODUCTIONDIVISION != null and P_PRODUCTIONDIVISION !='' and !(P_PRODUCTIONDIVISION eq '*'.toString()) ">
               AND L.LOTTYPE = #{P_PRODUCTIONDIVISION}
            </if>
        ),
        LOTDFDTL AS
        (
            SELECT DL.*
              FROM      BASETGT    BT
              LEFT JOIN FN_GETYIELDDEFECTLIST(BT.LOTID, #{LANGUAGETYPE})  DL    ON   DL.LOTID = BT.LOTID
            <if test="P_INSPECTIONPROCESS != null and P_INSPECTIONPROCESS !='' and !(P_INSPECTIONPROCESS eq 'Final'.toString())">
                                                                                AND  (DL.USERSEQUENCE||'.'||DL.SUBUSERSEQUENCE) <![CDATA[<=]]>  (BT.USERSEQUENCE||'.'||BT.SUBUSERSEQUENCE)
                                                                                AND  DL.WORKCOUNT <![CDATA[<=]]>  BT.WORKCOUNT
            </if>
             WHERE 1=1
               AND DL.SUMMARYTYPE = 'Normal'
            <if test="P_EXCEPTDEFECTCLASS != null and P_EXCEPTDEFECTCLASS !='' and !(P_EXCEPTDEFECTCLASS eq '*'.toString())">
               AND DL.DEFECTCODECLASSID NOT IN (SELECT regexp_substr(#{P_EXCEPTDEFECTCLASS}, '[^,]+', 1, LEVEL)
                                                  FROM dual
                                                CONNECT BY LEVEL <![CDATA[<=]]> length(#{P_EXCEPTDEFECTCLASS})-length(replace(#{P_EXCEPTDEFECTCLASS},',',''))+1)
            </if>
            UNION ALL
            SELECT DL.*
              FROM      BASETGT    BT
              LEFT JOIN FN_GETYIELDDEFECTLIST(BT.LOTID, #{LANGUAGETYPE})    DL    ON DL.LOTID = BT.LOTID
             WHERE 1=1
               AND DL.SUMMARYTYPE = 'CompleteDefect'
            <if test="P_EXCEPTDEFECTCLASS != null and P_EXCEPTDEFECTCLASS !='' and !(P_EXCEPTDEFECTCLASS eq '*'.toString())">
               AND DL.DEFECTCODECLASSID NOT IN (SELECT regexp_substr(#{P_EXCEPTDEFECTCLASS}, '[^,]+', 1, LEVEL)
                                                  FROM dual
                                                CONNECT BY LEVEL <![CDATA[<=]]> length(#{P_EXCEPTDEFECTCLASS})-length(replace(#{P_EXCEPTDEFECTCLASS},',',''))+1)
            </if>
        ),
        DFSUM AS
        (
            SELECT DD.LOTID
            <choose>
            <when test="P_INTERPLANTID != null and P_INTERPLANTID !='' and !(P_INTERPLANTID eq '*'.toString())">
                 , DD.DISCOVERYSITE    AS PLANTID
            </when>
            <otherwise>
                 , ''                  AS PLANTID
            </otherwise>
            </choose>
                 , DD.DISCOVERYSITE
                 , DD.PROCESSSEGMENTNAME
                 , DD.DEFECTCODE
                 , DD.DEFECTNAME
                 , DD.DEFECTQTY
                 , DD.QCSEGMENTNAME
                 , DD.REASONSITE
                 , DD.REASONCONSUMABLEDEFNAME                      /*원인 품목명*/
                 , DD.REASONSEGMENTNAME                            /*원인 공정명*/
                 , DD.REASONAREANAME
                 , DD.QCSEGMENTID
              FROM LOTDFDTL    DD
             WHERE DD.DEFECTQTY <![CDATA[<>]]> 0
            <if test="P_INTERPLANTID != null and P_INTERPLANTID !='' and !(P_INTERPLANTID eq '*'.toString())">
               AND DD.DISCOVERYSITE = #{P_INTERPLANTID}
            </if>
        ),
        DAT AS
        (
            SELECT BT.LOCALE
                 , BT.SHIPMENTSITE
                 , BT.RELATEDSITE
                 , CASE WHEN BT.LOCALE = 'Local' THEN BT.SHIPMENTSITE
                   ELSE DS.PLANTID
                   END                               AS INTERSECTSITE
                 , BT.PRODUCTSHAPE
                 , BT.CUSTOMERID
                 , BT.COMPANYCLIENT
                 , BT.PRODUCTDEFNAME
                 , BT.RELATEPLANTID
                 , BT.PLANTID
                 , CASE WHEN BT.PCSINPUTQTY IS NULL THEN IQ.INPUTQTY
                   ELSE BT.PCSINPUTQTY
                   END                                AS PCSINPUTQTY
                 , BT.ROOTLOTID
                 , BT.LOTID
                 , BT.LOTCREATEDPLANTID
                 , BT.PRODUCTDEFID
                 , BT.PRODUCTDEFVERSION
                 , BT.PROCESSDEFID
                 , BT.PROCESSDEFVERSION
                 , BT.PROCESSSEGMENTID
                 , BT.USERSEQUENCE
                 , BT.SUBUSERSEQUENCE
                 , BT.WORKCOUNT
                 , BT.INSPPROCESSSEGMENT
                 , BT.SUMMARYTYPE
                 , BT.SUMMARYDATE
                 , BT.SENDTIME
                 , BT.CREATEDTIME
                 , BT.ROOTCOMPLETE
                 , BT.M2SIZE
                 , BT.AREADIV
                 , BT.UNITPRICE
                 , BT.CURRENCY
                 , BT.PRODUCTDEFTYPE
                 , CASE WHEN BT.PCSINPUTQTY IS NULL THEN NVL(IQ.INPUTQTY, 0) - NVL(DS.DEFECTQTY, 0)
                   ELSE NVL(BT.PCSINPUTQTY, 0) - NVL(DS.DEFECTQTY, 0)
                   END                               AS PCSNORMALQTY
                 , NVL(DS.DEFECTQTY, 0)              AS PCSDEFECTQTY
                 , DS.DISCOVERYSITE
                 , DS.PROCESSSEGMENTNAME
                 , DS.DEFECTCODE
                 , DS.DEFECTNAME
                 , DS.QCSEGMENTID
                 , DS.QCSEGMENTNAME
                 , DS.REASONSITE
                 , DS.REASONCONSUMABLEDEFNAME
                 , DS.REASONSEGMENTNAME
                 , DS.REASONAREANAME
                 , DS.DEFECTQTY*BT.UNITPRICE                      AS PRICEDEFECTQTY
                 , BT.PCSINPUTQTY                                 AS INPUTQTY                 
              FROM      BASETGT                     BT
              LEFT JOIN DFSUM                       DS   ON   DS.LOTID = BT.LOTID
              LEFT JOIN FN_GETYIELDINPUTQTY2(BT.LOTID, BT.LOTCREATEDPLANTID)
                                                    IQ   ON   BT.LOTID = IQ.LOTID
                                                         AND  IQ.RNK   = 1
        ),
        <if test="P_LOTSTANDARD != null and P_LOTSTANDARD !='' and (P_LOTSTANDARD eq 'ROOTLOT'.toString())">
        ROOTINPUTQTY AS
        (
            SELECT D.ROOTLOTID
            <if test="P_INTERPLANTID != null and P_INTERPLANTID !='' and !(P_INTERPLANTID eq '*'.toString())">
                 , D.INTERSECTSITE
            </if>
                 , NVL(SUM(D.PCSINPUTQTY), 0)     AS INPUTQTY
              FROM
                   (
                      SELECT DISTINCT ROOTLOTID
                           , LOTID
                           , INTERSECTSITE
                           , PCSINPUTQTY
                        FROM DAT
                   ) D
            GROUP BY D.ROOTLOTID
            <if test="P_INTERPLANTID != null and P_INTERPLANTID !='' and !(P_INTERPLANTID eq '*'.toString())">
                   , D.INTERSECTSITE
            </if>
        ),
        </if>
        FIN AS
        (
            SELECT F.PRODUCTSHAPE
                 , F.COMPANYCLIENT
                 , F.PRODUCTDEFNAME
                 , F.PRODUCTDEFID
                 , F.PRODUCTDEFVERSION
                 , F.LOCALE
                 , F.SHIPMENTSITE
                 , F.RELATEDSITE
                 , F.INTERSECTSITE                 
                 , F.ROOTLOTID
                 , F.LOTID
                 , F.PROCESSSEGMENTID
                 , F.PCSINPUTQTY
                 , NVL(F.PCSDEFECTQTY, 0)                                                   AS PCSDEFECTQTY
                 , F.PCSNORMALQTY
                 , ROUND((F.PCSINPUTQTY/F.AREADIV), 2)                                      AS AREAINPUTQTY
                 , ROUND((F.PCSDEFECTQTY/F.AREADIV), 2)                                     AS AREADEFECTQTY
                 , ROUND((F.PCSNORMALQTY/F.AREADIV), 2)                                     AS AREANORMALQTY
                 , (F.UNITPRICE*F.PCSINPUTQTY)/NVL(E.EXCHANGE_RATE, 1)                      AS PRICEINPUTQTY
                 , (F.UNITPRICE*F.PCSDEFECTQTY)/NVL(E.EXCHANGE_RATE, 1)                     AS PRICEDEFECTQTY
                 , (F.UNITPRICE*F.PCSNORMALQTY)/NVL(E.EXCHANGE_RATE, 1)                     AS PRICENORMALQTY
                 , F.INSPPROCESSSEGMENT
                 , F.ROOTCOMPLETE
                 , F.PRODUCTDEFTYPE
                 , F.SUMMARYDATE
                 , F.CREATEDTIME
                 , F.QCSEGMENTID||F.DEFECTCODE                                              AS JOINCODE
                 , F.DEFECTNAME||NVL2(F.QCSEGMENTNAME, '-'||F.QCSEGMENTNAME, '')            AS JOINNAME
            FROM DAT F
            <choose>
            <when test="PLANT eq 'IFC'.toString()">
              LEFT OUTER JOIN  QAM_YIELD_EXCHANGE_V E ON E.PLANTID = #{PLANT} AND E.CURRENCY_CODE = 'KRW'
            </when>
            <when test="PLANT eq 'IFV'.toString()">
              LEFT OUTER JOIN  QAM_YIELD_EXCHANGE_V E ON E.PLANTID = #{PLANT} AND E.CURRENCY_CODE = 'VND'
            </when>
            <when test="PLANT eq 'CCV'.toString()">
              LEFT OUTER JOIN  QAM_YIELD_EXCHANGE_V E ON E.PLANTID = #{PLANT} AND E.CURRENCY_CODE = 'CNY'
            </when>
            <otherwise>
              LEFT OUTER JOIN  QAM_YIELD_EXCHANGE_V E ON E.PLANTID = #{PLANT} AND E.CURRENCY_CODE = 'USD'
            </otherwise>
            </choose>
             WHERE 1=1
               AND F.PCSINPUTQTY IS NOT NULL
               AND F.PCSINPUTQTY != 0
            <if test="P_LOCALEDIV != null and P_LOCALEDIV !='' and !(P_LOCALEDIV eq '*'.toString())">
               AND UPPER(F.LOCALE) = #{P_LOCALEDIV}
            </if>
            <if test="P_LINKPLANTID != null and P_LINKPLANTID !='' and !(P_LINKPLANTID eq '*'.toString())">
               AND F.RELATEDSITE IN (SELECT regexp_substr(#{P_LINKPLANTID}, '[^,]+', 1, LEVEL)
                                       FROM dual
                                     CONNECT BY LEVEL <![CDATA[<=]]> length(#{P_LINKPLANTID})-length(replace(#{P_LINKPLANTID},',',''))+1)
            </if>
            <if test="P_INTERPLANTID != null and P_INTERPLANTID !='' and !(P_INTERPLANTID eq '*'.toString())">
               /*2021.06.17 TOBE Modify 화면단에서 하나의 값만 넘김
               --AND F.INTERSECTSITE IN (SELECT VALUE FROM UFN_SELECTSTRINGTOSPLIT({P_INTERPLANTID}, ','))*/
               AND F.INTERSECTSITE = #{P_INTERPLANTID}
            </if>
            <if test="P_PRODSHAPETYPE != null and P_PRODSHAPETYPE !='' and !(P_PRODSHAPETYPE eq '*'.toString())">
               AND F.PRODUCTSHAPE = #{P_PRODSHAPETYPE}
            </if>
            <if test="P_CUSTOMER != null and P_CUSTOMER !=''">
               AND F.CUSTOMERID IN (SELECT regexp_substr(#{P_CUSTOMER}, '[^,]+', 1, LEVEL)
                                      FROM dual
                                    CONNECT BY LEVEL <![CDATA[<=]]> length(#{P_CUSTOMER})-length(replace(#{P_CUSTOMER},',',''))+1)
            </if>
            <if test="P_PLANTID != null and P_PLANTID !='' and !(P_PLANTID eq '*'.toString())">
               /*--2021.06.17 TOBE Modify 화면단에서 하나의 값만 넘김
               AND F.SHIPMENTSITE IN (SELECT VALUE FROM UFN_SELECTSTRINGTOSPLIT({P_PLANTID}, ','))*/
               AND F.SHIPMENTSITE = #{P_PLANTID}
            </if>
            <if test="P_LOTSTANDARD != null and P_LOTSTANDARD !='' and (P_LOTSTANDARD eq 'ROOTLOT'.toString())">
               AND F.ROOTCOMPLETE = 'COMPLETE'
            </if>
        ),
        FB AS
        (
            SELECT DISTINCT
                   F.PRODUCTSHAPE
                 , F.COMPANYCLIENT
                 , F.PRODUCTDEFNAME
                 , F.PRODUCTDEFID
                 , F.LOCALE
                 , F.SHIPMENTSITE
                 , F.RELATEDSITE
                 , F.ROOTLOTID
                 , F.LOTID
                 , ''                                                      AS INTERSECTSITE
                 , F.PRODUCTDEFVERSION
                 , ''                                                      AS JOINCODE
                 , ''                                                      AS JOINNAME
                 , MAX(F.PROCESSSEGMENTID)   OVER(PARTITION BY F.LOTID)    AS PROCESSSEGMENTID
                 , MAX(F.PCSINPUTQTY)        OVER(PARTITION BY F.LOTID)    AS PCSINPUTQTY
                 , SUM(F.PCSDEFECTQTY)       OVER(PARTITION BY F.LOTID)    AS PCSDEFECTQTY
                 , MAX(F.AREAINPUTQTY)       OVER(PARTITION BY F.LOTID)    AS AREAINPUTQTY
                 , SUM(F.AREADEFECTQTY)      OVER(PARTITION BY F.LOTID)    AS AREADEFECTQTY
                 , MAX(F.PRICEINPUTQTY)      OVER(PARTITION BY F.LOTID)    AS PRICEINPUTQTY
                 , SUM(F.PRICEDEFECTQTY)     OVER(PARTITION BY F.LOTID)    AS PRICEDEFECTQTY
                 , MAX(F.INSPPROCESSSEGMENT) OVER(PARTITION BY F.LOTID)    AS INSPPROCESSSEGMENT
                 , F.PRODUCTDEFTYPE
                 , MAX(F.SUMMARYDATE)        OVER(PARTITION BY F.LOTID)    AS SUMMARYDATE
                 , MAX(F.CREATEDTIME)        OVER(PARTITION BY F.LOTID)    AS CREATEDTIME                 
              FROM FIN F
        ),
        FINBASETOT AS
        (
            SELECT S.PRODUCTSHAPE
                 , S.COMPANYCLIENT
                 , S.PRODUCTDEFNAME
                 , S.PRODUCTDEFID
                 , S.LOCALE
                 , S.SHIPMENTSITE
                 , S.RELATEDSITE
                 , S.INTERSECTSITE
                 , S.PRODUCTDEFVERSION
                 , S.JOINCODE
                 , S.JOINNAME                 
                 , S.PROCESSSEGMENTID
                 , S.PCSINPUTQTY
                 , S.PCSDEFECTQTY
                 , S.PCSINPUTQTY-S.PCSDEFECTQTY        AS PCSNORMALQTY
                 , S.AREAINPUTQTY
                 , S.AREADEFECTQTY
                 , S.AREAINPUTQTY-S.AREADEFECTQTY      AS AREANORMALQTY
                 , S.PRICEINPUTQTY
                 , S.PRICEDEFECTQTY
                 , S.PRICEINPUTQTY-S.PRICEDEFECTQTY    AS PRICENORMALQTY
                 , S.INSPPROCESSSEGMENT
                 , S.PRODUCTDEFTYPE
                 , S.SUMMARYDATE
                 , S.CREATEDTIME                 
            FROM
            (
                SELECT DISTINCT
                       F.PRODUCTSHAPE
                     , F.COMPANYCLIENT
                     , F.PRODUCTDEFNAME
                     , F.PRODUCTDEFID
                     , F.LOCALE
                     , F.SHIPMENTSITE
                     , F.RELATEDSITE
                     , F.INTERSECTSITE
                     , F.PRODUCTDEFVERSION
                     , F.JOINCODE
                     , F.JOINNAME
                     , MAX(F.PROCESSSEGMENTID)   OVER(PARTITION BY F.PRODUCTDEFID, F.PRODUCTDEFVERSION) AS PROCESSSEGMENTID
                     , SUM(F.PCSINPUTQTY)        OVER(PARTITION BY F.PRODUCTDEFID, F.PRODUCTDEFVERSION) AS PCSINPUTQTY
                     , SUM(F.PCSDEFECTQTY)       OVER(PARTITION BY F.PRODUCTDEFID, F.PRODUCTDEFVERSION) AS PCSDEFECTQTY
                     , SUM(F.AREAINPUTQTY)       OVER(PARTITION BY F.PRODUCTDEFID, F.PRODUCTDEFVERSION) AS AREAINPUTQTY
                     , SUM(F.AREADEFECTQTY)      OVER(PARTITION BY F.PRODUCTDEFID, F.PRODUCTDEFVERSION) AS AREADEFECTQTY
                     , SUM(F.PRICEINPUTQTY)      OVER(PARTITION BY F.PRODUCTDEFID, F.PRODUCTDEFVERSION) AS PRICEINPUTQTY
                     , SUM(F.PRICEDEFECTQTY)     OVER(PARTITION BY F.PRODUCTDEFID, F.PRODUCTDEFVERSION) AS PRICEDEFECTQTY
                     , MAX(F.INSPPROCESSSEGMENT) OVER(PARTITION BY F.PRODUCTDEFID, F.PRODUCTDEFVERSION) AS INSPPROCESSSEGMENT
                     , F.PRODUCTDEFTYPE
                     , MAX(F.SUMMARYDATE)        OVER(PARTITION BY F.PRODUCTDEFID, F.PRODUCTDEFVERSION) AS SUMMARYDATE
                     , MAX(F.CREATEDTIME)        OVER(PARTITION BY F.PRODUCTDEFID, F.PRODUCTDEFVERSION) AS CREATEDTIME
                FROM FB F
            ) S
        ),
        DFCODERANK AS
        (
            SELECT D.*
                 , F.INPUTQTY
                 , ROUND((D.DEFECTQTY/F.INPUTQTY)*100, 2)    AS DEFECTRATE
              FROM
                      (
                          SELECT D.PRODUCTDEFID
                               , D.PRODUCTDEFVERSION
                               , D.JOINCODE
                               , D.JOINNAME
                          <choose>
                              <when test="P_YIELDQTYSTANDARD eq 'PCS'.toString()">                               
                               , SUM(D.PCSDEFECTQTY)           AS DEFECTQTY
                              </when>
                              <when test="P_YIELDQTYSTANDARD eq 'AREA'.toString()">                               
                               , SUM(D.AREADEFECTQTY)          AS DEFECTQTY
                              </when>
                              <otherwise>
                               , SUM(D.PRICEDEFECTQTY)         AS DEFECTQTY
                              </otherwise>
                          </choose>
                            FROM FIN D <!-- DAT D -->
                          GROUP BY D.PRODUCTDEFID
                                 , D.PRODUCTDEFVERSION
                                 , D.JOINCODE
                                 , D.JOINNAME
                      ) D
              LEFT JOIN
                      (
                          SELECT DISTINCT
                                 FBT.PRODUCTDEFID
                               , FBT.PRODUCTDEFVERSION
                          <choose>
                              <when test="P_YIELDQTYSTANDARD eq 'PCS'.toString()">                               
                               , FBT.PCSINPUTQTY               AS INPUTQTY
                              </when>
                              <when test="P_YIELDQTYSTANDARD eq 'AREA'.toString()">                               
                               , FBT.AREAINPUTQTY              AS INPUTQTY
                              </when>
                              <otherwise>
                               , FBT.PRICEINPUTQTY             AS INPUTQTY
                              </otherwise>
                          </choose>                               
                            FROM FINBASETOT FBT
                      ) F ON   D.PRODUCTDEFID      = F.PRODUCTDEFID
                          AND  D.PRODUCTDEFVERSION = F.PRODUCTDEFVERSION
             WHERE D.JOINCODE IS NOT NULL
        ),
        DRANK AS
        (
            SELECT D.*
                 , DENSE_RANK() OVER(PARTITION BY D.PRODUCTDEFID, D.PRODUCTDEFVERSION ORDER BY D.DEFECTRATE DESC, D.JOINCODE ASC)    AS RNK
              FROM DFCODERANK D
        )
        SELECT LD.*            
          FROM
                (
                    SELECT FBT.SHIPMENTSITE
                         , FBT.PRODUCTDEFID
                         , FBT.PRODUCTDEFNAME
                         , FBT.PRODUCTDEFVERSION
                    <choose>
                        <when test="P_YIELDQTYSTANDARD eq 'PCS'.toString()">
                         , CASE WHEN NVL(FBT.PCSINPUTQTY, 0) = 0 THEN 0
                           ELSE ROUND((FBT.PCSDEFECTQTY/FBT.PCSINPUTQTY)*100, 2)    
                           END                                                                           AS DEFECTRATE
                         , 100-(CASE WHEN NVL(FBT.PCSINPUTQTY, 0) = 0 THEN 0
                                ELSE ROUND((FBT.PCSDEFECTQTY/FBT.PCSINPUTQTY)*100, 2)    
                                END)                                                                     AS YIELDRATE 
                         , FBT.PCSINPUTQTY        AS INPUTQTY
                         , FBT.PCSDEFECTQTY       AS DEFECTQTY
                         , FBT.PCSNORMALQTY       AS NORMALQTY                        
                        </when>
                        <when test="P_YIELDQTYSTANDARD eq 'AREA'.toString()">
                         , CASE WHEN NVL(FBT.AREAINPUTQTY, 0) = 0 THEN 0
                           ELSE ROUND((FBT.AREADEFECTQTY/FBT.AREAINPUTQTY)*100, 2)    
                           END                                                                           AS DEFECTRATE
                         , 100-(CASE WHEN NVL(FBT.AREAINPUTQTY, 0) = 0 THEN 0
                                ELSE ROUND((FBT.AREADEFECTQTY/FBT.AREAINPUTQTY)*100, 2)    
                                END)                                                                     AS YIELDRATE
                         , FBT.AREAINPUTQTY       AS INPUTQTY
                         , FBT.AREADEFECTQTY      AS DEFECTQTY
                         , FBT.AREANORMALQTY      AS NORMALQTY
                        </when>
                        <otherwise>
                         , CASE WHEN NVL(FBT.PRICEINPUTQTY, 0) = 0 THEN 0
                           ELSE ROUND((FBT.PRICEDEFECTQTY/FBT.PRICEINPUTQTY)*100, 2)    
                           END                                                                           AS DEFECTRATE
                         , 100-(CASE WHEN NVL(FBT.AREAINPUTQTY, 0) = 0 THEN 0
                                ELSE ROUND((FBT.PRICEDEFECTQTY/FBT.PRICEINPUTQTY)*100, 2)    
                                END)                                                                     AS YIELDRATE                        
                         , FBT.PRICEINPUTQTY      AS INPUTQTY
                         , FBT.PRICEDEFECTQTY     AS DEFECTQTY
                         , FBT.PRICENORMALQTY     AS NORMALQTY
                        </otherwise>
                    </choose>
                         , DOI.TOTALDEFECTQTY
                         , CASE WHEN NVL(DOI.TOTALDEFECTQTY, 0) = 0 THEN 0
                           ELSE ROUND((FBT.PCSDEFECTQTY/DOI.TOTALDEFECTQTY)*100, 2)
                           END                                                                           AS DEFECTOCCUPANCY
                         , D1.JOINNAME                                                                   AS DEFECTNAME1
                         , D1.DEFECTQTY                                                                  AS DEFECTQTY1
                         , D1.DEFECTRATE                                                                 AS DEFECTRATE1
                         , D2.JOINNAME                                                                   AS DEFECTNAME2
                         , D2.DEFECTQTY                                                                  AS DEFECTQTY2
                         , D2.DEFECTRATE                                                                 AS DEFECTRATE2
                         , D3.JOINNAME                                                                   AS DEFECTNAME3
                         , D3.DEFECTQTY                                                                  AS DEFECTQTY3
                         , D3.DEFECTRATE                                                                 AS DEFECTRATE3
                         , D4.JOINNAME                                                                   AS DEFECTNAME4
                         , D4.DEFECTQTY                                                                  AS DEFECTQTY4
                         , D4.DEFECTRATE                                                                 AS DEFECTRATE4
                         , D5.JOINNAME                                                                   AS DEFECTNAME5
                         , D5.DEFECTQTY                                                                  AS DEFECTQTY5
                         , D5.DEFECTRATE                                                                 AS DEFECTRATE5
                         , D6.JOINNAME                                                                   AS DEFECTNAME6
                         , D6.DEFECTQTY                                                                  AS DEFECTQTY6
                         , D6.DEFECTRATE                                                                 AS DEFECTRATE6
                         , D7.JOINNAME                                                                   AS DEFECTNAME7
                         , D7.DEFECTQTY                                                                  AS DEFECTQTY7
                         , D7.DEFECTRATE                                                                 AS DEFECTRATE7
                         , D8.JOINNAME                                                                   AS DEFECTNAME8
                         , D8.DEFECTQTY                                                                  AS DEFECTQTY8
                         , D8.DEFECTRATE                                                                 AS DEFECTRATE8
                         , D9.JOINNAME                                                                   AS DEFECTNAME9
                         , D9.DEFECTQTY                                                                  AS DEFECTQTY9
                         , D9.DEFECTRATE                                                                 AS DEFECTRATE9
                         , D10.JOINNAME                                                                  AS DEFECTNAME10
                         , D10.DEFECTQTY                                                                 AS DEFECTQTY10
                         , D10.DEFECTRATE                                                                AS DEFECTRATE10
                         , D11.DEFECTNAME                                                                AS EXTDEFECTNAME
                         , D11.DEFECTQTY                                                                 AS EXTDEFECTQTY
                         , D11.DEFECTRATE                                                                AS EXTDEFECTRATE
                    FROM       FINBASETOT FBT
                    CROSS JOIN ( SELECT 
                                 <choose>
                                     <when test="P_YIELDQTYSTANDARD eq 'PCS'.toString()">
                                        SUM(PCSDEFECTQTY) AS TOTALDEFECTQTY
                                     </when>
                                     <when test="P_YIELDQTYSTANDARD eq 'AREA'.toString()">
                                        SUM(AREADEFECTQTY) AS TOTALDEFECTQTY
                                     </when>
                                     <otherwise>
                                        SUM(PRICEDEFECTQTY) AS TOTALDEFECTQTY
                                     </otherwise> 
                                 </choose>
                                   FROM FINBASETOT ) DOI
                    LEFT JOIN  DRANK      D1         ON   FBT.PRODUCTDEFID       = D1.PRODUCTDEFID
                                                     AND  FBT.PRODUCTDEFVERSION  = D1.PRODUCTDEFVERSION
                                                     AND  D1.RNK                 = 1
                    LEFT JOIN  DRANK      D2         ON   FBT.PRODUCTDEFID       = D2.PRODUCTDEFID
                                                     AND  FBT.PRODUCTDEFVERSION  = D2.PRODUCTDEFVERSION
                                                     AND  D2.RNK                 = 2
                    LEFT JOIN  DRANK      D3         ON   FBT.PRODUCTDEFID       = D3.PRODUCTDEFID
                                                     AND  FBT.PRODUCTDEFVERSION  = D3.PRODUCTDEFVERSION
                                                     AND  D3.RNK                 = 3
                    LEFT JOIN  DRANK      D4         ON   FBT.PRODUCTDEFID       = D4.PRODUCTDEFID
                                                     AND  FBT.PRODUCTDEFVERSION  = D4.PRODUCTDEFVERSION
                                                     AND  D4.RNK                 = 4
                    LEFT JOIN  DRANK      D5         ON   FBT.PRODUCTDEFID       = D5.PRODUCTDEFID
                                                     AND  FBT.PRODUCTDEFVERSION  = D5.PRODUCTDEFVERSION
                                                     AND  D5.RNK                 = 5
                    LEFT JOIN  DRANK      D6         ON   FBT.PRODUCTDEFID       = D6.PRODUCTDEFID
                                                     AND  FBT.PRODUCTDEFVERSION  = D6.PRODUCTDEFVERSION
                                                     AND  D6.RNK                 = 6
                    LEFT JOIN  DRANK      D7         ON   FBT.PRODUCTDEFID       = D7.PRODUCTDEFID
                                                     AND  FBT.PRODUCTDEFVERSION  = D7.PRODUCTDEFVERSION
                                                     AND  D7.RNK                 = 7
                    LEFT JOIN  DRANK      D8         ON   FBT.PRODUCTDEFID       = D8.PRODUCTDEFID
                                                     AND  FBT.PRODUCTDEFVERSION  = D8.PRODUCTDEFVERSION
                                                     AND  D8.RNK                 = 8
                    LEFT JOIN  DRANK      D9         ON   FBT.PRODUCTDEFID       = D9.PRODUCTDEFID
                                                     AND  FBT.PRODUCTDEFVERSION  = D9.PRODUCTDEFVERSION
                                                     AND  D9.RNK                 = 9
                    LEFT JOIN  DRANK      D10        ON   FBT.PRODUCTDEFID       = D10.PRODUCTDEFID
                                                     AND  FBT.PRODUCTDEFVERSION  = D10.PRODUCTDEFVERSION
                                                     AND  D10.RNK                = 10
                    LEFT JOIN (
                                SELECT FBT.PRODUCTDEFID
                                     , FBT.PRODUCTDEFVERSION
                                     , 'ETC'                                         AS DEFECTNAME
                                     , ''                                            AS QCSEGMENTNAME
                                     , SUM(D0.DEFECTQTY)                             AS DEFECTQTY
                                     , ROUND(SUM(D0.DEFECTQTY)/MAX(D0.INPUTQTY)*100, 2)  AS DEFECTRATE
                                  FROM      FINBASETOT FBT
                                  LEFT JOIN DRANK      D0   ON   FBT.PRODUCTDEFID       = D0.PRODUCTDEFID
                                                            AND  FBT.PRODUCTDEFVERSION  = D0.PRODUCTDEFVERSION
                                                            AND  D0.RNK                 > 10
                                GROUP BY FBT.PRODUCTDEFID
                                       , FBT.PRODUCTDEFVERSION
                               ) D11     ON   FBT.PRODUCTDEFID      = D11.PRODUCTDEFID
                                         AND  FBT.PRODUCTDEFVERSION = D11.PRODUCTDEFVERSION
                ) LD
        ORDER BY LD.DEFECTRATE DESC
    </select>
</mapper>